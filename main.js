/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __glob = (map) => (path) => {
  var fn = map[path];
  if (fn) return fn();
  throw new Error("Module not found in bundle: " + path);
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/constants.ts
var DEFAULT_SETTINGS, UNIVERSAL_FORBIDDEN_CHARS, WINDOWS_ANDROID_CHARS, TITLE_CHAR_REVERSAL_MAP;
var init_constants = __esm({
  "src/constants.ts"() {
    DEFAULT_SETTINGS = {
      folderScopeStrategy: "Only exclude...",
      tagScopeStrategy: "Only exclude...",
      propertyScopeStrategy: "Only exclude...",
      excludedFolders: [""],
      excludedTags: [""],
      excludedProperties: [],
      charCount: 100,
      checkInterval: 0,
      osPreset: "macOS",
      charReplacements: {
        slash: " \u2215 ",
        colon: "\u0589",
        asterisk: "\u2217",
        question: "\uFE56",
        lessThan: "\u2039",
        greaterThan: "\u203A",
        quote: "\uFF02",
        pipe: "\u2758",
        hash: "\uFF03",
        leftBracket: "\uFF3B",
        rightBracket: "\uFF3D",
        caret: "\u02C6",
        backslash: "\u29F5",
        dot: "\u2024"
      },
      charReplacementEnabled: {
        slash: false,
        colon: false,
        asterisk: false,
        question: false,
        lessThan: false,
        greaterThan: false,
        quote: false,
        pipe: false,
        hash: false,
        leftBracket: false,
        rightBracket: false,
        caret: false,
        backslash: false,
        dot: true
      },
      charReplacementTrimLeft: {
        slash: false,
        colon: false,
        asterisk: false,
        question: false,
        lessThan: false,
        greaterThan: false,
        quote: false,
        pipe: false,
        hash: false,
        leftBracket: true,
        rightBracket: true,
        caret: false,
        backslash: false,
        dot: false
      },
      charReplacementTrimRight: {
        slash: false,
        colon: false,
        asterisk: false,
        question: false,
        lessThan: false,
        greaterThan: false,
        quote: false,
        pipe: false,
        hash: false,
        leftBracket: true,
        rightBracket: true,
        caret: false,
        backslash: false,
        dot: false
      },
      customReplacements: [
        { searchText: "- [ ] ", replaceText: "\u2714\uFE0F ", onlyAtStart: true, onlyWholeLine: false, enabled: false },
        { searchText: "- [x] ", replaceText: "\u2705 ", onlyAtStart: true, onlyWholeLine: false, enabled: false }
      ],
      safewords: [
        { text: "To do", onlyAtStart: false, onlyWholeLine: false, enabled: false, caseSensitive: false }
      ],
      omitComments: false,
      omitHtmlTags: false,
      stripTemplaterSyntax: true,
      enableStripMarkup: true,
      stripMarkupSettings: {
        headings: true,
        bold: true,
        italic: true,
        strikethrough: true,
        highlight: true,
        wikilinks: true,
        markdownLinks: true,
        quote: true,
        callouts: true,
        unorderedLists: true,
        orderedLists: true,
        taskLists: true,
        code: true,
        codeBlocks: true,
        footnotes: true,
        comments: true,
        htmlTags: true
      },
      stripMarkupInAlias: false,
      stripCommentsEntirely: true,
      applyCustomRulesInAlias: false,
      enableForbiddenCharReplacements: false,
      enableCustomReplacements: false,
      applyCustomRulesAfterForbiddenChars: false,
      applyCustomRulesAfterMarkupStripping: false,
      enableSafewords: false,
      renameOnFocus: false,
      renameOnSave: false,
      renameNotes: "automatically",
      manualNotificationMode: "Always",
      windowsAndroidEnabled: false,
      hasEnabledForbiddenChars: false,
      hasEnabledWindowsAndroid: false,
      hasEnabledCustomReplacements: false,
      hasEnabledSafewords: false,
      hasEnabledAliases: false,
      grabTitleFromCardLink: true,
      stripTableMarkup: true,
      excludeSubfolders: true,
      tagMatchingMode: "In Properties and note body",
      excludeChildTags: true,
      fileReadMethod: "Editor",
      // Default to editor method
      verboseLogging: false,
      // Added default for verbose logging
      debugOutputFullContent: false,
      // Default OFF for debug content output
      debugEnabledTimestamp: "",
      // No debug enabled timestamp yet
      hasShownFirstTimeNotice: false,
      // First-time notice not shown yet
      hasSetupExclusions: false,
      // Exclusions tab not opened yet
      hasSetPropertyType: false,
      // Property type not set yet
      lastUsageDate: "",
      // No usage date yet
      currentSettingsTab: "general",
      // Default to general tab
      commandVisibility: {
        folderPutFirstLineInTitle: true,
        folderExclude: true,
        folderStopExcluding: true,
        filePutFirstLineInTitle: true,
        fileExclude: true,
        fileStopExcluding: true,
        tagPutFirstLineInTitle: true,
        tagExclude: true,
        tagStopExcluding: true,
        addSafeInternalLink: true,
        addSafeInternalLinkWithCaption: true
      },
      enableContextMenus: true,
      enableVaultSearchContextMenu: true,
      vaultSearchContextMenuVisibility: {
        putFirstLineInTitle: true,
        disable: true,
        enable: true
      },
      enableCommandPalette: true,
      commandPaletteVisibility: {
        renameCurrentFileUnlessExcluded: true,
        renameCurrentFile: true,
        renameAllFiles: true,
        disableRenaming: true,
        enableRenaming: true,
        toggleAutomaticRenaming: true
      },
      enableRibbon: true,
      ribbonVisibility: {
        renameCurrentFile: true,
        renameAllNotes: false,
        toggleAutomaticRenaming: false
      },
      enableAliases: false,
      truncateAlias: false,
      addAliasOnlyIfFirstLineDiffers: false,
      aliasPropertyKey: "aliases",
      hideAliasProperty: "never",
      hideAliasInSidebar: false,
      keepEmptyAliasProperty: true,
      whatToPutInTitle: "any_first_line_content",
      includeSubfolders: true,
      includeBodyTags: true,
      includeNestedTags: true,
      moveCursorToFirstLine: false,
      insertTitleOnCreation: false,
      placeCursorAtLineEnd: true,
      disableCursorInExcludedFolders: false,
      waitForCursorTemplate: false,
      suppressMergeNotifications: false,
      newNoteDelay: 0,
      waitForTemplate: false,
      addHeadingToTitle: false,
      disableRenamingKey: "no rename",
      disableRenamingValue: "true",
      modalCheckboxStates: {
        folderRename: {
          includeSubfolders: true,
          renameExcludedFolders: false,
          renameExcludedTags: false,
          renameExcludedProperties: false
        },
        tagRename: {
          includeChildTags: true,
          renameExcludedFolders: false,
          renameExcludedTags: false,
          renameExcludedProperties: false
        },
        searchRename: {
          renameExcludedFolders: false,
          renameExcludedTags: false,
          renameExcludedProperties: false
        },
        folderDisable: {
          includeSubfolders: true
        },
        tagDisable: {
          includeChildTags: true
        }
      }
    };
    UNIVERSAL_FORBIDDEN_CHARS = ["/", ":", "|", String.fromCharCode(92), "#", "[", "]", "^"];
    WINDOWS_ANDROID_CHARS = ["*", "?", "<", ">", '"'];
    TITLE_CHAR_REVERSAL_MAP = {
      "\u2215": "/",
      // Unicode: \u2215 -> slash
      "\u0589": ":",
      // Unicode: \u0589 -> colon
      "\u2217": "*",
      // Unicode: \u2217 -> asterisk
      "\uFE56": "?",
      // Unicode: \uFE56 -> question
      "\u2039": "<",
      // Unicode: \u2039 -> lessThan
      "\u203A": ">",
      // Unicode: \u203A -> greaterThan
      "\uFF02": '"',
      // Unicode: \uFF02 -> quote
      "\u2758": "|",
      // Unicode: \u2758 -> pipe
      "\uFF03": "#",
      // Unicode: \uFF03 -> hash
      "\uFF3B": "[",
      // Unicode: \uFF3B -> leftBracket
      "\uFF3D": "]",
      // Unicode: \uFF3D -> rightBracket
      "\u02C6": "^",
      // Unicode: \u02C6 -> caret
      "\u29F5": "\\",
      // Unicode: \u29F5 -> backslash
      "\u2024": "."
      // Unicode: \u2024 -> dot
    };
  }
});

// locale/en.json
var require_en = __commonJS({
  "locale/en.json"(exports, module2) {
    module2.exports = {
      untitled: "Untitled",
      table: "Table",
      commands: {
        putFirstLineInTitle: "Put first line in title",
        putFirstLineInTitleUnlessExcluded: "Put first line in title (unless excluded)",
        putFirstLineInTitleAllNotes: "Put first line in title in all notes",
        disableRenamingForNote: "Disable renaming for note",
        enableRenamingForNote: "Enable renaming for note",
        disableRenamingInFolder: "Disable renaming in folder",
        enableRenamingInFolder: "Enable renaming in folder",
        disableRenamingForTag: "Disable renaming for tag",
        enableRenamingForTag: "Enable renaming for tag",
        disableRenaming: "Disable renaming",
        enableRenaming: "Enable renaming",
        toggleAutomaticRenaming: "Toggle automatic renaming",
        addSafeInternalLink: "Add safe internal link",
        addSafeInternalLinkWithCaption: "Add safe internal link with caption",
        putFirstLineInTitleNFolders: {
          many: "Put first line in title ({{count}} folders)"
        },
        disableRenamingNFolders: {
          many: "Disable renaming ({{count}} folders)"
        },
        enableRenamingNFolders: {
          many: "Enable renaming ({{count}} folders)"
        },
        putFirstLineInTitleNNotes: {
          many: "Put first line in title ({{count}} notes)"
        },
        disableRenamingNNotes: {
          many: "Disable renaming ({{count}} notes)"
        },
        enableRenamingNNotes: {
          many: "Enable renaming ({{count}} notes)"
        },
        descriptions: {
          renameActiveNoteEvenExcluded: "Rename active note, even if in excluded folder or with excluded tag or property.",
          renameActiveNoteUnlessExcluded: "Rename active note except if in excluded folder or with excluded tag or property.",
          renameAllNotesExceptExcluded: "Rename all notes in vault except if in excluded folder or with excluded tag or property.",
          toggleRenameSetting: {
            part1: "Toggle the ",
            renameNotes: "Rename notes",
            part2: " setting between ",
            automatically: "Automatically",
            part3: " and ",
            manually: "Manually",
            part4: "."
          },
          excludeActiveNote: "Exclude active note from renaming.",
          stopExcludingActiveNote: "Stop excluding active note from renaming.",
          createLinkWithForbiddenChars: {
            part1: "Create internal link with forbidden characters handled as set in ",
            replaceCharacters: "Replace characters",
            part2: "."
          },
          createLinkWithValidPath: {
            part1: "Create internal link with forbidden characters handled as set in ",
            replaceCharacters: "Replace characters",
            part2: ", and with original text in caption."
          },
          renameNoteEvenExcluded: "Rename note, even if in excluded folder or with excluded tag.",
          excludeNote: "Exclude note from renaming.",
          stopExcludingNote: "Stop excluding note from renaming.",
          renameAllNotesInFolder: "Rename all notes in folder.",
          excludeFolder: "Exclude folder from renaming.",
          stopExcludingFolder: "Stop excluding folder from renaming.",
          renameAllNotesWithTag: "Rename all notes with tag.",
          excludeTag: "Exclude tag from renaming.",
          stopExcludingTag: "Stop excluding tag from renaming.",
          renameAllNotesInSearchResults: "Rename all notes in search results.",
          excludeAllNotesInSearchResults: "Exclude all notes in search results.",
          stopExcludingAllNotesInSearchResults: "Stop excluding all notes in search results from renaming."
        }
      },
      notifications: {
        errorNoActiveNote: "Error: no active note.",
        renamingNNotes: "Renaming {{count}} notes...",
        renamedNotes: "Renamed {{renamed}}/{{total}} notes.",
        renamedNotesWithErrors: "Renamed {{renamed}}/{{total}} notes with {{errors}} errors. Check console for details.",
        noNotesFoundWithTag: "No notes found with #{{tag}}.",
        noNotesFoundInFolders: "No notes found in selected folders.",
        disabledRenamingFor: "Disabled renaming for: {{filename}}",
        failedToDisable: "Failed to disable renaming. Check console for details.",
        enabledRenamingFor: "Enabled renaming for: {{filename}}",
        failedToEnable: "Failed to enable renaming. Check console for details.",
        automaticRenamingEnabled: "Automatic renaming enabled.",
        automaticRenamingDisabled: "Automatic renaming disabled.",
        settingsCleared: "Settings have been cleared.",
        firstTimeNotice: "Please open First Line is Title settings to set your preferences. Ensure your files are regularly backed up.",
        disabledRenamingForNNotes: "Disabled renaming for {{count}} notes.",
        enabledRenamingForNNotes: "Enabled renaming for {{count}} notes.",
        renamedTo: "Renamed to: {{filename}}",
        notRenamedSelfReference: "Note not renamed due to self-referential link in first line: {{filename}}",
        noNotesFoundInFolder: "No notes found in: {{folder}}",
        disabledRenamingInFolder: "Disabled renaming in: {{folder}}",
        enabledRenamingInFolder: "Enabled renaming in: {{folder}}",
        enabledRenamingInNFolders: "Enabled renaming in {{count}} folders.",
        disabledRenamingInNFolders: "Disabled renaming in {{count}} folders."
      },
      modals: {
        caution: "Caution",
        processNNotes: {
          one: {
            before: "This will process ",
            noun: "note",
            after: "."
          },
          many: {
            before: "This will process ",
            noun: "notes",
            after: "."
          }
        },
        ensure: "Ensure:",
        filesBackedUp: "Your files are backed up in case of errors.",
        exclusionsConfigured: "Excluded folders, tags and properties are configured correctly in plugin settings.",
        ensureFilesBackedUp: "Ensure your files are backed up in case of errors.",
        renameInAllSubfolders: "Rename notes in all subfolders",
        renameInExcludedFolders: "Rename notes in excluded folders",
        renameWithExcludedTags: "Rename notes with excluded tags",
        renameWithExcludedProperties: "Rename notes with excluded properties",
        renameWithChildTags: "Rename notes with child tags (e.g., #parent/child)",
        resetAllSettings: "This will reset all plugin settings to their default values and delete all custom rules. This cannot be undone.",
        addRemoveProperty: "This will add/remove the key:value property in {{count}} note(s).",
        disableEnableAddProperty: "This will add the property ",
        disableEnableRemoveProperty: "This will remove the property ",
        propertyTo: " to ",
        propertyFrom: " from ",
        internalLink: "Internal link",
        enterText: "Enter text...",
        backedUpLinkText: "backed up",
        processNotesMessage: {
          one: {
            before: "This will process ",
            noun: "note",
            after: "."
          },
          many: {
            before: "This will process ",
            noun: "notes",
            after: "."
          }
        },
        ensureBackup: "Ensure your files are backed up in case of errors.",
        propertyIn: " property in ",
        note: "note",
        noteFew: "notes",
        notes: "notes",
        notesPrepositional: "notes",
        buttons: {
          cancel: "Cancel",
          rename: "Rename",
          clearSettings: "Clear",
          disable: "Disable",
          enable: "Enable",
          add: "Add"
        }
      },
      ariaLabels: {
        restoreDefault: "Restore default",
        restoreDefaultContentRead: "Restore default content read method",
        remove: "Remove"
      },
      settings: {
        tabs: {
          general: "General",
          exclusions: "Exclusions",
          replaceCharacters: "Replace characters",
          customRules: "Custom rules",
          safewords: "Safewords",
          stripMarkup: "Strip markup",
          alias: "Alias",
          commands: "Commands",
          miscellaneous: "Miscellaneous"
        },
        general: {
          renameNotes: {
            name: "Rename notes",
            desc: "Set how notes should be processed.",
            automatically: "Automatically when modified while open",
            manually: "Manually with command only"
          },
          renameOnFocus: {
            name: "Rename on focus",
            desc: "Also process notes when they become active in the editor."
          },
          whatToPutInTitle: {
            name: "What to put in title",
            desc: "Set what first line content should be copied to filename.",
            anyText: "Any text",
            headingsOnly: "Headings only"
          },
          moveCursorToFirstLine: {
            name: "Move cursor to first line",
            desc: "Place the cursor in the first line when creating a new note."
          },
          placeCursorAtLineEnd: {
            name: "Place cursor at line end",
            desc: "When moving the cursor to a first line with content, place it at the end of the line instead of the start."
          },
          disableInExcludedFolders: {
            name: "Disable in excluded folders",
            desc: "Don't move the cursor when creating notes in excluded folders."
          },
          waitForTemplate: {
            name: "Wait for template",
            desc: "Move the cursor after a new note template is applied and it does not have an excluded tag or property."
          },
          insertTitleOnCreation: {
            name: "Insert title in first line on note creation",
            desc: {
              part1: "Place the filename in the first line when creating a new empty note (unless ",
              untitled: "Untitled",
              part2: "). Convert forbidden character replacements back to their original forms, as set in ",
              replaceCharacters: "Replace characters",
              part3: "."
            }
          },
          insertAfterTemplate: {
            name: "Insert after template",
            desc: "Let a new note template insert a Properties block before inserting the filename."
          },
          formatAsHeading: {
            name: "Format as heading",
            desc: "Make the first line a heading."
          },
          renameOnSave: {
            name: "Rename on save",
            desc: "Rename notes on manual save (Ctrl/Cmd-S on desktop by default)."
          },
          renameAllNotes: {
            name: "Rename all notes",
            desc: "Process all notes in the vault. Can also be run from the Command palette.",
            button: "Rename"
          },
          leaveFeedback: "Leave feedback"
        },
        exclusions: {
          desc: "Set how notes should be excluded from processing.",
          note: "Note: rules don't override other rules. For example, a note in excluded folder but with included tag will not be processed.",
          folders: {
            title: "Folders",
            desc: "Set folders to match.",
            renamedWarning: "Renamed, moved or deleted folders are not reflected below. Update manually if paths change.",
            matchSubfolders: {
              name: "Match subfolders",
              desc: "Also apply to all subfolders of folders listed below."
            },
            exclusionMode: {
              name: "Exclusion mode",
              desc: "Set how folders should be excluded.",
              onlyExclude: "Only exclude...",
              excludeAllExcept: "Exclude all except..."
            },
            placeholder: "Folder name",
            addButton: "Add folder"
          },
          tags: {
            title: "Tags",
            desc: "Set tags to match.",
            excludeAllNote: {
              part1: "",
              excludeAllExcept: "Exclude all except...",
              part2: " also excludes notes with no tags."
            },
            tagWranglerWarning: "Tags renamed with Tag Wrangler are not reflected below. Update manually after renaming.",
            matchTags: {
              name: "Match tags",
              desc: "Set where tags should be matched.",
              inPropertiesAndBody: "In Properties and note body",
              inPropertiesOnly: "In Properties only",
              inBodyOnly: "In note body only"
            },
            matchChildTags: {
              name: "Match child tags",
              desc: "For example, also match #parent/child if #parent is listed below."
            },
            exclusionMode: {
              name: "Exclusion mode",
              desc: "Set how tags should be excluded."
            },
            placeholder: "Tag name",
            addButton: "Add tag"
          },
          properties: {
            title: "Properties",
            desc: "Set properties to match.",
            leaveBlank: {
              part1: "Leave ",
              value: "value",
              part2: " blank to match all notes with this property key."
            },
            caseInsensitive: "Case-insensitive.",
            excludeAllNote: {
              part1: "",
              excludeAllExcept: "Exclude all except...",
              part2: " also excludes notes with no properties."
            },
            renamedWarning: "Renamed property keys aren't reflected below. Update manually after renaming.",
            exclusionMode: {
              name: "Exclusion mode",
              desc: "Set how properties should be excluded."
            },
            keyPlaceholder: "key",
            valuePlaceholder: "value",
            separator: ":",
            addButton: "Add property"
          },
          disableProperty: {
            title: "Property to disable renaming",
            desc: "Set the property to exclude notes from processing.",
            alwaysRespected: "Always respected \u2014 cannot get overridden by any command.",
            caseInsensitive: "Case-insensitive.",
            updateWarning: "Changing this will not automatically update properties that have been previously added to notes. Update manually after changing.",
            default: "Default: no rename:true"
          }
        },
        alias: {
          addAlias: {
            name: "Add alias",
            desc: "Always copy the first line to a property when renaming notes."
          },
          aliasPropertyName: {
            name: "Alias property name",
            desc: "Set the property key in which to insert the alias.",
            quickSwitcher: "Use 'aliases' to make the alias searchable in the Quick switcher.",
            multipleProperties: "To populate multiple properties, separate by comma (e.g., 'aliases, title').",
            noteTitle: {
              part1: "This property can be set as note title in ",
              part2: ", ",
              part3: " and ",
              part4: "."
            },
            default: "Default: aliases"
          },
          onlyAddIfDiffers: {
            name: "Only add alias if first line differs from title",
            desc: "For example, if the filename was truncated, or some characters have been omitted or replaced."
          },
          truncateAlias: {
            name: "Truncate alias",
            desc: {
              part1: "In accordance with the ",
              charCount: "Character count",
              part2: " value in ",
              miscellaneous: "Miscellaneous",
              part3: "."
            }
          },
          applyCustomRules: {
            name: "Apply custom rules",
            desc: {
              part1: "Apply custom text replacements to alias, as set in ",
              customRules: "Custom rules",
              part2: "."
            }
          },
          stripMarkup: {
            name: "Strip markup",
            desc: {
              part1: "Omit markup syntax in alias, as set in ",
              stripMarkup: "Strip markup",
              part2: "."
            }
          },
          keepEmptyProperty: {
            name: "Keep empty alias property",
            desc: "When the plugin removes the first line alias and no other aliases remain, keep the empty property rather than delete it."
          },
          hideProperty: {
            name: "Hide alias property",
            desc: "Hide the alias property in Reading view and Live Preview. Will always remain visible in Source view.",
            never: "Never",
            onlyWhenEmpty: "Only when empty",
            always: "Always"
          },
          hideInSidebar: {
            name: "Hide in sidebar",
            desc: "Also hide the property in the properties sidebar."
          },
          hideMergeNotifications: {
            name: "Hide merge notifications",
            desc: "Suppress notifications about files being modified externally and merged automatically."
          },
          limitations: {
            title: "Limitations",
            desc: {
              part1: "First line alias can be unreliable if editing in a page preview. Using ",
              part2: " is recommended."
            }
          }
        },
        replaceCharacters: {
          name: "Replace forbidden characters",
          desc: "Set replacements for characters which are not allowed in filenames. Forbidden characters are omitted entirely if disabled.",
          allOSes: {
            title: "All OSes",
            desc: "Replace characters that are forbidden in Obsidian filenames on all OSes.",
            note: {
              part1: "Use ",
              trimLeft: "Trim left",
              part2: " to remove preceding whitespace. Use ",
              trimRight: "Trim right",
              part3: " to remove whitespace that follows."
            }
          },
          windowsAndroid: {
            title: "Windows/Android",
            desc: "Replace characters that are forbidden in Obsidian filenames on Windows and Android only."
          },
          headers: {
            enable: "Enable",
            character: "Character",
            replaceWith: "Replace with",
            trimLeft: "Trim left",
            trimRight: "Trim right"
          },
          characters: {
            leftBracket: "Left bracket [",
            rightBracket: "Right bracket ]",
            hash: "Hash #",
            caret: "Caret ^",
            pipe: "Pipe |",
            backslash: "Backslash \\",
            forwardSlash: "Forward slash /",
            colon: "Colon :",
            dot: "Dot .",
            dotNote: "Note: the dot is forbidden at filename start only.",
            asterisk: "Asterisk *",
            quote: 'Quote "',
            lessThan: "Less than <",
            greaterThan: "Greater than >",
            questionMark: "Question mark ?"
          },
          emptyPlaceholder: "Empty",
          restoreDefault: "Restore default"
        },
        customRules: {
          name: "Enable custom rules",
          desc: "Set custom text replacements.",
          rulesAppliedSequentially: "Rules are applied sequentially from top to bottom.",
          whitespacePreserved: "Whitespace preserved.",
          leaveBlank: {
            part1: "Leave ",
            replaceWith: "Replace with",
            part2: " blank to omit text entirely."
          },
          untitledWarning: {
            part1: "If ",
            replaceWith: "Replace with",
            part2: " is blank and ",
            textToReplace: "Text to replace",
            part3: " matches the whole line, the filename becomes ",
            untitled: "Untitled",
            part4: "."
          },
          headers: {
            enable: "Enable",
            textToReplace: "Text to replace",
            replaceWith: "Replace with",
            onlyMatchLineStart: "Only match line start",
            onlyMatchWholeLine: "Only match whole line"
          },
          moveUp: "Move up",
          moveDown: "Move down",
          delete: "Delete",
          addReplacement: "Add replacement",
          processingOrder: {
            title: "Processing order",
            applyAfterForbidden: "Apply after stripping or replacing forbidden characters",
            asSetInReplace: {
              part1: "As set in ",
              replaceCharacters: "Replace characters",
              part2: "."
            },
            applyAfterMarkup: "Apply after markup stripping",
            asSetInStrip: {
              part1: "As set in ",
              stripMarkup: "Strip markup",
              part2: "."
            }
          }
        },
        stripMarkup: {
          name: "Strip markup",
          desc: "Omit markup syntax in filenames.",
          headings: {
            name: "Strip heading markup",
            desc: "For example, turn ### Hello into Hello."
          },
          bold: {
            name: "Strip bold markup",
            desc: "For example, turn **Hello** or __Hello__ into Hello."
          },
          italic: {
            name: "Strip italic markup",
            desc: "For example, turn *Hello* or _Hello_ into Hello."
          },
          strikethrough: {
            name: "Strip strikethrough markup",
            desc: "For example, turn ~~Hello~~ into Hello."
          },
          highlight: {
            name: "Strip highlight markup",
            desc: "For example, turn ==Hello== into Hello."
          },
          wikilinks: {
            name: "Strip wikilink markup",
            desc: "For example, turn [[Hello]] or [[Hi|Hello]] into Hello."
          },
          markdownLinks: {
            name: "Strip markdown link markup",
            desc: "For example, turn [Hello](https://example.org) into Hello."
          },
          quote: {
            name: "Strip quote markup",
            desc: "For example, turn >Hello into Hello."
          },
          callouts: {
            name: "Strip callout markup",
            desc: "For example, turn >[!info] Hello into Hello."
          },
          unorderedLists: {
            name: "Strip unordered list markup",
            desc: "For example, turn - Hello or * Hello into Hello."
          },
          orderedLists: {
            name: "Strip ordered list markup",
            desc: "For example, turn 1. Hello into Hello."
          },
          taskLists: {
            name: "Strip task list markup",
            desc: "For example, turn - [x] Hello into Hello."
          },
          code: {
            name: "Strip inline code markup",
            desc: "For example, turn `Hello` into Hello."
          },
          codeBlocks: {
            name: "Strip code block markup",
            desc: "Instead, put the first line within code block in title."
          },
          footnotes: {
            name: "Strip footnote markup",
            desc: "For example, turn Hello[^1] or Hello^[footnote] into Hello."
          },
          comments: {
            name: "Strip comment markup",
            desc: "For example, turn %%Hello%% or <!--Hello--> into Hello."
          },
          commentsEntirely: {
            name: "Strip comments entirely",
            desc: "Also strip comment content in title."
          },
          stripTableMarkup: {
            name: "Strip table markup",
            desc: {
              part1: "Instead, put ",
              table: "Table",
              part2: " in title."
            }
          },
          tables: {
            name: "Strip table markup",
            desc: {
              part1: "Instead, put ",
              table: "Table",
              part2: " in title."
            }
          },
          htmlTags: {
            name: "Strip HTML tags",
            desc: "For example, turn <u>Hello</u> into Hello."
          },
          templater: {
            name: "Strip Templater syntax",
            desc: {
              part1: "Omit ",
              part2: " syntax like ",
              code: "<% tp.file.cursor() %>",
              part3: "."
            }
          }
        },
        commands: {
          ribbon: {
            title: "Ribbon commands",
            desc: "Set which commands appear in the ribbon menu. Reload plugin or Obsidian to apply."
          },
          palette: {
            title: "Command palette commands",
            desc: "Set which commands appear in the Command palette (Ctrl/Cmd-P on desktop by default). Reload plugin or Obsidian to apply."
          },
          file: {
            title: "File commands",
            desc: "Set which commands appear in the file context menu."
          },
          folder: {
            title: "Folder commands",
            desc: "Set which commands appear in the folder context menu."
          },
          tag: {
            title: "Tag commands",
            desc: "Set which commands appear in the tag context menu."
          },
          search: {
            title: "Vault search commands",
            desc: "Set which commands appear in the context menu for search results."
          }
        },
        miscellaneous: {
          charCount: {
            name: "Character count",
            desc: "The maximum number of characters to put in filename.",
            default: "Default: 100"
          },
          notificationMode: {
            name: "Show notification when renaming manually",
            desc: "Set when to show notifications for manual rename commands.",
            always: "Always",
            onTitleChange: "On title change",
            never: "Never"
          },
          grabCardLink: {
            name: "Grab title from card link",
            desc: {
              part1: "If a note starts with a card link created with ",
              part2: " or ",
              part3: ", the card link title will be put in filename."
            }
          },
          newNoteDelay: {
            name: "New note delay",
            desc: "Delay processing new notes by this amount in milliseconds. May resolve issues on note creation.",
            default: "Default: 0"
          },
          contentReadMethod: {
            name: "Content read method",
            desc: "Set how the plugin reads note content. Cache or file read may resolve issues but will be slower.",
            default: "Default: Editor",
            editor: "Editor",
            cache: "Cache",
            file: "File"
          },
          checkInterval: {
            name: "Check interval",
            desc: "Interval in milliseconds for checking first-line changes. Increase in case of issues.",
            default: "Default: 0"
          },
          debug: {
            name: "Debug",
            desc: "Log all of the plugin's activity to the developer console."
          },
          debugOutputContent: {
            name: "Output full file content in console",
            desc: "Log the complete content of files (including YAML frontmatter) whenever they are modified."
          },
          clearSettings: {
            name: "Clear settings",
            desc: "Reset all plugin settings to their default values.",
            modalButton: "Clear settings"
          }
        },
        safewords: {
          enableSafewords: {
            name: "Enable safewords",
            desc: "Specify text that prevents renaming if matched in filename."
          },
          addButton: "Add safeword",
          headers: {
            enable: "Enable",
            safeword: "Safeword",
            onlyMatchStart: "Only match filename start",
            onlyMatchWhole: "Only match whole filename",
            caseSensitive: "Case-sensitive"
          }
        }
      }
    };
  }
});

// locale/ru.json
var require_ru = __commonJS({
  "locale/ru.json"(exports, module2) {
    module2.exports = {
      untitled: "\u0411\u0435\u0437 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u044F",
      table: "\u0422\u0430\u0431\u043B\u0438\u0446\u0430",
      commands: {
        putFirstLineInTitle: "\u041F\u043E\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u043F\u0435\u0440\u0432\u0443\u044E \u0441\u0442\u0440\u043E\u043A\u0443 \u0432 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435",
        putFirstLineInTitleUnlessExcluded: "\u041F\u043E\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u043F\u0435\u0440\u0432\u0443\u044E \u0441\u0442\u0440\u043E\u043A\u0443 \u0432 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 (\u0435\u0441\u043B\u0438 \u0437\u0430\u043C\u0435\u0442\u043A\u0430 \u043D\u0435 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u0430)",
        putFirstLineInTitleAllNotes: "\u041F\u043E\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u043F\u0435\u0440\u0432\u0443\u044E \u0441\u0442\u0440\u043E\u043A\u0443 \u0432 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0432\u043E \u0432\u0441\u0435\u0445 \u0437\u0430\u043C\u0435\u0442\u043A\u0430\u0445",
        disableRenamingForNote: "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 \u0434\u043B\u044F \u0437\u0430\u043C\u0435\u0442\u043A\u0438",
        enableRenamingForNote: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 \u0434\u043B\u044F \u0437\u0430\u043C\u0435\u0442\u043A\u0438",
        disableRenamingInFolder: "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 \u0432 \u043F\u0430\u043F\u043A\u0435",
        enableRenamingInFolder: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 \u0432 \u043F\u0430\u043F\u043A\u0435",
        disableRenamingForTag: "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 \u0434\u043B\u044F \u0442\u0435\u0433\u0430",
        enableRenamingForTag: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 \u0434\u043B\u044F \u0442\u0435\u0433\u0430",
        disableRenaming: "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435",
        enableRenaming: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435",
        toggleAutomaticRenaming: "\u041F\u0435\u0440\u0435\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u043E\u0435 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435",
        addSafeInternalLink: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0431\u0435\u0437\u043E\u043F\u0430\u0441\u043D\u0443\u044E \u0432\u043D\u0443\u0442\u0440\u0435\u043D\u043D\u044E\u044E \u0441\u0441\u044B\u043B\u043A\u0443",
        addSafeInternalLinkWithCaption: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0431\u0435\u0437\u043E\u043F\u0430\u0441\u043D\u0443\u044E \u0432\u043D\u0443\u0442\u0440\u0435\u043D\u043D\u044E\u044E \u0441\u0441\u044B\u043B\u043A\u0443 \u0441 \u043F\u043E\u0434\u043F\u0438\u0441\u044C\u044E",
        putFirstLineInTitleNFolders: {
          few: "\u041F\u043E\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u043F\u0435\u0440\u0432\u0443\u044E \u0441\u0442\u0440\u043E\u043A\u0443 \u0432 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 ({{count}} \u043F\u0430\u043F\u043A\u0438)",
          many: "\u041F\u043E\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u043F\u0435\u0440\u0432\u0443\u044E \u0441\u0442\u0440\u043E\u043A\u0443 \u0432 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 ({{count}} \u043F\u0430\u043F\u043E\u043A)"
        },
        disableRenamingNFolders: {
          few: "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 ({{count}} \u043F\u0430\u043F\u043A\u0438)",
          many: "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 ({{count}} \u043F\u0430\u043F\u043E\u043A)"
        },
        enableRenamingNFolders: {
          few: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 ({{count}} \u043F\u0430\u043F\u043A\u0438)",
          many: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 ({{count}} \u043F\u0430\u043F\u043E\u043A)"
        },
        putFirstLineInTitleNNotes: {
          few: "\u041F\u043E\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u043F\u0435\u0440\u0432\u0443\u044E \u0441\u0442\u0440\u043E\u043A\u0443 \u0432 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 ({{count}} \u0437\u0430\u043C\u0435\u0442\u043A\u0438)",
          many: "\u041F\u043E\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u043F\u0435\u0440\u0432\u0443\u044E \u0441\u0442\u0440\u043E\u043A\u0443 \u0432 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 ({{count}} \u0437\u0430\u043C\u0435\u0442\u043E\u043A)"
        },
        disableRenamingNNotes: {
          few: "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 ({{count}} \u0437\u0430\u043C\u0435\u0442\u043A\u0438)",
          many: "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 ({{count}} \u0437\u0430\u043C\u0435\u0442\u043E\u043A)"
        },
        enableRenamingNNotes: {
          few: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 ({{count}} \u0437\u0430\u043C\u0435\u0442\u043A\u0438)",
          many: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 ({{count}} \u0437\u0430\u043C\u0435\u0442\u043E\u043A)"
        },
        descriptions: {
          renameActiveNoteEvenExcluded: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C \u0430\u043A\u0442\u0438\u0432\u043D\u0443\u044E \u0437\u0430\u043C\u0435\u0442\u043A\u0443, \u0434\u0430\u0436\u0435 \u0435\u0441\u043B\u0438 \u043E\u043D\u0430 \u0432 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u043E\u0439 \u043F\u0430\u043F\u043A\u0435 \u0438\u043B\u0438 \u0441 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u043C \u0442\u0435\u0433\u043E\u043C \u0438\u043B\u0438 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E\u043C.",
          renameActiveNoteUnlessExcluded: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C \u0430\u043A\u0442\u0438\u0432\u043D\u0443\u044E \u0437\u0430\u043C\u0435\u0442\u043A\u0443, \u043A\u0440\u043E\u043C\u0435 \u0441\u043B\u0443\u0447\u0430\u0435\u0432, \u043A\u043E\u0433\u0434\u0430 \u043E\u043D\u0430 \u0432 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u043E\u0439 \u043F\u0430\u043F\u043A\u0435 \u0438\u043B\u0438 \u0441 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u043C \u0442\u0435\u0433\u043E\u043C \u0438\u043B\u0438 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E\u043C.",
          renameAllNotesExceptExcluded: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C \u0432\u0441\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0432 \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435, \u043A\u0440\u043E\u043C\u0435 \u043D\u0430\u0445\u043E\u0434\u044F\u0449\u0438\u0445\u0441\u044F \u0432 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u0445 \u043F\u0430\u043F\u043A\u0430\u0445 \u0438\u043B\u0438 \u0441 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u043C\u0438 \u0442\u0435\u0433\u0430\u043C\u0438 \u0438\u043B\u0438 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430\u043C\u0438.",
          toggleRenameSetting: {
            part1: "\u041F\u0435\u0440\u0435\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0443 ",
            renameNotes: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u044B\u0432\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0438",
            part2: " \u043C\u0435\u0436\u0434\u0443 ",
            automatically: "\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u043F\u0440\u0438 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0438, \u043A\u043E\u0433\u0434\u0430 \u043E\u0442\u043A\u0440\u044B\u0442\u044B",
            part3: " \u0438 ",
            manually: "\u0422\u043E\u043B\u044C\u043A\u043E \u043F\u0440\u0438 \u043F\u043E\u043C\u043E\u0449\u0438 \u043A\u043E\u043C\u0430\u043D\u0434\u044B",
            part4: "."
          },
          excludeActiveNote: "\u0418\u0441\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0430\u043A\u0442\u0438\u0432\u043D\u0443\u044E \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u0438\u0437 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u044F.",
          stopExcludingActiveNote: "\u041F\u0440\u0435\u043A\u0440\u0430\u0442\u0438\u0442\u044C \u0438\u0441\u043A\u043B\u044E\u0447\u0430\u0442\u044C \u0430\u043A\u0442\u0438\u0432\u043D\u0443\u044E \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u0438\u0437 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u044F.",
          createLinkWithForbiddenChars: {
            part1: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0432\u043D\u0443\u0442\u0440\u0435\u043D\u043D\u044E\u044E \u0441\u0441\u044B\u043B\u043A\u0443 \u0441 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u043E\u0439 \u0437\u0430\u043F\u0440\u0435\u0449\u0435\u043D\u043D\u044B\u0445 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432 \u0441\u043E\u0433\u043B\u0430\u0441\u043D\u043E \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u043C \u0432 \u0440\u0430\u0437\u0434\u0435\u043B\u0435 ",
            replaceCharacters: "\u0417\u0430\u043C\u0435\u043D\u0430 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432",
            part2: "."
          },
          createLinkWithValidPath: {
            part1: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0432\u043D\u0443\u0442\u0440\u0435\u043D\u043D\u044E\u044E \u0441\u0441\u044B\u043B\u043A\u0443 \u0441 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u043E\u0439 \u0437\u0430\u043F\u0440\u0435\u0449\u0435\u043D\u043D\u044B\u0445 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432 \u0441\u043E\u0433\u043B\u0430\u0441\u043D\u043E \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u043C \u0432 \u0440\u0430\u0437\u0434\u0435\u043B\u0435 ",
            replaceCharacters: "\u0417\u0430\u043C\u0435\u043D\u0430 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432",
            part2: ", \u0438 \u0441 \u0438\u0441\u0445\u043E\u0434\u043D\u044B\u043C \u0442\u0435\u043A\u0441\u0442\u043E\u043C \u0432 \u043A\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u043F\u043E\u0434\u043F\u0438\u0441\u0438."
          },
          renameNoteEvenExcluded: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443, \u0434\u0430\u0436\u0435 \u0435\u0441\u043B\u0438 \u043E\u043D\u0430 \u0432 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u043E\u0439 \u043F\u0430\u043F\u043A\u0435 \u0438\u043B\u0438 \u0441 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u043C \u0442\u0435\u0433\u043E\u043C.",
          excludeNote: "\u0418\u0441\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u0438\u0437 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u044F.",
          stopExcludingNote: "\u041F\u0440\u0435\u043A\u0440\u0430\u0442\u0438\u0442\u044C \u0438\u0441\u043A\u043B\u044E\u0447\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u0438\u0437 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u044F.",
          renameAllNotesInFolder: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C \u0432\u0441\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0432 \u043F\u0430\u043F\u043A\u0435.",
          excludeFolder: "\u0418\u0441\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0430\u043F\u043A\u0443 \u0438\u0437 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u044F.",
          stopExcludingFolder: "\u041F\u0440\u0435\u043A\u0440\u0430\u0442\u0438\u0442\u044C \u0438\u0441\u043A\u043B\u044E\u0447\u0430\u0442\u044C \u043F\u0430\u043F\u043A\u0443 \u0438\u0437 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u044F.",
          renameAllNotesWithTag: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C \u0432\u0441\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0441 \u0442\u0435\u0433\u043E\u043C.",
          excludeTag: "\u0418\u0441\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0442\u0435\u0433 \u0438\u0437 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u044F.",
          stopExcludingTag: "\u041F\u0440\u0435\u043A\u0440\u0430\u0442\u0438\u0442\u044C \u0438\u0441\u043A\u043B\u044E\u0447\u0430\u0442\u044C \u0442\u0435\u0433 \u0438\u0437 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u044F.",
          renameAllNotesInSearchResults: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C \u0432\u0441\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0432 \u0440\u0435\u0437\u0443\u043B\u044C\u0442\u0430\u0442\u0430\u0445 \u043F\u043E\u0438\u0441\u043A\u0430.",
          excludeAllNotesInSearchResults: "\u0418\u0441\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0432\u0441\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0432 \u0440\u0435\u0437\u0443\u043B\u044C\u0442\u0430\u0442\u0430\u0445 \u043F\u043E\u0438\u0441\u043A\u0430.",
          stopExcludingAllNotesInSearchResults: "\u041F\u0440\u0435\u043A\u0440\u0430\u0442\u0438\u0442\u044C \u0438\u0441\u043A\u043B\u044E\u0447\u0430\u0442\u044C \u0432\u0441\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0432 \u0440\u0435\u0437\u0443\u043B\u044C\u0442\u0430\u0442\u0430\u0445 \u043F\u043E\u0438\u0441\u043A\u0430 \u0438\u0437 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u044F."
        }
      },
      notifications: {
        errorNoActiveNote: "\u041E\u0448\u0438\u0431\u043A\u0430: \u043D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0438.",
        renamingNNotes: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 {{count}} \u0437\u0430\u043C\u0435\u0442\u043E\u043A...",
        renamedNotes: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u043E {{renamed}}/{{total}} \u0437\u0430\u043C\u0435\u0442\u043E\u043A.",
        renamedNotesWithErrors: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u043E {{renamed}}/{{total}} \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u0441 {{errors}} \u043E\u0448\u0438\u0431\u043A\u0430\u043C\u0438. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043A\u043E\u043D\u0441\u043E\u043B\u044C \u0434\u043B\u044F \u043F\u043E\u0434\u0440\u043E\u0431\u043D\u043E\u0441\u0442\u0435\u0439.",
        noNotesFoundWithTag: "\u0417\u0430\u043C\u0435\u0442\u043A\u0438 \u0441 \u0442\u0435\u0433\u043E\u043C #{{tag}} \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B.",
        noNotesFoundInFolders: "\u0417\u0430\u043C\u0435\u0442\u043A\u0438 \u0432 \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0445 \u043F\u0430\u043F\u043A\u0430\u0445 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B.",
        disabledRenamingFor: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u0434\u043B\u044F: {{filename}}",
        failedToDisable: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043A\u043E\u043D\u0441\u043E\u043B\u044C \u0434\u043B\u044F \u043F\u043E\u0434\u0440\u043E\u0431\u043D\u043E\u0441\u0442\u0435\u0439.",
        enabledRenamingFor: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u0434\u043B\u044F: {{filename}}",
        failedToEnable: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0432\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043A\u043E\u043D\u0441\u043E\u043B\u044C \u0434\u043B\u044F \u043F\u043E\u0434\u0440\u043E\u0431\u043D\u043E\u0441\u0442\u0435\u0439.",
        automaticRenamingEnabled: "\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u043E\u0435 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E.",
        automaticRenamingDisabled: "\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u043E\u0435 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E.",
        settingsCleared: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0441\u0431\u0440\u043E\u0448\u0435\u043D\u044B.",
        firstTimeNotice: "\u041E\u0442\u043A\u0440\u043E\u0439\u0442\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 First Line is Title, \u0447\u0442\u043E\u0431\u044B \u0437\u0430\u0434\u0430\u0442\u044C \u043F\u0440\u0435\u0434\u043F\u043E\u0447\u0442\u0435\u043D\u0438\u044F. \u0420\u0435\u043A\u043E\u043C\u0435\u043D\u0434\u0443\u0435\u0442\u0441\u044F \u0440\u0435\u0433\u0443\u043B\u044F\u0440\u043D\u043E \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C \u0440\u0435\u0437\u0435\u0440\u0432\u043D\u044B\u0435 \u043A\u043E\u043F\u0438\u0438 \u0444\u0430\u0439\u043B\u043E\u0432.",
        disabledRenamingForNNotes: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u0434\u043B\u044F {{count}} \u0437\u0430\u043C\u0435\u0442\u043E\u043A.",
        enabledRenamingForNNotes: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u0434\u043B\u044F {{count}} \u0437\u0430\u043C\u0435\u0442\u043E\u043A.",
        renamedTo: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u043E \u0432: {{filename}}",
        notRenamedSelfReference: "\u0417\u0430\u043C\u0435\u0442\u043A\u0430 \u043D\u0435 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0430 \u0438\u0437-\u0437\u0430 \u0441\u0430\u043C\u043E\u0440\u0435\u0444\u0435\u0440\u0435\u043D\u0442\u043D\u043E\u0439 \u0441\u0441\u044B\u043B\u043A\u0438 \u0432 \u043F\u0435\u0440\u0432\u043E\u0439 \u0441\u0442\u0440\u043E\u043A\u0435: {{filename}}",
        noNotesFoundInFolder: "\u0417\u0430\u043C\u0435\u0442\u043A\u0438 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B \u0432: {{folder}}",
        disabledRenamingInFolder: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u0432: {{folder}}",
        enabledRenamingInFolder: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u0432: {{folder}}",
        enabledRenamingInNFolders: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u0432 {{count}} \u043F\u0430\u043F\u043A\u0430\u0445.",
        disabledRenamingInNFolders: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u0432 {{count}} \u043F\u0430\u043F\u043A\u0430\u0445."
      },
      modals: {
        caution: "\u0412\u043D\u0438\u043C\u0430\u043D\u0438\u0435",
        processNNotes: {
          one: {
            before: "\u0411\u0443\u0434\u0435\u0442 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u0430\u043D\u0430 ",
            noun: "\u0437\u0430\u043C\u0435\u0442\u043A\u0430",
            after: "."
          },
          few: {
            before: "\u0411\u0443\u0434\u0443\u0442 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u0430\u043D\u044B ",
            noun: "\u0437\u0430\u043C\u0435\u0442\u043A\u0438",
            after: "."
          },
          many: {
            before: "\u0411\u0443\u0434\u0435\u0442 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u0430\u043D\u043E ",
            noun: "\u0437\u0430\u043C\u0435\u0442\u043E\u043A",
            after: "."
          }
        },
        ensure: "\u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044C:",
        filesBackedUp: "C\u043E\u0437\u0434\u0430\u043D\u044B \u0440\u0435\u0437\u0435\u0440\u0432\u043D\u044B\u0435 \u043A\u043E\u043F\u0438\u0438 \u0444\u0430\u0439\u043B\u043E\u0432 \u2014 \u043D\u0430 \u0441\u043B\u0443\u0447\u0430\u0439 \u043E\u0448\u0438\u0431\u043E\u043A.",
        exclusionsConfigured: "\u0418\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u0435 \u043F\u0430\u043F\u043A\u0438, \u0442\u0435\u0433\u0438 \u0438 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430 \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u044B \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445 \u043F\u043B\u0430\u0433\u0438\u043D\u0430.",
        ensureFilesBackedUp: "\u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044C, \u0447\u0442\u043E \u0441\u043E\u0437\u0434\u0430\u043D\u044B \u0440\u0435\u0437\u0435\u0440\u0432\u043D\u044B\u0435 \u043A\u043E\u043F\u0438\u0438 \u0444\u0430\u0439\u043B\u043E\u0432 \u2014 \u043D\u0430 \u0441\u043B\u0443\u0447\u0430\u0439 \u043E\u0448\u0438\u0431\u043E\u043A.",
        renameInAllSubfolders: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0432\u043E \u0432\u0441\u0435\u0445 \u043F\u043E\u0434\u043F\u0430\u043F\u043A\u0430\u0445",
        renameInExcludedFolders: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0432 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u0445 \u043F\u0430\u043F\u043A\u0430\u0445",
        renameWithExcludedTags: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0441 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u043C\u0438 \u0442\u0435\u0433\u0430\u043C\u0438",
        renameWithExcludedProperties: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0441 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u043C\u0438 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430\u043C\u0438",
        renameWithChildTags: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0441 \u0432\u043B\u043E\u0436\u0435\u043D\u043D\u044B\u043C\u0438 \u0442\u0435\u0433\u0430\u043C\u0438 (\u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, #\u0440\u043E\u0434\u0438\u0442\u0435\u043B\u044C/\u043F\u043E\u0442\u043E\u043C\u043E\u043A)",
        resetAllSettings: "\u042D\u0442\u043E \u0441\u0431\u0440\u043E\u0441\u0438\u0442 \u0432\u0441\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043F\u043B\u0430\u0433\u0438\u043D\u0430 \u043A \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u044F\u043C \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E \u0438 \u0443\u0434\u0430\u043B\u0438\u0442 \u0432\u0441\u0435 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u0430. \u042D\u0442\u043E \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u043D\u0435\u043B\u044C\u0437\u044F \u043E\u0442\u043C\u0435\u043D\u0438\u0442\u044C.",
        addRemoveProperty: "\u042D\u0442\u043E \u0434\u043E\u0431\u0430\u0432\u0438\u0442/\u0443\u0434\u0430\u043B\u0438\u0442 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E \u043A\u043B\u044E\u0447:\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 {{count}} \u0437\u0430\u043C\u0435\u0442\u043A\u0430\u0445.",
        disableEnableAddProperty: "\u042D\u0442\u043E \u0434\u043E\u0431\u0430\u0432\u0438\u0442 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E ",
        disableEnableRemoveProperty: "\u042D\u0442\u043E \u0443\u0434\u0430\u043B\u0438\u0442 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E ",
        propertyTo: " \u0432 ",
        propertyFrom: " \u0432 ",
        internalLink: "\u0412\u043D\u0443\u0442\u0440\u0435\u043D\u043D\u044F\u044F \u0441\u0441\u044B\u043B\u043A\u0430",
        enterText: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0442\u0435\u043A\u0441\u0442...",
        backedUpLinkText: "\u0440\u0435\u0437\u0435\u0440\u0432\u043D\u044B\u0435 \u043A\u043E\u043F\u0438\u0438",
        processNotesMessage: {
          one: {
            before: "\u0411\u0443\u0434\u0435\u0442 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u0430\u043D\u0430 ",
            noun: "\u0437\u0430\u043C\u0435\u0442\u043A\u0430",
            after: "."
          },
          few: {
            before: "\u0411\u0443\u0434\u0443\u0442 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u0430\u043D\u044B ",
            noun: "\u0437\u0430\u043C\u0435\u0442\u043A\u0438",
            after: "."
          },
          many: {
            before: "\u0411\u0443\u0434\u0435\u0442 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u0430\u043D\u043E ",
            noun: "\u0437\u0430\u043C\u0435\u0442\u043E\u043A",
            after: "."
          }
        },
        ensureBackup: "\u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044C, \u0447\u0442\u043E \u0441\u043E\u0437\u0434\u0430\u043D\u044B \u0440\u0435\u0437\u0435\u0440\u0432\u043D\u044B\u0435 \u043A\u043E\u043F\u0438\u0438 \u0444\u0430\u0439\u043B\u043E\u0432 \u2014 \u043D\u0430 \u0441\u043B\u0443\u0447\u0430\u0439 \u043E\u0448\u0438\u0431\u043E\u043A.",
        propertyIn: " \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E \u0432 ",
        note: "\u0437\u0430\u043C\u0435\u0442\u043A\u0430",
        noteFew: "\u0437\u0430\u043C\u0435\u0442\u043A\u0438",
        notes: "\u0437\u0430\u043C\u0435\u0442\u043E\u043A",
        notesPrepositional: "\u0437\u0430\u043C\u0435\u0442\u043A\u0430\u0445",
        buttons: {
          cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
          rename: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C",
          clearSettings: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C",
          disable: "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C",
          enable: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C",
          add: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C"
        }
      },
      ariaLabels: {
        restoreDefault: "\u0412\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
        restoreDefaultContentRead: "\u0412\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u043C\u0435\u0442\u043E\u0434 \u0447\u0442\u0435\u043D\u0438\u044F \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
        remove: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C"
      },
      settings: {
        tabs: {
          general: "\u041E\u0441\u043D\u043E\u0432\u043D\u044B\u0435",
          exclusions: "\u0418\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F",
          replaceCharacters: "\u0417\u0430\u043C\u0435\u043D\u0430 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432",
          customRules: "\u041F\u0440\u0430\u0432\u0438\u043B\u0430 \u0437\u0430\u043C\u0435\u043D\u044B",
          safewords: "\u0421\u0442\u043E\u043F-\u0441\u043B\u043E\u0432\u0430",
          stripMarkup: "\u0423\u0434\u0430\u043B\u0435\u043D\u0438\u0435 \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0438",
          alias: "\u041F\u0441\u0435\u0432\u0434\u043E\u043D\u0438\u043C",
          commands: "\u041A\u043E\u043C\u0430\u043D\u0434\u044B",
          miscellaneous: "\u041F\u0440\u043E\u0447\u0435\u0435"
        },
        general: {
          renameNotes: {
            name: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u044B\u0432\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0438",
            desc: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435, \u043A\u0430\u043A \u0434\u043E\u043B\u0436\u043D\u044B \u043E\u0431\u0440\u0430\u0431\u0430\u0442\u044B\u0432\u0430\u0442\u044C\u0441\u044F \u0437\u0430\u043C\u0435\u0442\u043A\u0438.",
            automatically: "\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u043F\u0440\u0438 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0438, \u043A\u043E\u0433\u0434\u0430 \u043E\u0442\u043A\u0440\u044B\u0442\u044B",
            manually: "\u0422\u043E\u043B\u044C\u043A\u043E \u043F\u0440\u0438 \u043F\u043E\u043C\u043E\u0449\u0438 \u043A\u043E\u043C\u0430\u043D\u0434\u044B"
          },
          renameOnFocus: {
            name: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u044B\u0432\u0430\u0442\u044C \u043F\u0440\u0438 \u0444\u043E\u043A\u0443\u0441\u0435",
            desc: "\u0422\u0430\u043A\u0436\u0435 \u043E\u0431\u0440\u0430\u0431\u0430\u0442\u044B\u0432\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0438, \u043A\u043E\u0433\u0434\u0430 \u043E\u043D\u0438 \u0441\u0442\u0430\u043D\u043E\u0432\u044F\u0442\u0441\u044F \u0430\u043A\u0442\u0438\u0432\u043D\u044B\u043C\u0438 \u0432 \u0440\u0435\u0434\u0430\u043A\u0442\u043E\u0440\u0435."
          },
          whatToPutInTitle: {
            name: "\u0427\u0442\u043E \u043F\u043E\u043C\u0435\u0449\u0430\u0442\u044C \u0432 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435",
            desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435, \u043A\u0430\u043A\u043E\u0435 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0435 \u043F\u0435\u0440\u0432\u043E\u0439 \u0441\u0442\u0440\u043E\u043A\u0438 \u0434\u043E\u043B\u0436\u043D\u043E \u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C\u0441\u044F \u0432 \u0438\u043C\u044F \u0444\u0430\u0439\u043B\u0430.",
            anyText: "\u041B\u044E\u0431\u043E\u0439 \u0442\u0435\u043A\u0441\u0442",
            headingsOnly: "\u0422\u043E\u043B\u044C\u043A\u043E \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u0438"
          },
          moveCursorToFirstLine: {
            name: "\u041F\u0435\u0440\u0435\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u043A\u0443\u0440\u0441\u043E\u0440 \u0432 \u043F\u0435\u0440\u0432\u0443\u044E \u0441\u0442\u0440\u043E\u043A\u0443",
            desc: "\u0420\u0430\u0437\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u043A\u0443\u0440\u0441\u043E\u0440 \u0432 \u043F\u0435\u0440\u0432\u043E\u0439 \u0441\u0442\u0440\u043E\u043A\u0435 \u043F\u0440\u0438 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0438 \u043D\u043E\u0432\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0438."
          },
          placeCursorAtLineEnd: {
            name: "\u0420\u0430\u0437\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u043A\u0443\u0440\u0441\u043E\u0440 \u0432 \u043A\u043E\u043D\u0446\u0435 \u0441\u0442\u0440\u043E\u043A\u0438",
            desc: "\u041F\u0440\u0438 \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u0438\u0438 \u043A\u0443\u0440\u0441\u043E\u0440\u0430 \u0432 \u043F\u0435\u0440\u0432\u0443\u044E \u0441\u0442\u0440\u043E\u043A\u0443 \u0441 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u044B\u043C \u0440\u0430\u0437\u043C\u0435\u0449\u0430\u0442\u044C \u0435\u0433\u043E \u0432 \u043A\u043E\u043D\u0446\u0435 \u0441\u0442\u0440\u043E\u043A\u0438, \u0430 \u043D\u0435 \u0432 \u043D\u0430\u0447\u0430\u043B\u0435."
          },
          disableInExcludedFolders: {
            name: "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0432 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u0445 \u043F\u0430\u043F\u043A\u0430\u0445",
            desc: "\u041D\u0435 \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0430\u0442\u044C \u043A\u0443\u0440\u0441\u043E\u0440 \u043F\u0440\u0438 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0438 \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u0432 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u0445 \u043F\u0430\u043F\u043A\u0430\u0445."
          },
          waitForTemplate: {
            name: "\u041E\u0436\u0438\u0434\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D",
            desc: "\u041F\u0435\u0440\u0435\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u043A\u0443\u0440\u0441\u043E\u0440 \u043F\u043E\u0441\u043B\u0435 \u043F\u0440\u0438\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u0448\u0430\u0431\u043B\u043E\u043D\u0430 \u043D\u043E\u0432\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0438, \u0435\u0441\u043B\u0438 \u0443 \u043D\u0435\u0435 \u043D\u0435\u0442 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u043E\u0433\u043E \u0442\u0435\u0433\u0430 \u0438\u043B\u0438 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430."
          },
          insertTitleOnCreation: {
            name: "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0432 \u043F\u0435\u0440\u0432\u0443\u044E \u0441\u0442\u0440\u043E\u043A\u0443 \u043F\u0440\u0438 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0438 \u0437\u0430\u043C\u0435\u0442\u043A\u0438",
            desc: {
              part1: "\u041F\u043E\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u0438\u043C\u044F \u0444\u0430\u0439\u043B\u0430 \u0432 \u043F\u0435\u0440\u0432\u0443\u044E \u0441\u0442\u0440\u043E\u043A\u0443 \u043F\u0440\u0438 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0438 \u043D\u043E\u0432\u043E\u0439 \u043F\u0443\u0441\u0442\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 (\u0437\u0430 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435\u043C ",
              untitled: "\u0411\u0435\u0437 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u044F",
              part2: "). \u041F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u043D\u044B \u0437\u0430\u043F\u0440\u0435\u0449\u0435\u043D\u043D\u044B\u0445 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432 \u043E\u0431\u0440\u0430\u0442\u043D\u043E \u0432 \u0438\u0445 \u0438\u0441\u0445\u043E\u0434\u043D\u044B\u0435 \u0444\u043E\u0440\u043C\u044B, \u043A\u0430\u043A \u0443\u043A\u0430\u0437\u0430\u043D\u043E \u0432 \u0440\u0430\u0437\u0434\u0435\u043B\u0435 ",
              replaceCharacters: "\u0417\u0430\u043C\u0435\u043D\u0430 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432",
              part3: "."
            }
          },
          insertAfterTemplate: {
            name: "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u043F\u043E\u0441\u043B\u0435 \u0448\u0430\u0431\u043B\u043E\u043D\u0430",
            desc: "\u041F\u043E\u0437\u0432\u043E\u043B\u0438\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 \u043D\u043E\u0432\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0432\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u0431\u043B\u043E\u043A \u0441\u0432\u043E\u0439\u0441\u0442\u0432 \u043F\u0435\u0440\u0435\u0434 \u0432\u0441\u0442\u0430\u0432\u043A\u043E\u0439 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430."
          },
          formatAsHeading: {
            name: "\u0424\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043A\u0430\u043A \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043E\u043A",
            desc: "\u0421\u0434\u0435\u043B\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u0443\u044E \u0441\u0442\u0440\u043E\u043A\u0443 \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u043E\u043C."
          },
          renameOnSave: {
            name: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u044B\u0432\u0430\u0442\u044C \u043F\u0440\u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0438",
            desc: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u044B\u0432\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043F\u0440\u0438 \u0440\u0443\u0447\u043D\u043E\u043C \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0438 (Ctrl/Cmd-S \u043D\u0430 \u043A\u043E\u043C\u043F\u044C\u044E\u0442\u0435\u0440\u0435 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E)."
          },
          renameAllNotes: {
            name: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C \u0432\u0441\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438",
            desc: "\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u0430\u0442\u044C \u0432\u0441\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0432 \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435. \u0422\u0430\u043A\u0436\u0435 \u043C\u043E\u0436\u043D\u043E \u0437\u0430\u043F\u0443\u0441\u0442\u0438\u0442\u044C \u0438\u0437 \u043F\u0430\u043B\u0438\u0442\u0440\u044B \u043A\u043E\u043C\u0430\u043D\u0434.",
            button: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C"
          },
          leaveFeedback: "\u041E\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u043E\u0442\u0437\u044B\u0432"
        },
        exclusions: {
          desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435, \u043A\u0430\u043A \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0434\u043E\u043B\u0436\u043D\u044B \u0438\u0441\u043A\u043B\u044E\u0447\u0430\u0442\u044C\u0441\u044F \u0438\u0437 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0438.",
          note: "\u041F\u0440\u0438\u043C\u0435\u0447\u0430\u043D\u0438\u0435: \u043F\u0440\u0430\u0432\u0438\u043B\u0430 \u043D\u0435 \u043F\u0435\u0440\u0435\u043E\u043F\u0440\u0435\u0434\u0435\u043B\u044F\u044E\u0442 \u0434\u0440\u0443\u0433\u0438\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u0430. \u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u0437\u0430\u043C\u0435\u0442\u043A\u0430 \u0432 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u043E\u0439 \u043F\u0430\u043F\u043A\u0435, \u043D\u043E \u0441 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u043C \u0442\u0435\u0433\u043E\u043C, \u043D\u0435 \u0431\u0443\u0434\u0435\u0442 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u0430\u043D\u0430.",
          folders: {
            title: "\u041F\u0430\u043F\u043A\u0438",
            desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435, \u043A\u0430\u043A\u0438\u0435 \u043F\u0430\u043F\u043A\u0438 \u0443\u0447\u0438\u0442\u044B\u0432\u0430\u0442\u044C.",
            renamedWarning: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u043D\u044B\u0435, \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u043D\u044B\u0435 \u0438\u043B\u0438 \u0443\u0434\u0430\u043B\u0435\u043D\u043D\u044B\u0435 \u043F\u0430\u043F\u043A\u0438 \u043D\u0435 \u043E\u0442\u0440\u0430\u0436\u0430\u044E\u0442\u0441\u044F \u043D\u0438\u0436\u0435. \u041E\u0431\u043D\u043E\u0432\u0438\u0442\u0435 \u0432\u0440\u0443\u0447\u043D\u0443\u044E, \u0435\u0441\u043B\u0438 \u043F\u0443\u0442\u0438 \u0438\u0437\u043C\u0435\u043D\u0438\u043B\u0438\u0441\u044C.",
            matchSubfolders: {
              name: "\u0423\u0447\u0438\u0442\u044B\u0432\u0430\u0442\u044C \u043F\u043E\u0434\u043F\u0430\u043F\u043A\u0438",
              desc: "\u0422\u0430\u043A\u0436\u0435 \u043F\u0440\u0438\u043C\u0435\u043D\u044F\u0442\u044C \u043A\u043E \u0432\u0441\u0435\u043C \u043F\u043E\u0434\u043F\u0430\u043F\u043A\u0430\u043C \u043F\u0430\u043F\u043E\u043A, \u0443\u043A\u0430\u0437\u0430\u043D\u043D\u044B\u0445 \u043D\u0438\u0436\u0435."
            },
            exclusionMode: {
              name: "\u0420\u0435\u0436\u0438\u043C \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F",
              desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435, \u043A\u0430\u043A \u0434\u043E\u043B\u0436\u043D\u044B \u0438\u0441\u043A\u043B\u044E\u0447\u0430\u0442\u044C\u0441\u044F \u043F\u0430\u043F\u043A\u0438.",
              onlyExclude: "\u0418\u0441\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0442\u043E\u043B\u044C\u043A\u043E...",
              excludeAllExcept: "\u0418\u0441\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0432\u0441\u0435, \u043A\u0440\u043E\u043C\u0435..."
            },
            placeholder: "\u041D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u043F\u0430\u043F\u043A\u0438",
            addButton: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043F\u0430\u043F\u043A\u0443"
          },
          tags: {
            title: "\u0422\u0435\u0433\u0438",
            desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435, \u043A\u0430\u043A\u0438\u0435 \u0442\u0435\u0433\u0438 \u0443\u0447\u0438\u0442\u044B\u0432\u0430\u0442\u044C.",
            excludeAllNote: {
              part1: "",
              excludeAllExcept: "\u0418\u0441\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0432\u0441\u0435, \u043A\u0440\u043E\u043C\u0435...",
              part2: " \u0442\u0430\u043A\u0436\u0435 \u0438\u0441\u043A\u043B\u044E\u0447\u0430\u0435\u0442 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0431\u0435\u0437 \u0442\u0435\u0433\u043E\u0432."
            },
            tagWranglerWarning: "\u0422\u0435\u0433\u0438, \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\u044E Tag Wrangler, \u043D\u0435 \u043E\u0442\u0440\u0430\u0436\u0430\u044E\u0442\u0441\u044F \u043D\u0438\u0436\u0435. \u041E\u0431\u043D\u043E\u0432\u0438\u0442\u0435 \u0432\u0440\u0443\u0447\u043D\u0443\u044E \u043F\u043E\u0441\u043B\u0435 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u044F.",
            matchTags: {
              name: "\u0423\u0447\u0438\u0442\u044B\u0432\u0430\u0442\u044C \u0442\u0435\u0433\u0438",
              desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435, \u0433\u0434\u0435 \u0434\u043E\u043B\u0436\u043D\u044B \u0443\u0447\u0438\u0442\u044B\u0432\u0430\u0442\u044C\u0441\u044F \u0442\u0435\u0433\u0438.",
              inPropertiesAndBody: "\u0412 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430\u0445 \u0438 \u0432 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u043C \u0437\u0430\u043C\u0435\u0442\u043A\u0438",
              inPropertiesOnly: "\u0422\u043E\u043B\u044C\u043A\u043E \u0432 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430\u0445",
              inBodyOnly: "\u0422\u043E\u043B\u044C\u043A\u043E \u0432 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u043C \u0437\u0430\u043C\u0435\u0442\u043A\u0438"
            },
            matchChildTags: {
              name: "\u0423\u0447\u0438\u0442\u044B\u0432\u0430\u0442\u044C \u0432\u043B\u043E\u0436\u0435\u043D\u043D\u044B\u0435 \u0442\u0435\u0433\u0438",
              desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u0442\u0430\u043A\u0436\u0435 \u0443\u0447\u0438\u0442\u044B\u0432\u0430\u0442\u044C #\u0440\u043E\u0434\u0438\u0442\u0435\u043B\u044C/\u043F\u043E\u0442\u043E\u043C\u043E\u043A, \u0435\u0441\u043B\u0438 #\u0440\u043E\u0434\u0438\u0442\u0435\u043B\u044C \u0443\u043A\u0430\u0437\u0430\u043D \u043D\u0438\u0436\u0435."
            },
            exclusionMode: {
              name: "\u0420\u0435\u0436\u0438\u043C \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F",
              desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435, \u043A\u0430\u043A \u0434\u043E\u043B\u0436\u043D\u044B \u0438\u0441\u043A\u043B\u044E\u0447\u0430\u0442\u044C\u0441\u044F \u0442\u0435\u0433\u0438."
            },
            placeholder: "\u041D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0442\u0435\u0433\u0430",
            addButton: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0442\u0435\u0433"
          },
          properties: {
            title: "\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u0430",
            desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435, \u043A\u0430\u043A\u0438\u0435 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430 \u0443\u0447\u0438\u0442\u044B\u0432\u0430\u0442\u044C.",
            leaveBlank: {
              part1: "\u041E\u0441\u0442\u0430\u0432\u044C\u0442\u0435 ",
              value: "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435",
              part2: " \u043F\u0443\u0441\u0442\u044B\u043C, \u0447\u0442\u043E\u0431\u044B \u0443\u0447\u0438\u0442\u044B\u0432\u0430\u0442\u044C \u0432\u0441\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0441 \u044D\u0442\u0438\u043C \u043A\u043B\u044E\u0447\u043E\u043C \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430."
            },
            caseInsensitive: "\u0411\u0435\u0437 \u0443\u0447\u0435\u0442\u0430 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430.",
            excludeAllNote: {
              part1: "",
              excludeAllExcept: "\u0418\u0441\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0432\u0441\u0435, \u043A\u0440\u043E\u043C\u0435...",
              part2: " \u0442\u0430\u043A\u0436\u0435 \u0438\u0441\u043A\u043B\u044E\u0447\u0430\u0435\u0442 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0431\u0435\u0437 \u0441\u0432\u043E\u0439\u0441\u0442\u0432."
            },
            renamedWarning: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u043A\u043B\u044E\u0447\u0438 \u0441\u0432\u043E\u0439\u0441\u0442\u0432 \u043D\u0435 \u043E\u0442\u0440\u0430\u0436\u0430\u044E\u0442\u0441\u044F \u043D\u0438\u0436\u0435. \u041E\u0431\u043D\u043E\u0432\u0438\u0442\u0435 \u0432\u0440\u0443\u0447\u043D\u0443\u044E \u043F\u043E\u0441\u043B\u0435 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u044F.",
            exclusionMode: {
              name: "\u0420\u0435\u0436\u0438\u043C \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F",
              desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435, \u043A\u0430\u043A \u0434\u043E\u043B\u0436\u043D\u044B \u0438\u0441\u043A\u043B\u044E\u0447\u0430\u0442\u044C\u0441\u044F \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430."
            },
            keyPlaceholder: "\u043A\u043B\u044E\u0447",
            valuePlaceholder: "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435",
            separator: ":",
            addButton: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E"
          },
          disableProperty: {
            title: "\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u043E \u0434\u043B\u044F \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u044F",
            desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E \u0434\u043B\u044F \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u0438\u0437 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0438.",
            alwaysRespected: "\u0412\u0441\u0435\u0433\u0434\u0430 \u0443\u0447\u0438\u0442\u044B\u0432\u0430\u0435\u0442\u0441\u044F \u2014 \u043D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u043F\u0435\u0440\u0435\u043E\u043F\u0440\u0435\u0434\u0435\u043B\u0435\u043D\u043E \u043D\u0438 \u043E\u0434\u043D\u043E\u0439 \u043A\u043E\u043C\u0430\u043D\u0434\u043E\u0439.",
            caseInsensitive: "\u0411\u0435\u0437 \u0443\u0447\u0435\u0442\u0430 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430.",
            updateWarning: "\u0418\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0435 \u044D\u0442\u043E\u0433\u043E \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430 \u043D\u0435 \u043E\u0431\u043D\u043E\u0432\u0438\u0442 \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u0440\u0430\u043D\u0435\u0435 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043D\u044B\u0435 \u0432 \u0437\u0430\u043C\u0435\u0442\u043A\u0430\u0445 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430. \u041E\u0431\u043D\u043E\u0432\u0438\u0442\u0435 \u0432\u0440\u0443\u0447\u043D\u0443\u044E \u043F\u043E\u0441\u043B\u0435 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F.",
            default: "\u041F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E: no rename:true"
          }
        },
        alias: {
          addAlias: {
            name: "\u0414\u043E\u0431\u0430\u0432\u043B\u044F\u0442\u044C \u043F\u0441\u0435\u0432\u0434\u043E\u043D\u0438\u043C",
            desc: "\u0412\u0441\u0435\u0433\u0434\u0430 \u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u0443\u044E \u0441\u0442\u0440\u043E\u043A\u0443 \u0432 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E \u043F\u0440\u0438 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0438 \u0437\u0430\u043C\u0435\u0442\u043E\u043A."
          },
          aliasPropertyName: {
            name: "\u041D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430 \u043F\u0441\u0435\u0432\u0434\u043E\u043D\u0438\u043C\u0430",
            desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435 \u043A\u043B\u044E\u0447 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u0430, \u0432 \u043A\u043E\u0442\u043E\u0440\u043E\u0435 \u0432\u0441\u0442\u0430\u0432\u043B\u044F\u0442\u044C \u043F\u0441\u0435\u0432\u0434\u043E\u043D\u0438\u043C.",
            quickSwitcher: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 'aliases', \u0447\u0442\u043E\u0431\u044B \u0441\u0434\u0435\u043B\u0430\u0442\u044C \u043F\u0441\u0435\u0432\u0434\u043E\u043D\u0438\u043C \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u043C \u0434\u043B\u044F \u043F\u043E\u0438\u0441\u043A\u0430 \u0432 \u0431\u044B\u0441\u0442\u0440\u043E\u043C \u043F\u0435\u0440\u0435\u043A\u043B\u044E\u0447\u0430\u0442\u0435\u043B\u0435.",
            multipleProperties: "\u0414\u043B\u044F \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u0438\u044F \u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u0438\u0445 \u0441\u0432\u043E\u0439\u0441\u0442\u0432 \u0440\u0430\u0437\u0434\u0435\u043B\u044F\u0439\u0442\u0435 \u0437\u0430\u043F\u044F\u0442\u043E\u0439 (\u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, 'aliases, title').",
            noteTitle: {
              part1: "\u042D\u0442\u043E \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E \u043C\u043E\u0436\u043D\u043E \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u043A\u0430\u043A \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0432 ",
              part2: ", ",
              part3: " \u0438 ",
              part4: "."
            },
            default: "\u041F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E: aliases"
          },
          onlyAddIfDiffers: {
            name: "\u0414\u043E\u0431\u0430\u0432\u043B\u044F\u0442\u044C \u043F\u0441\u0435\u0432\u0434\u043E\u043D\u0438\u043C \u0442\u043E\u043B\u044C\u043A\u043E \u0435\u0441\u043B\u0438 \u043F\u0435\u0440\u0432\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430 \u043E\u0442\u043B\u0438\u0447\u0430\u0435\u0442\u0441\u044F \u043E\u0442 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u044F",
            desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u0435\u0441\u043B\u0438 \u0438\u043C\u044F \u0444\u0430\u0439\u043B\u0430 \u0431\u044B\u043B\u043E \u0443\u0441\u0435\u0447\u0435\u043D\u043E, \u0438\u043B\u0438 \u043D\u0435\u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u0441\u0438\u043C\u0432\u043E\u043B\u044B \u0431\u044B\u043B\u0438 \u043F\u0440\u043E\u043F\u0443\u0449\u0435\u043D\u044B \u0438\u043B\u0438 \u0437\u0430\u043C\u0435\u043D\u0435\u043D\u044B."
          },
          truncateAlias: {
            name: "\u0423\u0441\u0435\u0447\u044C \u043F\u0441\u0435\u0432\u0434\u043E\u043D\u0438\u043C",
            desc: {
              part1: "\u0412 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0438 \u0441\u043E \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435\u043C ",
              charCount: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432",
              part2: " \u0432 \u0440\u0430\u0437\u0434\u0435\u043B\u0435 ",
              miscellaneous: "\u041F\u0440\u043E\u0447\u0435\u0435",
              part3: "."
            }
          },
          applyCustomRules: {
            name: "\u041F\u0440\u0438\u043C\u0435\u043D\u0438\u0442\u044C \u0441\u043E\u0431\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u0430",
            desc: {
              part1: "\u041F\u0440\u0438\u043C\u0435\u043D\u0438\u0442\u044C \u0441\u043E\u0431\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u0435 \u0437\u0430\u043C\u0435\u043D\u044B \u0442\u0435\u043A\u0441\u0442\u0430 \u043A \u043F\u0441\u0435\u0432\u0434\u043E\u043D\u0438\u043C\u0443, \u043A\u0430\u043A \u0443\u043A\u0430\u0437\u0430\u043D\u043E \u0432 \u0440\u0430\u0437\u0434\u0435\u043B\u0435 ",
              customRules: "\u041F\u0440\u0430\u0432\u0438\u043B\u0430 \u0437\u0430\u043C\u0435\u043D\u044B",
              part2: "."
            }
          },
          stripMarkup: {
            name: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443",
            desc: {
              part1: "\u041F\u0440\u043E\u043F\u0443\u0441\u0442\u0438\u0442\u044C \u0441\u0438\u043D\u0442\u0430\u043A\u0441\u0438\u0441 \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0438 \u0432 \u043F\u0441\u0435\u0432\u0434\u043E\u043D\u0438\u043C\u0435, \u043A\u0430\u043A \u0443\u043A\u0430\u0437\u0430\u043D\u043E \u0432 \u0440\u0430\u0437\u0434\u0435\u043B\u0435 ",
              stripMarkup: "\u0423\u0434\u0430\u043B\u0435\u043D\u0438\u0435 \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0438",
              part2: "."
            }
          },
          keepEmptyProperty: {
            name: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u043F\u0443\u0441\u0442\u043E\u0435 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E \u043F\u0441\u0435\u0432\u0434\u043E\u043D\u0438\u043C\u0430",
            desc: "\u041A\u043E\u0433\u0434\u0430 \u043F\u043B\u0430\u0433\u0438\u043D \u0443\u0434\u0430\u043B\u044F\u0435\u0442 \u043F\u0441\u0435\u0432\u0434\u043E\u043D\u0438\u043C \u043F\u0435\u0440\u0432\u043E\u0439 \u0441\u0442\u0440\u043E\u043A\u0438 \u0438 \u043D\u0435 \u043E\u0441\u0442\u0430\u0435\u0442\u0441\u044F \u0434\u0440\u0443\u0433\u0438\u0445 \u043F\u0441\u0435\u0432\u0434\u043E\u043D\u0438\u043C\u043E\u0432, \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043F\u0443\u0441\u0442\u043E\u0435 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E \u0432\u043C\u0435\u0441\u0442\u043E \u0435\u0433\u043E \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u044F."
          },
          hideProperty: {
            name: "\u0421\u043A\u0440\u044B\u0442\u044C \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E \u043F\u0441\u0435\u0432\u0434\u043E\u043D\u0438\u043C\u0430",
            desc: "\u0421\u043A\u0440\u044B\u0442\u044C \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E \u043F\u0441\u0435\u0432\u0434\u043E\u043D\u0438\u043C\u0430 \u0432 \u0440\u0435\u0436\u0438\u043C\u0435 \u0447\u0442\u0435\u043D\u0438\u044F \u0438 \u0440\u0435\u0436\u0438\u043C\u0435 \u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F. \u0412\u0441\u0435\u0433\u0434\u0430 \u043E\u0441\u0442\u0430\u043D\u0435\u0442\u0441\u044F \u0432\u0438\u0434\u0438\u043C\u044B\u043C \u0432 \u0440\u0435\u0436\u0438\u043C\u0435 \u0438\u0441\u0445\u043E\u0434\u043D\u043E\u0433\u043E \u043A\u043E\u0434\u0430.",
            never: "\u041D\u0438\u043A\u043E\u0433\u0434\u0430",
            onlyWhenEmpty: "\u0422\u043E\u043B\u044C\u043A\u043E \u043A\u043E\u0433\u0434\u0430 \u043F\u0443\u0441\u0442\u043E",
            always: "\u0412\u0441\u0435\u0433\u0434\u0430"
          },
          hideInSidebar: {
            name: "\u0421\u043A\u0440\u044B\u0442\u044C \u0432 \u0431\u043E\u043A\u043E\u0432\u043E\u0439 \u043F\u0430\u043D\u0435\u043B\u0438",
            desc: "\u0422\u0430\u043A\u0436\u0435 \u0441\u043A\u0440\u044B\u0442\u044C \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E \u0432 \u0431\u043E\u043A\u043E\u0432\u043E\u0439 \u043F\u0430\u043D\u0435\u043B\u0438 \u0441\u0432\u043E\u0439\u0441\u0442\u0432."
          },
          hideMergeNotifications: {
            name: "\u0421\u043A\u0440\u044B\u0442\u044C \u0443\u0432\u0435\u0434\u043E\u043C\u043B\u0435\u043D\u0438\u044F \u043E \u0441\u043B\u0438\u044F\u043D\u0438\u0438",
            desc: "\u041F\u043E\u0434\u0430\u0432\u0438\u0442\u044C \u0443\u0432\u0435\u0434\u043E\u043C\u043B\u0435\u043D\u0438\u044F \u043E \u0444\u0430\u0439\u043B\u0430\u0445, \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u043D\u044B\u0445 \u0438\u0437\u0432\u043D\u0435 \u0438 \u0441\u043B\u0438\u0442\u044B\u0445 \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438."
          },
          limitations: {
            title: "\u041E\u0433\u0440\u0430\u043D\u0438\u0447\u0435\u043D\u0438\u044F",
            desc: {
              part1: "\u041F\u0441\u0435\u0432\u0434\u043E\u043D\u0438\u043C \u043F\u0435\u0440\u0432\u043E\u0439 \u0441\u0442\u0440\u043E\u043A\u0438 \u043C\u043E\u0436\u0435\u0442 \u0440\u0430\u0431\u043E\u0442\u0430\u0442\u044C \u043D\u0435\u043D\u0430\u0434\u0435\u0436\u043D\u043E \u043F\u0440\u0438 \u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0438 \u0432 \u043F\u0440\u0435\u0434\u0432\u0430\u0440\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u043C \u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440\u0435 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u044B. \u0420\u0435\u043A\u043E\u043C\u0435\u043D\u0434\u0443\u0435\u0442\u0441\u044F \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C ",
              part2: "."
            }
          }
        },
        replaceCharacters: {
          name: "\u0417\u0430\u043C\u0435\u043D\u044F\u0442\u044C \u0437\u0430\u043F\u0440\u0435\u0449\u0435\u043D\u043D\u044B\u0435 \u0441\u0438\u043C\u0432\u043E\u043B\u044B",
          desc: "\u0417\u0430\u043C\u0435\u043D\u044F\u0442\u044C \u0441\u0438\u043C\u0432\u043E\u043B\u044B, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043D\u0435 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043D\u044B \u0432 \u0438\u043C\u0435\u043D\u0430\u0445 \u0444\u0430\u0439\u043B\u043E\u0432. \u0417\u0430\u043F\u0440\u0435\u0449\u0435\u043D\u043D\u044B\u0435 \u0441\u0438\u043C\u0432\u043E\u043B\u044B \u043F\u043E\u043B\u043D\u043E\u0441\u0442\u044C\u044E \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u044E\u0442\u0441\u044F, \u0435\u0441\u043B\u0438 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E.",
          allOSes: {
            title: "\u0412\u0441\u0435 \u041E\u0421",
            desc: "\u0417\u0430\u043C\u0435\u043D\u044F\u0442\u044C \u0441\u0438\u043C\u0432\u043E\u043B\u044B, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u0437\u0430\u043F\u0440\u0435\u0449\u0435\u043D\u044B \u0432 \u0438\u043C\u0435\u043D\u0430\u0445 \u0444\u0430\u0439\u043B\u043E\u0432 Obsidian \u043D\u0430 \u0432\u0441\u0435\u0445 \u043E\u043F\u0435\u0440\u0430\u0446\u0438\u043E\u043D\u043D\u044B\u0445 \u0441\u0438\u0441\u0442\u0435\u043C\u0430\u0445.",
            note: {
              part1: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 ",
              trimLeft: "\u041E\u0431\u0440\u0435\u0437\u0430\u0442\u044C \u0441\u043B\u0435\u0432\u0430",
              part2: ", \u0447\u0442\u043E\u0431\u044B \u0443\u0434\u0430\u043B\u0438\u0442\u044C \u043F\u0440\u0435\u0434\u0448\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0435 \u043F\u0440\u043E\u0431\u0435\u043B\u044B. \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 ",
              trimRight: "\u041E\u0431\u0440\u0435\u0437\u0430\u0442\u044C \u0441\u043F\u0440\u0430\u0432\u0430",
              part3: ", \u0447\u0442\u043E\u0431\u044B \u0443\u0434\u0430\u043B\u0438\u0442\u044C \u043F\u0440\u043E\u0431\u0435\u043B\u044B, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u0441\u043B\u0435\u0434\u0443\u044E\u0442."
            }
          },
          windowsAndroid: {
            title: "Windows/Android",
            desc: "\u0417\u0430\u043C\u0435\u043D\u044F\u0442\u044C \u0441\u0438\u043C\u0432\u043E\u043B\u044B, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u0437\u0430\u043F\u0440\u0435\u0449\u0435\u043D\u044B \u0432 \u0438\u043C\u0435\u043D\u0430\u0445 \u0444\u0430\u0439\u043B\u043E\u0432 Obsidian \u0442\u043E\u043B\u044C\u043A\u043E \u043D\u0430 Windows \u0438 Android."
          },
          headers: {
            enable: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C",
            character: "\u0421\u0438\u043C\u0432\u043E\u043B",
            replaceWith: "\u0417\u0430\u043C\u0435\u043D\u0438\u0442\u044C \u043D\u0430",
            trimLeft: "\u041E\u0431\u0440\u0435\u0437\u0430\u0442\u044C \u0441\u043B\u0435\u0432\u0430",
            trimRight: "\u041E\u0431\u0440\u0435\u0437\u0430\u0442\u044C \u0441\u043F\u0440\u0430\u0432\u0430"
          },
          characters: {
            leftBracket: "\u041B\u0435\u0432\u0430\u044F \u0441\u043A\u043E\u0431\u043A\u0430 [",
            rightBracket: "\u041F\u0440\u0430\u0432\u0430\u044F \u0441\u043A\u043E\u0431\u043A\u0430 ]",
            hash: "\u0420\u0435\u0448\u0435\u0442\u043A\u0430 #",
            caret: "\u041A\u0430\u0440\u0435\u0442 ^",
            pipe: "\u0412\u0435\u0440\u0442\u0438\u043A\u0430\u043B\u044C\u043D\u0430\u044F \u0447\u0435\u0440\u0442\u0430 |",
            backslash: "\u041E\u0431\u0440\u0430\u0442\u043D\u0430\u044F \u043A\u043E\u0441\u0430\u044F \u0447\u0435\u0440\u0442\u0430 \\",
            forwardSlash: "\u041A\u043E\u0441\u0430\u044F \u0447\u0435\u0440\u0442\u0430 /",
            colon: "\u0414\u0432\u043E\u0435\u0442\u043E\u0447\u0438\u0435 :",
            dot: "\u0422\u043E\u0447\u043A\u0430 .",
            dotNote: "\u041F\u0440\u0438\u043C\u0435\u0447\u0430\u043D\u0438\u0435: \u0442\u043E\u0447\u043A\u0430 \u0437\u0430\u043F\u0440\u0435\u0449\u0435\u043D\u0430 \u0442\u043E\u043B\u044C\u043A\u043E \u0432 \u043D\u0430\u0447\u0430\u043B\u0435 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430.",
            asterisk: "\u0417\u0432\u0435\u0437\u0434\u043E\u0447\u043A\u0430 *",
            quote: '\u041A\u0430\u0432\u044B\u0447\u043A\u0430 "',
            lessThan: "\u041C\u0435\u043D\u044C\u0448\u0435 <",
            greaterThan: "\u0411\u043E\u043B\u044C\u0448\u0435 >",
            questionMark: "\u0412\u043E\u043F\u0440\u043E\u0441\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 \u0437\u043D\u0430\u043A ?"
          },
          emptyPlaceholder: "\u041F\u0443\u0441\u0442\u043E",
          restoreDefault: "\u0412\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E"
        },
        customRules: {
          name: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0440\u0430\u0432\u0438\u043B\u0430 \u0437\u0430\u043C\u0435\u043D\u044B",
          desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435 \u0441\u043E\u0431\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u0435 \u0437\u0430\u043C\u0435\u043D\u044B \u0442\u0435\u043A\u0441\u0442\u0430.",
          rulesAppliedSequentially: "\u041F\u0440\u0430\u0432\u0438\u043B\u0430 \u043F\u0440\u0438\u043C\u0435\u043D\u044F\u044E\u0442\u0441\u044F \u043F\u043E\u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u043D\u043E \u0441\u0432\u0435\u0440\u0445\u0443 \u0432\u043D\u0438\u0437.",
          whitespacePreserved: "\u041F\u0440\u043E\u0431\u0435\u043B\u044B \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u044E\u0442\u0441\u044F.",
          leaveBlank: {
            part1: "\u041E\u0441\u0442\u0430\u0432\u044C\u0442\u0435 \u043F\u043E\u043B\u0435 ",
            replaceWith: "\u0417\u0430\u043C\u0435\u043D\u0438\u0442\u044C \u043D\u0430",
            part2: " \u043F\u0443\u0441\u0442\u044B\u043C, \u0447\u0442\u043E\u0431\u044B \u043F\u043E\u043B\u043D\u043E\u0441\u0442\u044C\u044E \u043F\u0440\u043E\u043F\u0443\u0441\u0442\u0438\u0442\u044C \u0442\u0435\u043A\u0441\u0442."
          },
          untitledWarning: {
            part1: "\u0415\u0441\u043B\u0438 ",
            replaceWith: "\u0417\u0430\u043C\u0435\u043D\u0438\u0442\u044C \u043D\u0430",
            part2: " \u043F\u0443\u0441\u0442\u043E, \u0430 ",
            textToReplace: "\u0422\u0435\u043A\u0441\u0442 \u0434\u043B\u044F \u0437\u0430\u043C\u0435\u043D\u044B",
            part3: " \u0441\u043E\u0432\u043F\u0430\u0434\u0430\u0435\u0442 \u0441\u043E \u0432\u0441\u0435\u0439 \u0441\u0442\u0440\u043E\u043A\u043E\u0439, \u0438\u043C\u044F \u0444\u0430\u0439\u043B\u0430 \u0441\u0442\u0430\u043D\u0435\u0442 ",
            untitled: "\u0411\u0435\u0437 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u044F",
            part4: "."
          },
          headers: {
            enable: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C",
            textToReplace: "\u0422\u0435\u043A\u0441\u0442 \u0434\u043B\u044F \u0437\u0430\u043C\u0435\u043D\u044B",
            replaceWith: "\u0417\u0430\u043C\u0435\u043D\u0438\u0442\u044C \u043D\u0430",
            onlyMatchLineStart: "\u0422\u043E\u043B\u044C\u043A\u043E \u0432 \u043D\u0430\u0447\u0430\u043B\u0435 \u0441\u0442\u0440\u043E\u043A\u0438",
            onlyMatchWholeLine: "\u0422\u043E\u043B\u044C\u043A\u043E \u0432\u0441\u044E \u0441\u0442\u0440\u043E\u043A\u0443"
          },
          moveUp: "\u041F\u0435\u0440\u0435\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u0432\u0432\u0435\u0440\u0445",
          moveDown: "\u041F\u0435\u0440\u0435\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u0432\u043D\u0438\u0437",
          delete: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C",
          addReplacement: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043F\u0440\u0430\u0432\u0438\u043B\u043E",
          processingOrder: {
            title: "\u041F\u043E\u0440\u044F\u0434\u043E\u043A \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0438",
            applyAfterForbidden: "\u041F\u0440\u0438\u043C\u0435\u043D\u044F\u0442\u044C \u043F\u043E\u0441\u043B\u0435 \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u044F \u0438\u043B\u0438 \u0437\u0430\u043C\u0435\u043D\u044B \u0437\u0430\u043F\u0440\u0435\u0449\u0435\u043D\u043D\u044B\u0445 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432",
            asSetInReplace: {
              part1: "\u041A\u0430\u043A \u0443\u043A\u0430\u0437\u0430\u043D\u043E \u0432 \u0440\u0430\u0437\u0434\u0435\u043B\u0435 ",
              replaceCharacters: "\u0417\u0430\u043C\u0435\u043D\u0430 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432",
              part2: "."
            },
            applyAfterMarkup: "\u041F\u0440\u0438\u043C\u0435\u043D\u044F\u0442\u044C \u043F\u043E\u0441\u043B\u0435 \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u044F \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0438",
            asSetInStrip: {
              part1: "\u041A\u0430\u043A \u0443\u043A\u0430\u0437\u0430\u043D\u043E \u0432 \u0440\u0430\u0437\u0434\u0435\u043B\u0435 ",
              stripMarkup: "\u0423\u0434\u0430\u043B\u0435\u043D\u0438\u0435 \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0438",
              part2: "."
            }
          }
        },
        stripMarkup: {
          name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443",
          desc: "\u041F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u0442\u044C \u0441\u0438\u043D\u0442\u0430\u043A\u0441\u0438\u0441 \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0438 \u0432 \u0438\u043C\u0435\u043D\u0430\u0445 \u0444\u0430\u0439\u043B\u043E\u0432.",
          headings: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u043E\u0432",
            desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C ### \u041F\u0440\u0438\u0432\u0435\u0442 \u0432 \u041F\u0440\u0438\u0432\u0435\u0442."
          },
          bold: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u0436\u0438\u0440\u043D\u043E\u0433\u043E \u0442\u0435\u043A\u0441\u0442\u0430",
            desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C **\u041F\u0440\u0438\u0432\u0435\u0442** \u0438\u043B\u0438 __\u041F\u0440\u0438\u0432\u0435\u0442__ \u0432 \u041F\u0440\u0438\u0432\u0435\u0442."
          },
          italic: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u043A\u0443\u0440\u0441\u0438\u0432\u0430",
            desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C *\u041F\u0440\u0438\u0432\u0435\u0442* \u0438\u043B\u0438 _\u041F\u0440\u0438\u0432\u0435\u0442_ \u0432 \u041F\u0440\u0438\u0432\u0435\u0442."
          },
          strikethrough: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u0437\u0430\u0447\u0435\u0440\u043A\u043D\u0443\u0442\u043E\u0433\u043E \u0442\u0435\u043A\u0441\u0442\u0430",
            desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C ~~\u041F\u0440\u0438\u0432\u0435\u0442~~ \u0432 \u041F\u0440\u0438\u0432\u0435\u0442."
          },
          highlight: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u0432\u044B\u0434\u0435\u043B\u0435\u043D\u0438\u044F",
            desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C ==\u041F\u0440\u0438\u0432\u0435\u0442== \u0432 \u041F\u0440\u0438\u0432\u0435\u0442."
          },
          wikilinks: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u0432\u0438\u043A\u0438-\u0441\u0441\u044B\u043B\u043E\u043A",
            desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C [[\u041F\u0440\u0438\u0432\u0435\u0442]] \u0438\u043B\u0438 [[\u041F\u043E\u043A\u0430|\u041F\u0440\u0438\u0432\u0435\u0442]] \u0432 \u041F\u0440\u0438\u0432\u0435\u0442."
          },
          markdownLinks: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u0441\u0441\u044B\u043B\u043E\u043A Markdown",
            desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C [\u041F\u0440\u0438\u0432\u0435\u0442](https://example.org) \u0432 \u041F\u0440\u0438\u0432\u0435\u0442."
          },
          quote: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u0446\u0438\u0442\u0430\u0442",
            desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C >\u041F\u0440\u0438\u0432\u0435\u0442 \u0432 \u041F\u0440\u0438\u0432\u0435\u0442."
          },
          callouts: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u0432\u044B\u043D\u043E\u0441\u043D\u044B\u0445 \u0431\u043B\u043E\u043A\u043E\u0432",
            desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C >[!info] \u041F\u0440\u0438\u0432\u0435\u0442 \u0432 \u041F\u0440\u0438\u0432\u0435\u0442."
          },
          unorderedLists: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u043D\u0435\u043D\u0443\u043C\u0435\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0445 \u0441\u043F\u0438\u0441\u043A\u043E\u0432",
            desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C - \u041F\u0440\u0438\u0432\u0435\u0442 \u0438\u043B\u0438 * \u041F\u0440\u0438\u0432\u0435\u0442 \u0432 \u041F\u0440\u0438\u0432\u0435\u0442."
          },
          orderedLists: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u043D\u0443\u043C\u0435\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0445 \u0441\u043F\u0438\u0441\u043A\u043E\u0432",
            desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C 1. \u041F\u0440\u0438\u0432\u0435\u0442 \u0432 \u041F\u0440\u0438\u0432\u0435\u0442."
          },
          taskLists: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u0441\u043F\u0438\u0441\u043A\u043E\u0432 \u0437\u0430\u0434\u0430\u0447",
            desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C - [x] \u041F\u0440\u0438\u0432\u0435\u0442 \u0432 \u041F\u0440\u0438\u0432\u0435\u0442."
          },
          code: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u0432\u0441\u0442\u0440\u043E\u0435\u043D\u043D\u043E\u0433\u043E \u043A\u043E\u0434\u0430",
            desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C `\u041F\u0440\u0438\u0432\u0435\u0442` \u0432 \u041F\u0440\u0438\u0432\u0435\u0442."
          },
          codeBlocks: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u0431\u043B\u043E\u043A\u043E\u0432 \u043A\u043E\u0434\u0430",
            desc: "\u0412\u043C\u0435\u0441\u0442\u043E \u044D\u0442\u043E\u0433\u043E \u043F\u043E\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u043F\u0435\u0440\u0432\u0443\u044E \u0441\u0442\u0440\u043E\u043A\u0443 \u0438\u0437 \u0431\u043B\u043E\u043A\u0430 \u043A\u043E\u0434\u0430 \u0432 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435."
          },
          footnotes: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u0441\u043D\u043E\u0441\u043E\u043A",
            desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C \u041F\u0440\u0438\u0432\u0435\u0442[^1] \u0438\u043B\u0438 \u041F\u0440\u0438\u0432\u0435\u0442^[footnote] \u0432 \u041F\u0440\u0438\u0432\u0435\u0442."
          },
          comments: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u043A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0435\u0432",
            desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C %%\u041F\u0440\u0438\u0432\u0435\u0442%% \u0438\u043B\u0438 <!--\u041F\u0440\u0438\u0432\u0435\u0442--> \u0432 \u041F\u0440\u0438\u0432\u0435\u0442."
          },
          commentsEntirely: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u043A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0438 \u043F\u043E\u043B\u043D\u043E\u0441\u0442\u044C\u044E",
            desc: "\u0422\u0430\u043A\u0436\u0435 \u0443\u0434\u0430\u043B\u044F\u0442\u044C \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0435 \u043A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0435\u0432 \u0432 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0438."
          },
          stripTableMarkup: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u0442\u0430\u0431\u043B\u0438\u0446",
            desc: {
              part1: "\u0412\u043C\u0435\u0441\u0442\u043E \u044D\u0442\u043E\u0433\u043E \u043F\u043E\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u0432 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 ",
              table: "\u0422\u0430\u0431\u043B\u0438\u0446\u0430",
              part2: "."
            }
          },
          tables: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0443 \u0442\u0430\u0431\u043B\u0438\u0446",
            desc: {
              part1: "\u0412\u043C\u0435\u0441\u0442\u043E \u044D\u0442\u043E\u0433\u043E \u043F\u043E\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u0432 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 ",
              table: "\u0422\u0430\u0431\u043B\u0438\u0446\u0430",
              part2: "."
            }
          },
          htmlTags: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C HTML-\u0442\u0435\u0433\u0438",
            desc: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C <u>\u041F\u0440\u0438\u0432\u0435\u0442</u> \u0432 \u041F\u0440\u0438\u0432\u0435\u0442."
          },
          templater: {
            name: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0441\u0438\u043D\u0442\u0430\u043A\u0441\u0438\u0441 Templater",
            desc: {
              part1: "\u0423\u0431\u0438\u0440\u0430\u0442\u044C \u0441\u0438\u043D\u0442\u0430\u043A\u0441\u0438\u0441 ",
              part2: " \u0432\u0440\u043E\u0434\u0435 ",
              code: "<% tp.file.cursor() %>",
              part3: "."
            }
          }
        },
        commands: {
          ribbon: {
            title: "\u041A\u043E\u043C\u0430\u043D\u0434\u044B \u043D\u0430 \u043B\u0435\u043D\u0442\u0435",
            desc: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435, \u043A\u0430\u043A\u0438\u0435 \u043A\u043E\u043C\u0430\u043D\u0434\u044B \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u044E\u0442\u0441\u044F \u043D\u0430 \u043B\u0435\u043D\u0442\u0435. \u041F\u0435\u0440\u0435\u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u0435 \u043F\u043B\u0430\u0433\u0438\u043D \u0438\u043B\u0438 Obsidian \u0434\u043B\u044F \u043F\u0440\u0438\u043C\u0435\u043D\u0435\u043D\u0438\u044F."
          },
          palette: {
            title: "\u041A\u043E\u043C\u0430\u043D\u0434\u044B \u043F\u0430\u043B\u0438\u0442\u0440\u044B \u043A\u043E\u043C\u0430\u043D\u0434",
            desc: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435, \u043A\u0430\u043A\u0438\u0435 \u043A\u043E\u043C\u0430\u043D\u0434\u044B \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u044E\u0442\u0441\u044F \u0432 \u043F\u0430\u043B\u0438\u0442\u0440\u0435 \u043A\u043E\u043C\u0430\u043D\u0434 (Ctrl/Cmd-P \u043D\u0430 \u043A\u043E\u043C\u043F\u044C\u044E\u0442\u0435\u0440\u0435 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E). \u041F\u0435\u0440\u0435\u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u0435 \u043F\u043B\u0430\u0433\u0438\u043D \u0438\u043B\u0438 Obsidian \u0434\u043B\u044F \u043F\u0440\u0438\u043C\u0435\u043D\u0435\u043D\u0438\u044F."
          },
          file: {
            title: "\u041A\u043E\u043C\u0430\u043D\u0434\u044B \u0434\u043B\u044F \u0444\u0430\u0439\u043B\u043E\u0432",
            desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435, \u043A\u0430\u043A\u0438\u0435 \u043A\u043E\u043C\u0430\u043D\u0434\u044B \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u044E\u0442\u0441\u044F \u0432 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u043D\u043E\u043C \u043C\u0435\u043D\u044E \u0444\u0430\u0439\u043B\u0430."
          },
          folder: {
            title: "\u041A\u043E\u043C\u0430\u043D\u0434\u044B \u0434\u043B\u044F \u043F\u0430\u043F\u043E\u043A",
            desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435, \u043A\u0430\u043A\u0438\u0435 \u043A\u043E\u043C\u0430\u043D\u0434\u044B \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u044E\u0442\u0441\u044F \u0432 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u043D\u043E\u043C \u043C\u0435\u043D\u044E \u043F\u0430\u043F\u043A\u0438."
          },
          tag: {
            title: "\u041A\u043E\u043C\u0430\u043D\u0434\u044B \u0434\u043B\u044F \u0442\u0435\u0433\u043E\u0432",
            desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435, \u043A\u0430\u043A\u0438\u0435 \u043A\u043E\u043C\u0430\u043D\u0434\u044B \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u044E\u0442\u0441\u044F \u0432 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u043D\u043E\u043C \u043C\u0435\u043D\u044E \u0442\u0435\u0433\u0430."
          },
          search: {
            title: "\u041A\u043E\u043C\u0430\u043D\u0434\u044B \u043F\u043E\u0438\u0441\u043A\u0430 \u043F\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0443",
            desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435, \u043A\u0430\u043A\u0438\u0435 \u043A\u043E\u043C\u0430\u043D\u0434\u044B \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u044E\u0442\u0441\u044F \u0432 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u043D\u043E\u043C \u043C\u0435\u043D\u044E \u0440\u0435\u0437\u0443\u043B\u044C\u0442\u0430\u0442\u043E\u0432 \u043F\u043E\u0438\u0441\u043A\u0430."
          }
        },
        miscellaneous: {
          charCount: {
            name: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432",
            desc: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432 \u0432 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430.",
            default: "\u041F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E: 100"
          },
          notificationMode: {
            name: "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u0443\u0432\u0435\u0434\u043E\u043C\u043B\u0435\u043D\u0438\u0435 \u043F\u0440\u0438 \u0440\u0443\u0447\u043D\u043E\u043C \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0438",
            desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435, \u043A\u043E\u0433\u0434\u0430 \u043F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u0443\u0432\u0435\u0434\u043E\u043C\u043B\u0435\u043D\u0438\u044F \u0434\u043B\u044F \u043A\u043E\u043C\u0430\u043D\u0434 \u0440\u0443\u0447\u043D\u043E\u0433\u043E \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u044F.",
            always: "\u0412\u0441\u0435\u0433\u0434\u0430",
            onTitleChange: "\u041F\u0440\u0438 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0438 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u044F",
            never: "\u041D\u0438\u043A\u043E\u0433\u0434\u0430"
          },
          grabCardLink: {
            name: "\u0412\u0437\u044F\u0442\u044C \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0438\u0437 \u0441\u0441\u044B\u043B\u043A\u0438-\u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
            desc: {
              part1: "\u0415\u0441\u043B\u0438 \u0437\u0430\u043C\u0435\u0442\u043A\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0435\u0442\u0441\u044F \u0441\u043E \u0441\u0441\u044B\u043B\u043A\u0438-\u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438, \u0441\u043E\u0437\u0434\u0430\u043D\u043D\u043E\u0439 \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\u044E ",
              part2: " \u0438\u043B\u0438 ",
              part3: ", \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0431\u0443\u0434\u0435\u0442 \u043F\u043E\u043C\u0435\u0449\u0435\u043D\u043E \u0432 \u0438\u043C\u044F \u0444\u0430\u0439\u043B\u0430."
            }
          },
          newNoteDelay: {
            name: "\u0417\u0430\u0434\u0435\u0440\u0436\u043A\u0430 \u0434\u043B\u044F \u043D\u043E\u0432\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0438",
            desc: "\u0417\u0430\u0434\u0435\u0440\u0436\u043A\u0430 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0438 \u043D\u043E\u0432\u044B\u0445 \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u043D\u0430 \u0443\u043A\u0430\u0437\u0430\u043D\u043D\u043E\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043C\u0438\u043B\u043B\u0438\u0441\u0435\u043A\u0443\u043D\u0434. \u041C\u043E\u0436\u0435\u0442 \u0440\u0435\u0448\u0438\u0442\u044C \u043F\u0440\u043E\u0431\u043B\u0435\u043C\u044B \u043F\u0440\u0438 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0438 \u0437\u0430\u043C\u0435\u0442\u043A\u0438.",
            default: "\u041F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E: 0"
          },
          contentReadMethod: {
            name: "\u041C\u0435\u0442\u043E\u0434 \u0447\u0442\u0435\u043D\u0438\u044F \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0433\u043E",
            desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435, \u043A\u0430\u043A \u043F\u043B\u0430\u0433\u0438\u043D \u0447\u0438\u0442\u0430\u0435\u0442 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0435 \u0437\u0430\u043C\u0435\u0442\u043E\u043A. \u0427\u0442\u0435\u043D\u0438\u0435 \u0438\u0437 \u043A\u044D\u0448\u0430 \u0438\u043B\u0438 \u0444\u0430\u0439\u043B\u0430 \u043C\u043E\u0436\u0435\u0442 \u0440\u0435\u0448\u0438\u0442\u044C \u043F\u0440\u043E\u0431\u043B\u0435\u043C\u044B, \u043D\u043E \u0431\u0443\u0434\u0435\u0442 \u043C\u0435\u0434\u043B\u0435\u043D\u043D\u0435\u0435.",
            default: "\u041F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E: \u0420\u0435\u0434\u0430\u043A\u0442\u043E\u0440",
            editor: "\u0420\u0435\u0434\u0430\u043A\u0442\u043E\u0440",
            cache: "\u041A\u044D\u0448",
            file: "\u0424\u0430\u0439\u043B"
          },
          checkInterval: {
            name: "\u0418\u043D\u0442\u0435\u0440\u0432\u0430\u043B \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0438",
            desc: "\u0418\u043D\u0442\u0435\u0440\u0432\u0430\u043B \u0432 \u043C\u0438\u043B\u043B\u0438\u0441\u0435\u043A\u0443\u043D\u0434\u0430\u0445 \u0434\u043B\u044F \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0438 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0439 \u043F\u0435\u0440\u0432\u043E\u0439 \u0441\u0442\u0440\u043E\u043A\u0438. \u0423\u0432\u0435\u043B\u0438\u0447\u044C\u0442\u0435 \u0432 \u0441\u043B\u0443\u0447\u0430\u0435 \u043F\u0440\u043E\u0431\u043B\u0435\u043C.",
            default: "\u041F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E: 0"
          },
          debug: {
            name: "\u041E\u0442\u043B\u0430\u0434\u043A\u0430",
            desc: "\u0417\u0430\u043F\u0438\u0441\u044B\u0432\u0430\u0442\u044C \u0432\u0441\u044E \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0441\u0442\u044C \u043F\u043B\u0430\u0433\u0438\u043D\u0430 \u0432 \u043A\u043E\u043D\u0441\u043E\u043B\u044C \u0440\u0430\u0437\u0440\u0430\u0431\u043E\u0442\u0447\u0438\u043A\u0430."
          },
          debugOutputContent: {
            name: "\u0412\u044B\u0432\u043E\u0434\u0438\u0442\u044C \u043F\u043E\u043B\u043D\u043E\u0435 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0435 \u0444\u0430\u0439\u043B\u0430 \u0432 \u043A\u043E\u043D\u0441\u043E\u043B\u044C",
            desc: "\u0417\u0430\u043F\u0438\u0441\u044B\u0432\u0430\u0442\u044C \u043F\u043E\u043B\u043D\u043E\u0435 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0435 \u0444\u0430\u0439\u043B\u043E\u0432 (\u0432\u043A\u043B\u044E\u0447\u0430\u044F \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043E\u043A YAML) \u043F\u0440\u0438 \u0438\u0445 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0438."
          },
          clearSettings: {
            name: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438",
            desc: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u0432\u0441\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043F\u043B\u0430\u0433\u0438\u043D\u0430 \u043A \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u044F\u043C \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E.",
            modalButton: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438"
          }
        },
        safewords: {
          enableSafewords: {
            name: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0441\u0442\u043E\u043F-\u0441\u043B\u043E\u0432\u0430",
            desc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435 \u0442\u0435\u043A\u0441\u0442, \u043A\u043E\u0442\u043E\u0440\u044B\u0439 \u043F\u0440\u0435\u0434\u043E\u0442\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435, \u0435\u0441\u043B\u0438 \u0443\u043A\u0430\u0437\u0430\u043D \u0432 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430."
          },
          addButton: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u0442\u043E\u043F-\u0441\u043B\u043E\u0432\u043E",
          headers: {
            enable: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C",
            safeword: "\u0421\u0442\u043E\u043F-\u0441\u043B\u043E\u0432\u043E",
            onlyMatchStart: "\u0422\u043E\u043B\u044C\u043A\u043E \u0432 \u043D\u0430\u0447\u0430\u043B\u0435 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430",
            onlyMatchWhole: "\u0422\u043E\u043B\u044C\u043A\u043E \u043F\u043E\u043B\u043D\u043E\u0435 \u0438\u043C\u044F \u0444\u0430\u0439\u043B\u0430",
            caseSensitive: "\u0423\u0447\u0438\u0442\u044B\u0432\u0430\u0442\u044C \u0440\u0435\u0433\u0438\u0441\u0442\u0440"
          }
        }
      }
    };
  }
});

// require("../locale/**/*.json") in src/i18n.ts
var globRequire_locale_json;
var init_ = __esm({
  'require("../locale/**/*.json") in src/i18n.ts'() {
    globRequire_locale_json = __glob({
      "../locale/en.json": () => require_en(),
      "../locale/ru.json": () => require_ru()
    });
  }
});

// src/i18n.ts
function initI18n() {
  try {
    if (typeof window.localStorage !== "undefined" && window.localStorage.getItem("language")) {
      currentLocale = window.localStorage.getItem("language") || "en";
    }
  } catch (e) {
    currentLocale = import_obsidian.moment.locale();
  }
  currentLocale = currentLocale.split("-")[0].toLowerCase();
  try {
    translations = globRequire_locale_json(`../locale/${currentLocale}.json`);
  } catch (e) {
    currentLocale = "en";
    try {
      translations = require_en();
    } catch (err) {
      console.error("Failed to load translations:", err);
      translations = {};
    }
  }
}
function t(keyPath, variables, fallback) {
  let vars;
  let fb;
  if (typeof variables === "string") {
    fb = variables;
    vars = void 0;
  } else {
    vars = variables;
    fb = fallback;
  }
  const keys = keyPath.split(".");
  let value = translations;
  for (const key of keys) {
    if (value && typeof value === "object" && key in value) {
      value = value[key];
    } else {
      return fb || keyPath;
    }
  }
  let result = typeof value === "string" ? value : fb || keyPath;
  if (vars) {
    for (const [key, val] of Object.entries(vars)) {
      result = result.replace(`{{${key}}}`, String(val));
    }
  }
  return result;
}
function getCurrentLocale() {
  return currentLocale;
}
function getPluralForm(count, one, few, many) {
  if (currentLocale !== "ru") {
    return count === 1 ? one : many;
  }
  const mod10 = count % 10;
  const mod100 = count % 100;
  if (mod10 === 1 && mod100 !== 11) {
    return one;
  } else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
    return few;
  } else {
    return many;
  }
}
function tp(keyPath, count, fallback) {
  const keys = keyPath.split(".");
  let value = translations;
  for (const key of keys) {
    if (value && typeof value === "object" && key in value) {
      value = value[key];
    } else {
      return (fallback || keyPath).replace("{{count}}", String(count));
    }
  }
  if (typeof value === "string") {
    return value.replace("{{count}}", String(count));
  }
  let pluralKey;
  if (currentLocale !== "ru") {
    pluralKey = count === 1 ? "one" : "many";
  } else {
    const mod10 = count % 10;
    const mod100 = count % 100;
    if (mod10 === 1 && mod100 !== 11) {
      pluralKey = "one";
    } else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
      pluralKey = "few";
    } else {
      pluralKey = "many";
    }
  }
  const message = value[pluralKey] || value["many"] || fallback || keyPath;
  return typeof message === "string" ? message.replace("{{count}}", String(count)) : message;
}
function tpSplit(keyPath, count) {
  const keys = keyPath.split(".");
  let value = translations;
  for (const key of keys) {
    if (value && typeof value === "object" && key in value) {
      value = value[key];
    } else {
      return { before: keyPath, noun: "", after: "" };
    }
  }
  let pluralKey;
  if (currentLocale !== "ru") {
    pluralKey = count === 1 ? "one" : "many";
  } else {
    const mod10 = count % 10;
    const mod100 = count % 100;
    if (mod10 === 1 && mod100 !== 11) {
      pluralKey = "one";
    } else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
      pluralKey = "few";
    } else {
      pluralKey = "many";
    }
  }
  const pluralForm = value[pluralKey] || value["many"];
  if (pluralForm && typeof pluralForm === "object") {
    return {
      before: pluralForm.before || "",
      noun: pluralForm.noun || "",
      after: pluralForm.after || ""
    };
  }
  return { before: pluralForm || keyPath, noun: "", after: "" };
}
var import_obsidian, translations, currentLocale;
var init_i18n = __esm({
  "src/i18n.ts"() {
    import_obsidian = require("obsidian");
    init_();
    translations = {};
    currentLocale = "en";
  }
});

// src/utils.ts
function verboseLog(plugin, message, data) {
  if (plugin.settings.verboseLogging) {
    if (data) {
      console.debug(message, data);
    } else {
      console.debug(message);
    }
  }
}
function isValidHeading(line) {
  return /^#{1,6}\s+.*/.test(line);
}
function normalizePropertyValue(value) {
  if (typeof value !== "string") return value;
  if (value === "true") return true;
  if (value === "false") return false;
  if (value === "null") return null;
  if (value !== "" && !isNaN(Number(value))) {
    return Number(value);
  }
  return value;
}
function detectOS() {
  if (import_obsidian2.Platform.isMacOS || import_obsidian2.Platform.isIosApp) {
    return "macOS";
  }
  if (import_obsidian2.Platform.isWin) {
    return "Windows";
  }
  return "Linux";
}
function isFileInTargetFolders(file, settings) {
  var _a;
  const nonEmptyFolders = settings.excludedFolders.filter((folder) => folder.trim() !== "").map((folder) => (0, import_obsidian2.normalizePath)(folder));
  if (nonEmptyFolders.length === 0) return false;
  const filePath = (_a = file.parent) == null ? void 0 : _a.path;
  if (nonEmptyFolders.includes(filePath)) {
    return true;
  }
  if (settings.excludeSubfolders) {
    for (const targetFolder of nonEmptyFolders) {
      if (filePath && filePath.startsWith(targetFolder + "/")) {
        return true;
      }
    }
  }
  return false;
}
function fileHasExcludedProperties(file, settings, app) {
  const nonEmptyProperties = settings.excludedProperties.filter(
    (prop) => prop.key.trim() !== ""
  );
  if (nonEmptyProperties.length === 0) return false;
  const fileCache = app.metadataCache.getFileCache(file);
  if (!fileCache || !fileCache.frontmatter) return false;
  const frontmatter = fileCache.frontmatter;
  for (const excludedProp of nonEmptyProperties) {
    const propKey = excludedProp.key.trim();
    const propValue = excludedProp.value.trim();
    if (propKey in frontmatter) {
      if (propValue === "") {
        return true;
      }
      const frontmatterValue = frontmatter[propKey];
      if (typeof frontmatterValue === "string") {
        if (frontmatterValue === propValue) {
          return true;
        }
      } else if (Array.isArray(frontmatterValue)) {
        if (frontmatterValue.some((val) => String(val) === propValue)) {
          return true;
        }
      } else if (frontmatterValue != null) {
        if (String(frontmatterValue) === propValue) {
          return true;
        }
      }
    }
  }
  return false;
}
function fileHasTargetTags(file, settings, app, content) {
  const nonEmptyTags = settings.excludedTags.filter((tag) => tag.trim() !== "");
  if (nonEmptyTags.length === 0) return false;
  const fileCache = app.metadataCache.getFileCache(file);
  if (settings.tagMatchingMode !== "In note body only") {
    let fileTags = [];
    if (content) {
      fileTags = parseTagsFromYAML(content);
    } else if (fileCache && fileCache.frontmatter && fileCache.frontmatter.tags) {
      const frontmatterTags = fileCache.frontmatter.tags;
      fileTags = Array.isArray(frontmatterTags) ? frontmatterTags.map(String) : [String(frontmatterTags)];
    }
    for (const targetTag of nonEmptyTags) {
      const normalizedTargetTag = targetTag.startsWith("#") ? targetTag.slice(1) : targetTag;
      for (const fileTag of fileTags) {
        const normalizedFileTag = fileTag.toString();
        if (normalizedFileTag === normalizedTargetTag) {
          return true;
        }
        if (settings.excludeChildTags) {
          if (normalizedFileTag.startsWith(normalizedTargetTag + "/")) {
            return true;
          }
        }
      }
    }
  }
  if (settings.tagMatchingMode !== "In Properties only") {
    let inlineTagsInContent = [];
    if (content && settings.tagMatchingMode === "In Properties and note body") {
      inlineTagsInContent = parseInlineTagsFromText(content);
    } else if (content && settings.tagMatchingMode === "In note body only") {
      const bodyContent = stripFrontmatter(content);
      inlineTagsInContent = parseInlineTagsFromText(bodyContent);
    } else if (!content) {
      if (fileCache && fileCache.tags) {
        inlineTagsInContent = fileCache.tags.map(
          (tag) => tag.tag.startsWith("#") ? tag.tag.slice(1) : tag.tag
        );
      }
    }
    for (const targetTag of nonEmptyTags) {
      const normalizedTargetTag = targetTag.startsWith("#") ? targetTag.slice(1) : targetTag;
      for (const inlineTag of inlineTagsInContent) {
        if (inlineTag === normalizedTargetTag) {
          return true;
        }
        if (settings.excludeChildTags) {
          if (inlineTag.startsWith(normalizedTargetTag + "/")) {
            return true;
          }
        }
      }
    }
  }
  return false;
}
function shouldProcessFile(file, settings, app, content, exclusionOverrides) {
  const isInTargetFolders = isFileInTargetFolders(file, settings);
  const hasTargetTags = fileHasTargetTags(file, settings, app, content);
  const hasTargetProperties = fileHasExcludedProperties(file, settings, app);
  const applyStrategy = (isTargeted, hasTargets, strategy) => {
    if (strategy === "Only exclude...") {
      return hasTargets ? isTargeted : false;
    } else {
      return hasTargets ? !isTargeted : true;
    }
  };
  const shouldExcludeFromFolders = (exclusionOverrides == null ? void 0 : exclusionOverrides.ignoreFolder) ? false : applyStrategy(
    isInTargetFolders,
    settings.excludedFolders.some((folder) => folder.trim() !== ""),
    settings.folderScopeStrategy
  );
  const shouldExcludeFromTags = (exclusionOverrides == null ? void 0 : exclusionOverrides.ignoreTag) ? false : applyStrategy(
    hasTargetTags,
    settings.excludedTags.some((tag) => tag.trim() !== ""),
    settings.tagScopeStrategy
  );
  const shouldExcludeFromProperties = (exclusionOverrides == null ? void 0 : exclusionOverrides.ignoreProperty) ? false : applyStrategy(
    hasTargetProperties,
    settings.excludedProperties.some((prop) => prop.key.trim() !== ""),
    settings.propertyScopeStrategy
  );
  return !(shouldExcludeFromFolders || shouldExcludeFromTags || shouldExcludeFromProperties);
}
function parseInlineTagsFromText(content) {
  const tagRegex = /#([a-zA-Z][\w\-_/]*)/g;
  const tags = [];
  let match;
  while ((match = tagRegex.exec(content)) !== null) {
    const tag = match[1];
    if (!tags.includes(tag)) {
      tags.push(tag);
    }
  }
  return tags;
}
function stripFrontmatter(content) {
  if (!content.startsWith("---")) {
    return content;
  }
  const lines = content.split("\n");
  let endIndex = -1;
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].trim() === "---") {
      endIndex = i;
      break;
    }
  }
  if (endIndex === -1) {
    return content;
  }
  return lines.slice(endIndex + 1).join("\n");
}
function parseTagsFromYAML(content) {
  const tags = [];
  if (!content.startsWith("---")) {
    return tags;
  }
  const lines = content.split("\n");
  let yamlEndLine = -1;
  for (let i = 1; i < lines.length; i++) {
    if (lines[i] === "---") {
      yamlEndLine = i;
      break;
    }
  }
  if (yamlEndLine === -1) return tags;
  const yamlLines = lines.slice(1, yamlEndLine);
  let currentKey = "";
  let inArray = false;
  for (const line of yamlLines) {
    const trimmed = line.trim();
    if (trimmed === "" || trimmed.startsWith("#")) continue;
    if (trimmed.startsWith("- ")) {
      if (inArray && currentKey === "tags") {
        let tagValue = trimmed.substring(2).trim();
        if (tagValue.startsWith('"') && tagValue.endsWith('"') || tagValue.startsWith("'") && tagValue.endsWith("'")) {
          tagValue = tagValue.substring(1, tagValue.length - 1);
        }
        if (tagValue.startsWith("#")) {
          tagValue = tagValue.substring(1);
        }
        tags.push(tagValue);
      }
      continue;
    }
    if (trimmed.includes(":")) {
      const colonIndex = trimmed.indexOf(":");
      const key = trimmed.substring(0, colonIndex).trim();
      const value = trimmed.substring(colonIndex + 1).trim();
      currentKey = key;
      if (value === "" || value === "[") {
        inArray = true;
        continue;
      } else {
        inArray = false;
      }
      if (key === "tags" && value) {
        let tagValue = value;
        if (tagValue.startsWith('"') && tagValue.endsWith('"') || tagValue.startsWith("'") && tagValue.endsWith("'")) {
          tagValue = tagValue.substring(1, tagValue.length - 1);
        }
        if (tagValue.startsWith("#")) {
          tagValue = tagValue.substring(1);
        }
        tags.push(tagValue);
      }
    }
  }
  return tags;
}
async function hasDisablePropertyInFile(file, app, disableKey, disableValue) {
  try {
    const metadata = app.metadataCache.getFileCache(file);
    const frontmatter = metadata == null ? void 0 : metadata.frontmatter;
    if (!frontmatter) return false;
    const propertyValue = frontmatter[disableKey];
    if (propertyValue === void 0 || propertyValue === null) return false;
    const normalizedPropertyValue = normalizePropertyValue(propertyValue);
    const normalizedDisableValue = normalizePropertyValue(disableValue);
    if (Array.isArray(normalizedPropertyValue)) {
      return normalizedPropertyValue.some((item) => {
        const normalizedItem = normalizePropertyValue(item);
        if (typeof normalizedItem === "string" && typeof normalizedDisableValue === "string") {
          return normalizedItem.toLowerCase() === normalizedDisableValue.toLowerCase();
        }
        return normalizedItem === normalizedDisableValue;
      });
    }
    if (typeof normalizedPropertyValue === "string" && typeof normalizedDisableValue === "string") {
      return normalizedPropertyValue.toLowerCase() === normalizedDisableValue.toLowerCase();
    }
    return normalizedPropertyValue === normalizedDisableValue;
  } catch (error) {
    return false;
  }
}
function containsSafeword(filename, settings) {
  if (!settings.enableSafewords) return false;
  const filenameWithoutExt = filename.replace(/\.md$/, "");
  for (const safeword of settings.safewords) {
    if (!safeword.enabled || !safeword.text) continue;
    const compareFullFilename = safeword.caseSensitive ? filename : filename.toLowerCase();
    const compareFilenameWithoutExt = safeword.caseSensitive ? filenameWithoutExt : filenameWithoutExt.toLowerCase();
    const compareText = safeword.caseSensitive ? safeword.text : safeword.text.toLowerCase();
    for (const compareFilename of [compareFullFilename, compareFilenameWithoutExt]) {
      if (safeword.onlyWholeLine) {
        if (compareFilename.trim() === compareText.trim()) {
          return true;
        }
      } else if (safeword.onlyAtStart) {
        if (compareFilename.startsWith(compareText)) {
          return true;
        }
      } else {
        if (compareFilename.includes(compareText)) {
          return true;
        }
      }
    }
  }
  return false;
}
function extractTitle(line, settings) {
  const originalLine = line;
  line = line.trim();
  if (settings.stripTemplaterSyntax) {
    line = line.replace(/<%\s*tp\.file\.cursor\(\)\s*%>/, "").trim();
    if (line === "<%*") {
      return t("untitled");
    }
  }
  const isHeading = isValidHeading(originalLine);
  const isEmptyHeading = /^#{1,6}\s*$/.test(originalLine);
  if (isEmptyHeading) {
    return t("untitled");
  }
  const escapeMap = /* @__PURE__ */ new Map();
  let escapeCounter = 0;
  const backslashReplacementEnabled = settings.enableForbiddenCharReplacements && settings.charReplacementEnabled.backslash;
  if (!backslashReplacementEnabled) {
    line = line.replace(/\\(.)/g, (match, char) => {
      const placeholder = `__ESCAPED_${escapeCounter++}__`;
      escapeMap.set(placeholder, char);
      return placeholder;
    });
  }
  if (settings.enableStripMarkup || settings.omitComments || settings.omitHtmlTags) {
    const checkEscaped = (match, offset) => {
      if (backslashReplacementEnabled) return false;
      const matchEnd = offset + match.length;
      for (let i = offset; i < matchEnd; i++) {
        for (const placeholder of escapeMap.keys()) {
          if (line.indexOf(placeholder) === i) return true;
        }
      }
      return false;
    };
    if (settings.enableStripMarkup && settings.stripMarkupSettings.comments || settings.omitComments) {
      line = line.replace(/%%.*?%%/g, "");
      line = line.replace(/<!--.*?-->/g, "");
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.bold) {
      line = line.replace(/\*\*(.+?)\*\*/g, (match, content, offset) => {
        return checkEscaped(match, offset) ? match : content;
      });
      line = line.replace(/__(.+?)__/g, (match, content, offset) => {
        return checkEscaped(match, offset) ? match : content;
      });
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.italic) {
      line = line.replace(/(?<!\*)\*(?!\*)(.+?)(?<!\*)\*(?!\*)/g, (match, content, offset) => {
        return checkEscaped(match, offset) ? match : content;
      });
      line = line.replace(/(?<!_)_(?!_)(.+?)(?<!_)_(?!_)/g, (match, content, offset) => {
        return checkEscaped(match, offset) ? match : content;
      });
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.strikethrough) {
      line = line.replace(/~~(.+?)~~/g, (match, content, offset) => {
        return checkEscaped(match, offset) ? match : content;
      });
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.highlight) {
      line = line.replace(/==(.+?)==/g, (match, content, offset) => {
        return checkEscaped(match, offset) ? match : content;
      });
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.codeBlocks) {
      if (/^\s*```\s*$/.test(line)) {
        return t("untitled");
      }
      const codeBlockMatch = /^\s*```(?!`)[^\n]*\n([\s\S]+)/m.exec(line);
      if (codeBlockMatch) {
        const content = codeBlockMatch[1];
        const contentLines = content.split("\n");
        let foundLine = false;
        for (const contentLine of contentLines) {
          const trimmed = contentLine.trim();
          if (trimmed !== "" && !trimmed.startsWith("```")) {
            line = contentLine;
            foundLine = true;
            break;
          }
        }
        if (!foundLine) {
          return t("untitled");
        }
      }
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.code) {
      line = line.replace(/`(.+?)`/g, (match, content, offset) => {
        return checkEscaped(match, offset) ? match : content;
      });
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.callouts) {
      line = line.replace(/^>\s*\[![^\]]+\]\s*(.*)$/gm, "$1");
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.quote) {
      line = line.replace(/^>\s*(.*)$/gm, "$1");
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.taskLists) {
      line = line.replace(/^(?:[-+*]|\d+\.) \[.\] /gm, "");
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.unorderedLists) {
      line = line.replace(/^[-+*] /gm, "");
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.orderedLists) {
      line = line.replace(/^\d+\. /gm, "");
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.htmlTags || settings.omitHtmlTags) {
      let previousLine = "";
      while (line !== previousLine) {
        previousLine = line;
        line = line.replace(/<([a-zA-Z][a-zA-Z0-9]*)\b[^>]*>(.*?)<\/\1>/g, "$2");
      }
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.footnotes) {
      line = line.replace(/\[\^[^\]]+\](?!:)/g, "");
      line = line.replace(/\^\[[^\]]+\](?!:)/g, "");
    }
  }
  const embedLinkRegex = /!\[\[(.*?)\]\]/g;
  line = line.replace(embedLinkRegex, "[[$1]]");
  const regularEmbedRegex = /!\[(.*?)\]\((.*?)\)/g;
  line = line.replace(regularEmbedRegex, (match, caption) => caption);
  if (isHeading && (!settings.enableStripMarkup || settings.stripMarkupSettings.headings)) {
    const headerArr = [
      "# ",
      "## ",
      "### ",
      "#### ",
      "##### ",
      "###### "
    ];
    for (let i = 0; i < headerArr.length; i++) {
      if (line.startsWith(headerArr[i])) {
        line = line.slice(headerArr[i].length).trim();
        break;
      }
    }
  }
  if (!settings.enableStripMarkup || settings.stripMarkupSettings.wikilinks) {
    while (line.includes("[[") && line.includes("]]")) {
      const openBracket = line.indexOf("[[");
      const closeBracket = line.indexOf("]]", openBracket);
      if (openBracket === -1 || closeBracket === -1) break;
      const linkText = line.slice(openBracket + 2, closeBracket);
      const beforeLink = line.slice(0, openBracket);
      const afterLink = line.slice(closeBracket + 2);
      const pipeIndex = linkText.indexOf("|");
      const resolvedText = pipeIndex !== -1 ? linkText.slice(pipeIndex + 1) : linkText;
      line = (beforeLink + resolvedText + afterLink).trim();
    }
  }
  const onlyEmptyLinksRegex = /^(\s*!?\[\]\([^)]*\)\s*)+$/;
  if (onlyEmptyLinksRegex.test(line)) {
    return t("untitled");
  }
  if (!settings.enableStripMarkup || settings.stripMarkupSettings.markdownLinks) {
    const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
    line = line.replace(markdownLinkRegex, (_, title) => title);
    line = line.replace(/!?\[\]\([^)]*\)/g, "").trim();
  }
  if (!backslashReplacementEnabled) {
    for (const [placeholder, char] of escapeMap) {
      line = line.replace(placeholder, char);
    }
  }
  return line;
}
function generateSafeLinkTarget(text, settings) {
  function detectOS2() {
    const platform = window.navigator.platform.toLowerCase();
    if (platform.indexOf("win") !== -1) return "Windows";
    if (platform.indexOf("mac") !== -1) return "macOS";
    return "Linux";
  }
  const charMap = {
    "/": settings.charReplacements.slash,
    ":": settings.charReplacements.colon,
    "|": settings.charReplacements.pipe,
    "#": settings.charReplacements.hash,
    "[": settings.charReplacements.leftBracket,
    "]": settings.charReplacements.rightBracket,
    "^": settings.charReplacements.caret,
    "*": settings.charReplacements.asterisk,
    "?": settings.charReplacements.question,
    "<": settings.charReplacements.lessThan,
    ">": settings.charReplacements.greaterThan,
    '"': settings.charReplacements.quote,
    [String.fromCharCode(92)]: settings.charReplacements.backslash,
    ".": settings.charReplacements.dot
  };
  const universalForbiddenChars = UNIVERSAL_FORBIDDEN_CHARS;
  const windowsAndroidChars = WINDOWS_ANDROID_CHARS;
  const allForbiddenChars = [...universalForbiddenChars];
  const currentOS = detectOS2();
  if (currentOS === "Windows" || settings.windowsAndroidEnabled) {
    allForbiddenChars.push(...windowsAndroidChars);
  }
  const forbiddenChars = [...new Set(allForbiddenChars)].join("");
  let result = "";
  for (let i = 0; i < text.length; i++) {
    let char = text[i];
    if (char === ".") {
      if (result === "") {
        if (settings.enableForbiddenCharReplacements && settings.charReplacementEnabled.dot) {
          const replacement = charMap["."] || "";
          if (replacement !== "") {
            if (settings.charReplacementTrimRight.dot) {
              while (i + 1 < text.length && /\s/.test(text[i + 1])) {
                i++;
              }
            }
            result += replacement;
          }
        }
      } else {
        result += ".";
      }
    } else if (forbiddenChars.includes(char)) {
      let shouldReplace = false;
      let replacement = "";
      if (settings.enableForbiddenCharReplacements) {
        let settingKey = null;
        switch (char) {
          case "/":
            settingKey = "slash";
            break;
          case String.fromCharCode(92):
            settingKey = "backslash";
            break;
          case ":":
            settingKey = "colon";
            break;
          case "|":
            settingKey = "pipe";
            break;
          case "#":
            settingKey = "hash";
            break;
          case "[":
            settingKey = "leftBracket";
            break;
          case "]":
            settingKey = "rightBracket";
            break;
          case "^":
            settingKey = "caret";
            break;
          case "*":
            settingKey = "asterisk";
            break;
          case "?":
            settingKey = "question";
            break;
          case "<":
            settingKey = "lessThan";
            break;
          case ">":
            settingKey = "greaterThan";
            break;
          case '"':
            settingKey = "quote";
            break;
        }
        const isWindowsAndroidChar = WINDOWS_ANDROID_CHARS.includes(char);
        const canReplace = isWindowsAndroidChar ? settings.windowsAndroidEnabled && settingKey && settings.charReplacementEnabled[settingKey] : settingKey && settings.charReplacementEnabled[settingKey];
        if (canReplace && settingKey) {
          shouldReplace = true;
          replacement = charMap[char] || "";
          if (replacement !== "") {
            if (settings.charReplacementTrimLeft[settingKey]) {
              result = result.trimEnd();
            }
            if (settings.charReplacementTrimRight[settingKey]) {
              while (i + 1 < text.length && /\s/.test(text[i + 1])) {
                i++;
              }
            }
          }
        }
      }
      if (shouldReplace && replacement !== "") {
        result += replacement;
      }
    } else {
      result += char;
    }
  }
  return result.trim();
}
function findTitleSourceLine(firstNonEmptyLine, contentLines, settings, plugin) {
  let titleSourceLine = firstNonEmptyLine;
  if (settings.stripTableMarkup) {
    const pipeCount = (titleSourceLine.match(/\|/g) || []).length;
    if (pipeCount >= 3) {
      titleSourceLine = t("table");
      if (plugin) {
        verboseLog(plugin, `Table row detected, using "${t("table")}" as title`);
      }
    }
  }
  if (settings.grabTitleFromCardLink) {
    const cardLinkMatch = titleSourceLine.trim().match(/^```(embed|cardlink)$/);
    if (cardLinkMatch) {
      let foundTitle = false;
      const maxLinesToCheck = 20;
      let nonEmptyCount = 0;
      for (let i = 0; i < Math.min(contentLines.length, maxLinesToCheck); i++) {
        const line = contentLines[i].trim();
        if (line === "") continue;
        nonEmptyCount++;
        if (nonEmptyCount === 1) continue;
        if (nonEmptyCount > 10) break;
        if (line.toLowerCase().startsWith("title:")) {
          let title = line.substring(line.indexOf(":") + 1).trim();
          if (title.startsWith('"') && title.endsWith('"') || title.startsWith("'") && title.endsWith("'")) {
            title = title.substring(1, title.length - 1);
          }
          titleSourceLine = title;
          foundTitle = true;
          if (plugin) {
            verboseLog(plugin, `Found ${cardLinkMatch[1]} card link`, { title: titleSourceLine });
          }
          break;
        }
        if (line.startsWith("```")) {
          titleSourceLine = t("untitled");
          if (plugin) {
            verboseLog(plugin, `Card link has no title, using ${t("untitled")}`);
          }
          break;
        }
      }
      if (!foundTitle && titleSourceLine !== t("untitled")) {
        titleSourceLine = t("untitled");
      }
    }
  }
  const trimmedTitleSourceLine = titleSourceLine.trim();
  if (trimmedTitleSourceLine.startsWith("```") && !trimmedTitleSourceLine.match(/^```(embed|cardlink)$/)) {
    let nonEmptyCount = 0;
    for (const line of contentLines) {
      if (line.trim() !== "") {
        nonEmptyCount++;
        if (nonEmptyCount === 2) {
          titleSourceLine = line;
          if (plugin) {
            verboseLog(plugin, `Code block detected, using second line as title source: ${titleSourceLine}`);
          }
          break;
        }
      }
    }
  }
  return titleSourceLine;
}
var import_obsidian2;
var init_utils = __esm({
  "src/utils.ts"() {
    import_obsidian2 = require("obsidian");
    init_constants();
    init_i18n();
  }
});

// src/modals.ts
var modals_exports = {};
__export(modals_exports, {
  ClearSettingsModal: () => ClearSettingsModal,
  DisableEnableModal: () => DisableEnableModal,
  InternalLinkModal: () => InternalLinkModal,
  ProcessTagModal: () => ProcessTagModal,
  RenameAllFilesModal: () => RenameAllFilesModal,
  RenameFolderModal: () => RenameFolderModal,
  RenameModal: () => RenameModal,
  RenameMultipleFoldersModal: () => RenameMultipleFoldersModal
});
var import_obsidian3, RenameAllFilesModal, RenameFolderModal, RenameMultipleFoldersModal, ProcessTagModal, ClearSettingsModal, RenameModal, DisableEnableModal, InternalLinkModal;
var init_modals = __esm({
  "src/modals.ts"() {
    import_obsidian3 = require("obsidian");
    init_utils();
    init_i18n();
    RenameAllFilesModal = class extends import_obsidian3.Modal {
      constructor(app, plugin) {
        super(app);
        this.plugin = plugin;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        const heading = contentEl.createEl("h2", { text: t("modals.caution"), cls: "flit-modal-heading" });
        const allFiles = this.app.vault.getMarkdownFiles();
        const count = allFiles.length;
        const messagePara = contentEl.createEl("p");
        const parts = tpSplit("modals.processNNotes", count);
        messagePara.appendText(parts.before);
        messagePara.createEl("strong", { text: `${count} ${parts.noun}` });
        messagePara.appendText(parts.after);
        const ensureList = contentEl.createEl("p", { text: t("modals.ensure") });
        ensureList.style.marginTop = "10px";
        ensureList.style.marginBottom = "10px";
        const ul = contentEl.createEl("ul");
        ul.style.marginTop = "0";
        ul.style.paddingLeft = "20px";
        const li1 = ul.createEl("li");
        const backupText = t("modals.filesBackedUp");
        const backupParts = backupText.split(t("modals.backedUpLinkText"));
        li1.appendText(backupParts[0]);
        li1.createEl("a", { text: t("modals.backedUpLinkText"), href: "https://help.obsidian.md/backup" });
        if (backupParts[1]) li1.appendText(backupParts[1]);
        ul.createEl("li", { text: t("modals.exclusionsConfigured") });
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container flit-modal-button-container" });
        const cancelButton = buttonContainer.createEl("button", { text: t("modals.buttons.cancel") });
        cancelButton.onclick = () => this.close();
        const renameButton = buttonContainer.createEl("button", { text: t("modals.buttons.rename") });
        renameButton.addClass("mod-cta");
        renameButton.onclick = async () => {
          this.close();
          await this.renameAllFiles();
        };
      }
      async renameAllFiles() {
        let filesToRename = [];
        this.app.vault.getMarkdownFiles().forEach((file) => {
          if (shouldProcessFile(file, this.plugin.settings, this.app)) {
            filesToRename.push(file);
          }
        });
        filesToRename.sort((a, b) => a.stat.ctime - b.stat.ctime);
        const renamingMsg = t("notifications.renamingNNotes").replace("{{count}}", String(filesToRename.length));
        verboseLog(this.plugin, `Showing notice: ${renamingMsg}`);
        const pleaseWaitNotice = new import_obsidian3.Notice(renamingMsg, 0);
        verboseLog(this.plugin, `Starting bulk rename of ${filesToRename.length} files`);
        const exclusionOverrides = {
          ignoreFolder: true,
          ignoreTag: true,
          ignoreProperty: true
        };
        let renamedFileCount = 0;
        try {
          const errors = [];
          for (const file of filesToRename) {
            try {
              await this.plugin.renameEngine.processFile(file, true, true, void 0, true, exclusionOverrides);
              renamedFileCount++;
            } catch (error) {
              errors.push(`Failed to rename ${file.path}: ${error}`);
              console.error(`Error renaming ${file.path}`, error);
            }
          }
          if (errors.length > 0) {
            const errorMsg = t("notifications.renamedNotesWithErrors").replace("{{renamed}}", String(renamedFileCount)).replace("{{total}}", String(filesToRename.length)).replace("{{errors}}", String(errors.length));
            verboseLog(this.plugin, `Showing notice: ${errorMsg}`);
            new import_obsidian3.Notice(errorMsg, 0);
            console.error("Rename errors:", errors);
          }
        } finally {
          if (this.plugin.cacheManager) {
            this.plugin.cacheManager.clearReservedPaths();
            verboseLog(this.plugin, "Cache cleaned up immediately after batch operation");
          }
          pleaseWaitNotice.hide();
          const renamedMsg = t("notifications.renamedNotes").replace("{{renamed}}", String(renamedFileCount)).replace("{{total}}", String(filesToRename.length));
          verboseLog(this.plugin, `Showing notice: ${renamedMsg}`);
          new import_obsidian3.Notice(renamedMsg, 0);
          verboseLog(this.plugin, `Bulk rename completed: ${renamedFileCount}/${filesToRename.length} files renamed`);
        }
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    RenameFolderModal = class extends import_obsidian3.Modal {
      constructor(app, plugin, folder) {
        super(app);
        this.plugin = plugin;
        this.folder = folder;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        const heading = contentEl.createEl("h2", { text: t("modals.caution"), cls: "flit-modal-heading" });
        const folderFiles = this.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian3.TFile && f.extension === "md").filter((f) => {
          var _a;
          return f.path.startsWith(this.folder.path + "/") || ((_a = f.parent) == null ? void 0 : _a.path) === this.folder.path;
        });
        const count = folderFiles.length;
        const messagePara = contentEl.createEl("p");
        const parts = tpSplit("modals.processNNotes", count);
        messagePara.appendText(parts.before);
        messagePara.createEl("strong", { text: `${count} ${parts.noun}` });
        messagePara.appendText(parts.after);
        messagePara.createEl("br");
        messagePara.createEl("br");
        const backupText = t("modals.ensureFilesBackedUp");
        const backupParts = backupText.split(t("modals.backedUpLinkText"));
        messagePara.appendText(backupParts[0]);
        messagePara.createEl("a", { text: t("modals.backedUpLinkText"), href: "https://help.obsidian.md/backup" });
        if (backupParts[1]) messagePara.appendText(backupParts[1]);
        const optionsContainer = contentEl.createDiv({ cls: "flit-modal-options" });
        const subfoldersContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const subfoldersCheckbox = subfoldersContainer.createEl("input", { type: "checkbox" });
        subfoldersCheckbox.id = "rename-subfolders";
        subfoldersCheckbox.checked = this.plugin.settings.modalCheckboxStates.folderRename.includeSubfolders;
        const subfoldersLabel = subfoldersContainer.createEl("label");
        subfoldersLabel.setAttribute("for", "rename-subfolders");
        subfoldersLabel.textContent = t("modals.renameInAllSubfolders");
        const excludedFoldersContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedFoldersCheckbox = excludedFoldersContainer.createEl("input", { type: "checkbox" });
        excludedFoldersCheckbox.id = "rename-excluded-folders";
        excludedFoldersCheckbox.checked = this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedFolders;
        const excludedFoldersLabel = excludedFoldersContainer.createEl("label");
        excludedFoldersLabel.setAttribute("for", "rename-excluded-folders");
        excludedFoldersLabel.textContent = t("modals.renameInExcludedFolders");
        const excludedTagsContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedTagsCheckbox = excludedTagsContainer.createEl("input", { type: "checkbox" });
        excludedTagsCheckbox.id = "rename-excluded-tags";
        excludedTagsCheckbox.checked = this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedTags;
        const excludedTagsLabel = excludedTagsContainer.createEl("label");
        excludedTagsLabel.setAttribute("for", "rename-excluded-tags");
        excludedTagsLabel.textContent = t("modals.renameWithExcludedTags");
        const excludedPropsContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedPropsCheckbox = excludedPropsContainer.createEl("input", { type: "checkbox" });
        excludedPropsCheckbox.id = "rename-excluded-properties";
        excludedPropsCheckbox.checked = this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedProperties;
        const excludedPropsLabel = excludedPropsContainer.createEl("label");
        excludedPropsLabel.setAttribute("for", "rename-excluded-properties");
        excludedPropsLabel.textContent = t("modals.renameWithExcludedProperties");
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container flit-modal-button-container" });
        const cancelButton = buttonContainer.createEl("button", { text: t("modals.buttons.cancel") });
        cancelButton.onclick = () => this.close();
        const renameButton = buttonContainer.createEl("button", { text: t("modals.buttons.rename") });
        renameButton.addClass("mod-cta");
        renameButton.onclick = async () => {
          this.plugin.settings.modalCheckboxStates.folderRename.includeSubfolders = subfoldersCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedFolders = excludedFoldersCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedTags = excludedTagsCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedProperties = excludedPropsCheckbox.checked;
          await this.plugin.saveSettings();
          this.close();
          await this.renameFolderFiles(
            subfoldersCheckbox.checked,
            excludedFoldersCheckbox.checked,
            excludedTagsCheckbox.checked,
            excludedPropsCheckbox.checked
          );
        };
      }
      async renameFolderFiles(includeSubfolders, renameExcludedFolders, renameExcludedTags, renameExcludedProperties) {
        var _a, _b;
        const allFiles = this.app.vault.getMarkdownFiles();
        const filesToRename = [];
        for (const file of allFiles) {
          const isInFolder = ((_a = file.parent) == null ? void 0 : _a.path) === this.folder.path;
          const isInSubfolder = file.path.startsWith(this.folder.path + "/") && ((_b = file.parent) == null ? void 0 : _b.path) !== this.folder.path;
          if (!isInFolder && (!includeSubfolders || !isInSubfolder)) {
            continue;
          }
          filesToRename.push(file);
        }
        filesToRename.sort((a, b) => a.stat.ctime - b.stat.ctime);
        const renamingMsg = t("notifications.renamingNNotes").replace("{{count}}", String(filesToRename.length));
        verboseLog(this.plugin, renamingMsg);
        const pleaseWaitNotice = new import_obsidian3.Notice(renamingMsg, 0);
        const exclusionOverrides = {
          ignoreFolder: renameExcludedFolders,
          ignoreTag: renameExcludedTags,
          ignoreProperty: renameExcludedProperties
        };
        let renamedFileCount = 0;
        try {
          for (const file of filesToRename) {
            try {
              await this.plugin.renameEngine.processFile(file, true, true, void 0, true, exclusionOverrides);
              renamedFileCount++;
            } catch (error) {
              console.error(`Error processing ${file.path}`, error);
            }
          }
        } finally {
          if (this.plugin.cacheManager) {
            this.plugin.cacheManager.clearReservedPaths();
          }
          pleaseWaitNotice.hide();
          verboseLog(this.plugin, `Renamed ${renamedFileCount}/${filesToRename.length} notes.`);
          const renamedMsg = t("notifications.renamedNotes").replace("{{renamed}}", String(renamedFileCount)).replace("{{total}}", String(filesToRename.length));
          new import_obsidian3.Notice(renamedMsg, 0);
        }
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    RenameMultipleFoldersModal = class extends import_obsidian3.Modal {
      constructor(app, plugin, folders) {
        super(app);
        this.plugin = plugin;
        this.folders = folders;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        const heading = contentEl.createEl("h2", { text: t("modals.caution"), cls: "flit-modal-heading" });
        let totalFiles = 0;
        this.folders.forEach((folder) => {
          const folderFiles = this.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian3.TFile && f.extension === "md").filter((f) => {
            var _a;
            return f.path.startsWith(folder.path + "/") || ((_a = f.parent) == null ? void 0 : _a.path) === folder.path;
          });
          totalFiles += folderFiles.length;
        });
        const messagePara = contentEl.createEl("p");
        const parts = tpSplit("modals.processNNotes", totalFiles);
        messagePara.appendText(parts.before);
        messagePara.createEl("strong", { text: `${totalFiles} ${parts.noun}` });
        messagePara.appendText(parts.after);
        messagePara.createEl("br");
        messagePara.createEl("br");
        const backupText = t("modals.ensureFilesBackedUp");
        const backupParts = backupText.split(t("modals.backedUpLinkText"));
        messagePara.appendText(backupParts[0]);
        messagePara.createEl("a", { text: t("modals.backedUpLinkText"), href: "https://help.obsidian.md/backup" });
        if (backupParts[1]) messagePara.appendText(backupParts[1]);
        const optionsContainer = contentEl.createDiv({ cls: "flit-modal-options" });
        const subfoldersContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const subfoldersCheckbox = subfoldersContainer.createEl("input", { type: "checkbox" });
        subfoldersCheckbox.id = "rename-subfolders";
        subfoldersCheckbox.checked = this.plugin.settings.modalCheckboxStates.folderRename.includeSubfolders;
        const subfoldersLabel = subfoldersContainer.createEl("label");
        subfoldersLabel.setAttribute("for", "rename-subfolders");
        subfoldersLabel.textContent = t("modals.renameInAllSubfolders");
        const excludedFoldersContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedFoldersCheckbox = excludedFoldersContainer.createEl("input", { type: "checkbox" });
        excludedFoldersCheckbox.id = "rename-excluded-folders";
        excludedFoldersCheckbox.checked = this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedFolders;
        const excludedFoldersLabel = excludedFoldersContainer.createEl("label");
        excludedFoldersLabel.setAttribute("for", "rename-excluded-folders");
        excludedFoldersLabel.textContent = t("modals.renameInExcludedFolders");
        const excludedTagsContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedTagsCheckbox = excludedTagsContainer.createEl("input", { type: "checkbox" });
        excludedTagsCheckbox.id = "rename-excluded-tags";
        excludedTagsCheckbox.checked = this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedTags;
        const excludedTagsLabel = excludedTagsContainer.createEl("label");
        excludedTagsLabel.setAttribute("for", "rename-excluded-tags");
        excludedTagsLabel.textContent = t("modals.renameWithExcludedTags");
        const excludedPropsContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedPropsCheckbox = excludedPropsContainer.createEl("input", { type: "checkbox" });
        excludedPropsCheckbox.id = "rename-excluded-properties";
        excludedPropsCheckbox.checked = this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedProperties;
        const excludedPropsLabel = excludedPropsContainer.createEl("label");
        excludedPropsLabel.setAttribute("for", "rename-excluded-properties");
        excludedPropsLabel.textContent = t("modals.renameWithExcludedProperties");
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container flit-modal-button-container" });
        const cancelButton = buttonContainer.createEl("button", { text: t("modals.buttons.cancel") });
        cancelButton.onclick = () => this.close();
        const renameButton = buttonContainer.createEl("button", { text: t("modals.buttons.rename") });
        renameButton.addClass("mod-cta");
        renameButton.onclick = async () => {
          this.plugin.settings.modalCheckboxStates.folderRename.includeSubfolders = subfoldersCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedFolders = excludedFoldersCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedTags = excludedTagsCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedProperties = excludedPropsCheckbox.checked;
          await this.plugin.saveSettings();
          this.close();
          await this.renameMultipleFolders(
            subfoldersCheckbox.checked,
            excludedFoldersCheckbox.checked,
            excludedTagsCheckbox.checked,
            excludedPropsCheckbox.checked
          );
        };
      }
      async renameMultipleFolders(includeSubfolders, renameExcludedFolders, renameExcludedTags, renameExcludedProperties) {
        var _a, _b;
        const allFiles = this.app.vault.getMarkdownFiles();
        const filesToRename = [];
        for (const folder of this.folders) {
          for (const file of allFiles) {
            const isInFolder = ((_a = file.parent) == null ? void 0 : _a.path) === folder.path;
            const isInSubfolder = file.path.startsWith(folder.path + "/") && ((_b = file.parent) == null ? void 0 : _b.path) !== folder.path;
            if (!isInFolder && (!includeSubfolders || !isInSubfolder)) {
              continue;
            }
            if (!filesToRename.includes(file)) {
              filesToRename.push(file);
            }
          }
        }
        filesToRename.sort((a, b) => a.stat.ctime - b.stat.ctime);
        const renamingMsg = t("notifications.renamingNNotes").replace("{{count}}", String(filesToRename.length));
        verboseLog(this.plugin, renamingMsg);
        const pleaseWaitNotice = new import_obsidian3.Notice(renamingMsg, 0);
        const exclusionOverrides = {
          ignoreFolder: renameExcludedFolders,
          ignoreTag: renameExcludedTags,
          ignoreProperty: renameExcludedProperties
        };
        let renamedFileCount = 0;
        try {
          for (const file of filesToRename) {
            try {
              await this.plugin.renameEngine.processFile(file, true, true, void 0, true, exclusionOverrides);
              renamedFileCount++;
            } catch (error) {
              console.error(`Error processing ${file.path}`, error);
            }
          }
        } finally {
          if (this.plugin.cacheManager) {
            this.plugin.cacheManager.clearReservedPaths();
          }
          pleaseWaitNotice.hide();
          verboseLog(this.plugin, `Renamed ${renamedFileCount}/${filesToRename.length} notes.`);
          const renamedMsg = t("notifications.renamedNotes").replace("{{renamed}}", String(renamedFileCount)).replace("{{total}}", String(filesToRename.length));
          new import_obsidian3.Notice(renamedMsg, 0);
        }
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    ProcessTagModal = class extends import_obsidian3.Modal {
      constructor(app, plugin, tag) {
        super(app);
        this.plugin = plugin;
        this.tag = tag;
      }
      onOpen() {
        var _a;
        const { contentEl } = this;
        contentEl.empty();
        const heading = contentEl.createEl("h2", { text: t("modals.caution"), cls: "flit-modal-heading" });
        const allFiles = this.app.vault.getMarkdownFiles();
        let count = 0;
        for (const file of allFiles) {
          const cache = this.app.metadataCache.getFileCache(file);
          if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.tags) {
            const frontmatterTags = Array.isArray(cache.frontmatter.tags) ? cache.frontmatter.tags : [cache.frontmatter.tags];
            for (const tag of frontmatterTags) {
              const normalizedTag = tag.startsWith("#") ? tag.slice(1) : tag;
              if (normalizedTag === this.tag || normalizedTag.startsWith(`${this.tag}/`)) {
                count++;
                break;
              }
            }
          }
          if (cache == null ? void 0 : cache.tags) {
            for (const tagCache of cache.tags) {
              const normalizedTag = tagCache.tag.startsWith("#") ? tagCache.tag.slice(1) : tagCache.tag;
              if (normalizedTag === this.tag || normalizedTag.startsWith(`${this.tag}/`)) {
                count++;
                break;
              }
            }
          }
        }
        const messagePara = contentEl.createEl("p");
        const parts = tpSplit("modals.processNotesMessage", count);
        messagePara.appendText(parts.before);
        messagePara.createEl("strong", { text: `${count} ${parts.noun}` });
        messagePara.appendText(parts.after);
        messagePara.createEl("br");
        messagePara.createEl("br");
        const backupText = t("modals.ensureFilesBackedUp");
        const backupParts = backupText.split(t("modals.backedUpLinkText"));
        messagePara.appendText(backupParts[0]);
        messagePara.createEl("a", { text: t("modals.backedUpLinkText"), href: "https://help.obsidian.md/backup" });
        if (backupParts[1]) messagePara.appendText(backupParts[1]);
        const optionsContainer = contentEl.createDiv({ cls: "flit-modal-options" });
        const childTagsContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const childTagsCheckbox = childTagsContainer.createEl("input", { type: "checkbox" });
        childTagsCheckbox.id = "rename-child-tags";
        childTagsCheckbox.checked = this.plugin.settings.modalCheckboxStates.tagRename.includeChildTags;
        const childTagsLabel = childTagsContainer.createEl("label");
        childTagsLabel.setAttribute("for", "rename-child-tags");
        childTagsLabel.textContent = t("modals.renameWithChildTags");
        const excludedFoldersContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedFoldersCheckbox = excludedFoldersContainer.createEl("input", { type: "checkbox" });
        excludedFoldersCheckbox.id = "rename-excluded-folders";
        excludedFoldersCheckbox.checked = this.plugin.settings.modalCheckboxStates.tagRename.renameExcludedFolders;
        const excludedFoldersLabel = excludedFoldersContainer.createEl("label");
        excludedFoldersLabel.setAttribute("for", "rename-excluded-folders");
        excludedFoldersLabel.textContent = t("modals.renameInExcludedFolders");
        const excludedTagsContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedTagsCheckbox = excludedTagsContainer.createEl("input", { type: "checkbox" });
        excludedTagsCheckbox.id = "rename-excluded-tags";
        excludedTagsCheckbox.checked = this.plugin.settings.modalCheckboxStates.tagRename.renameExcludedTags;
        const excludedTagsLabel = excludedTagsContainer.createEl("label");
        excludedTagsLabel.setAttribute("for", "rename-excluded-tags");
        excludedTagsLabel.textContent = t("modals.renameWithExcludedTags");
        const excludedPropsContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedPropsCheckbox = excludedPropsContainer.createEl("input", { type: "checkbox" });
        excludedPropsCheckbox.id = "rename-excluded-properties";
        excludedPropsCheckbox.checked = this.plugin.settings.modalCheckboxStates.tagRename.renameExcludedProperties;
        const excludedPropsLabel = excludedPropsContainer.createEl("label");
        excludedPropsLabel.setAttribute("for", "rename-excluded-properties");
        excludedPropsLabel.textContent = t("modals.renameWithExcludedProperties");
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container flit-modal-button-container" });
        const cancelButton = buttonContainer.createEl("button", { text: t("modals.buttons.cancel") });
        cancelButton.onclick = () => this.close();
        const renameButton = buttonContainer.createEl("button", { text: t("modals.buttons.rename") });
        renameButton.addClass("mod-cta");
        renameButton.onclick = async () => {
          this.plugin.settings.modalCheckboxStates.tagRename.includeChildTags = childTagsCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.tagRename.renameExcludedFolders = excludedFoldersCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.tagRename.renameExcludedTags = excludedTagsCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.tagRename.renameExcludedProperties = excludedPropsCheckbox.checked;
          await this.plugin.saveSettings();
          this.close();
          await this.processTagFiles(
            childTagsCheckbox.checked,
            excludedFoldersCheckbox.checked,
            excludedTagsCheckbox.checked,
            excludedPropsCheckbox.checked
          );
        };
      }
      async processTagFiles(includeChildTags, renameExcludedFolders, renameExcludedTags, renameExcludedProperties) {
        var _a;
        const filesToProcess = [];
        const allFiles = this.app.vault.getMarkdownFiles();
        for (const file of allFiles) {
          let hasMatchingTag = false;
          const cache = this.app.metadataCache.getFileCache(file);
          if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.tags) {
            const frontmatterTags = Array.isArray(cache.frontmatter.tags) ? cache.frontmatter.tags : [cache.frontmatter.tags];
            for (const tag of frontmatterTags) {
              const normalizedTag = tag.startsWith("#") ? tag.slice(1) : tag;
              if (normalizedTag === this.tag) {
                hasMatchingTag = true;
                break;
              }
              if (includeChildTags && normalizedTag.startsWith(`${this.tag}/`)) {
                hasMatchingTag = true;
                break;
              }
            }
          }
          if (!hasMatchingTag && (cache == null ? void 0 : cache.tags)) {
            for (const tagCache of cache.tags) {
              const normalizedTag = tagCache.tag.startsWith("#") ? tagCache.tag.slice(1) : tagCache.tag;
              if (normalizedTag === this.tag) {
                hasMatchingTag = true;
                break;
              }
              if (includeChildTags && normalizedTag.startsWith(`${this.tag}/`)) {
                hasMatchingTag = true;
                break;
              }
            }
          }
          if (!hasMatchingTag) {
            continue;
          }
          filesToProcess.push(file);
        }
        if (filesToProcess.length === 0) {
          verboseLog(this.plugin, `No notes found with ${this.tag}`);
          new import_obsidian3.Notice(t("notifications.noNotesFoundWithTag").replace("{{tag}}", this.tag));
          return;
        }
        filesToProcess.sort((a, b) => a.stat.ctime - b.stat.ctime);
        verboseLog(this.plugin, `Renaming ${filesToProcess.length} files with tag ${this.tag}...`);
        const renamingMsg = t("notifications.renamingNNotes").replace("{{count}}", String(filesToProcess.length));
        const pleaseWaitNotice = new import_obsidian3.Notice(renamingMsg, 0);
        let renamedCount = 0;
        const exclusionOverrides = {
          ignoreFolder: renameExcludedFolders,
          ignoreTag: renameExcludedTags,
          ignoreProperty: renameExcludedProperties
        };
        try {
          for (const file of filesToProcess) {
            try {
              await this.plugin.renameEngine.processFile(file, true, true, void 0, true, exclusionOverrides);
              renamedCount++;
            } catch (error) {
              console.error(`Error processing ${file.path}`, error);
            }
          }
        } finally {
          if (this.plugin.cacheManager) {
            this.plugin.cacheManager.clearReservedPaths();
          }
          pleaseWaitNotice.hide();
          verboseLog(this.plugin, `Renamed ${renamedCount}/${filesToProcess.length} files with tag ${this.tag}`);
          const renamedMsg = t("notifications.renamedNotes").replace("{{renamed}}", String(renamedCount)).replace("{{total}}", String(filesToProcess.length));
          new import_obsidian3.Notice(renamedMsg, 0);
        }
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    ClearSettingsModal = class extends import_obsidian3.Modal {
      constructor(app, plugin, onConfirm) {
        super(app);
        this.plugin = plugin;
        this.onConfirm = onConfirm;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        const heading = contentEl.createEl("h2", { text: t("modals.caution"), cls: "flit-modal-heading" });
        contentEl.createEl("p", {
          text: t("modals.resetAllSettings")
        });
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container flit-modal-button-container" });
        const cancelButton = buttonContainer.createEl("button", { text: t("modals.buttons.cancel") });
        cancelButton.onclick = () => this.close();
        const clearButton = buttonContainer.createEl("button", { text: t("settings.miscellaneous.clearSettings.modalButton") });
        clearButton.addClass("mod-warning");
        clearButton.onclick = async () => {
          this.close();
          await this.onConfirm();
        };
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    RenameModal = class extends import_obsidian3.Modal {
      constructor(app, plugin, files) {
        super(app);
        this.plugin = plugin;
        this.files = files;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        const heading = contentEl.createEl("h2", { text: t("modals.caution"), cls: "flit-modal-heading" });
        const count = this.files.length;
        const messagePara = contentEl.createEl("p");
        const parts = tpSplit("modals.processNotesMessage", count);
        messagePara.appendText(parts.before);
        messagePara.createEl("strong", { text: `${count} ${parts.noun}` });
        messagePara.appendText(parts.after);
        messagePara.createEl("br");
        messagePara.createEl("br");
        const backupText = t("modals.ensureFilesBackedUp");
        const backupParts = backupText.split(t("modals.backedUpLinkText"));
        messagePara.appendText(backupParts[0]);
        messagePara.createEl("a", { text: t("modals.backedUpLinkText"), href: "https://help.obsidian.md/backup" });
        if (backupParts[1]) messagePara.appendText(backupParts[1]);
        const optionsContainer = contentEl.createDiv({ cls: "flit-modal-options" });
        const excludedFoldersContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedFoldersCheckbox = excludedFoldersContainer.createEl("input", { type: "checkbox" });
        excludedFoldersCheckbox.id = "rename-excluded-folders";
        excludedFoldersCheckbox.checked = this.plugin.settings.modalCheckboxStates.searchRename.renameExcludedFolders;
        const excludedFoldersLabel = excludedFoldersContainer.createEl("label");
        excludedFoldersLabel.setAttribute("for", "rename-excluded-folders");
        excludedFoldersLabel.textContent = t("modals.renameInExcludedFolders");
        const excludedTagsContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedTagsCheckbox = excludedTagsContainer.createEl("input", { type: "checkbox" });
        excludedTagsCheckbox.id = "rename-excluded-tags";
        excludedTagsCheckbox.checked = this.plugin.settings.modalCheckboxStates.searchRename.renameExcludedTags;
        const excludedTagsLabel = excludedTagsContainer.createEl("label");
        excludedTagsLabel.setAttribute("for", "rename-excluded-tags");
        excludedTagsLabel.textContent = t("modals.renameWithExcludedTags");
        const excludedPropsContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedPropsCheckbox = excludedPropsContainer.createEl("input", { type: "checkbox" });
        excludedPropsCheckbox.id = "rename-excluded-properties";
        excludedPropsCheckbox.checked = this.plugin.settings.modalCheckboxStates.searchRename.renameExcludedProperties;
        const excludedPropsLabel = excludedPropsContainer.createEl("label");
        excludedPropsLabel.setAttribute("for", "rename-excluded-properties");
        excludedPropsLabel.textContent = t("modals.renameWithExcludedProperties");
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container flit-modal-button-container" });
        const cancelButton = buttonContainer.createEl("button", { text: t("modals.buttons.cancel") });
        cancelButton.onclick = () => this.close();
        const renameButton = buttonContainer.createEl("button", { text: t("modals.buttons.rename") });
        renameButton.addClass("mod-cta");
        renameButton.onclick = async () => {
          this.plugin.settings.modalCheckboxStates.searchRename.renameExcludedFolders = excludedFoldersCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.searchRename.renameExcludedTags = excludedTagsCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.searchRename.renameExcludedProperties = excludedPropsCheckbox.checked;
          await this.plugin.saveSettings();
          this.close();
          await this.renameFiles(
            excludedFoldersCheckbox.checked,
            excludedTagsCheckbox.checked,
            excludedPropsCheckbox.checked
          );
        };
      }
      async renameFiles(renameExcludedFolders, renameExcludedTags, renameExcludedProperties) {
        const filesToProcess = [...this.files];
        filesToProcess.sort((a, b) => a.stat.ctime - b.stat.ctime);
        verboseLog(this.plugin, `Renaming ${filesToProcess.length} notes...`);
        const renamingMsg = t("notifications.renamingNNotes").replace("{{count}}", String(filesToProcess.length));
        const pleaseWaitNotice = new import_obsidian3.Notice(renamingMsg, 0);
        const exclusionOverrides = {
          ignoreFolder: renameExcludedFolders,
          ignoreTag: renameExcludedTags,
          ignoreProperty: renameExcludedProperties
        };
        let renamedFileCount = 0;
        try {
          for (const file of filesToProcess) {
            try {
              await this.plugin.renameEngine.processFile(file, true, true, void 0, true, exclusionOverrides);
              renamedFileCount++;
            } catch (error) {
              console.error(`Error processing ${file.path}`, error);
            }
          }
        } finally {
          if (this.plugin.cacheManager) {
            this.plugin.cacheManager.clearReservedPaths();
          }
          pleaseWaitNotice.hide();
          verboseLog(this.plugin, `Renamed ${renamedFileCount}/${filesToProcess.length} notes.`);
          const renamedMsg = t("notifications.renamedNotes").replace("{{renamed}}", String(renamedFileCount)).replace("{{total}}", String(filesToProcess.length));
          new import_obsidian3.Notice(renamedMsg, 0);
        }
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    DisableEnableModal = class extends import_obsidian3.Modal {
      constructor(app, plugin, files, action) {
        super(app);
        this.plugin = plugin;
        this.files = files;
        this.action = action;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        const heading = contentEl.createEl("h2", { text: t("modals.caution"), cls: "flit-modal-heading" });
        const key = this.plugin.settings.disableRenamingKey;
        const value = this.plugin.settings.disableRenamingValue;
        const count = this.files.length;
        const messagePara = contentEl.createEl("p");
        messagePara.appendText(this.action === "disable" ? t("modals.disableEnableAddProperty") : t("modals.disableEnableRemoveProperty"));
        messagePara.createEl("strong", { text: `${key}:${value}` });
        messagePara.appendText(this.action === "disable" ? t("modals.propertyTo") : t("modals.propertyFrom"));
        const nounForm = this.action === "disable" ? getPluralForm(count, t("modals.note"), t("modals.noteFew"), t("modals.notes")) : count === 1 ? t("modals.note") : t("modals.notesPrepositional");
        messagePara.createEl("strong", { text: `${count} ${nounForm}` });
        messagePara.appendText(".");
        messagePara.createEl("br");
        messagePara.createEl("br");
        const backupText = t("modals.ensureFilesBackedUp");
        const backupParts = backupText.split(t("modals.backedUpLinkText"));
        messagePara.appendText(backupParts[0]);
        messagePara.createEl("a", { text: t("modals.backedUpLinkText"), href: "https://help.obsidian.md/backup" });
        if (backupParts[1]) messagePara.appendText(backupParts[1]);
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container flit-modal-button-container" });
        const cancelButton = buttonContainer.createEl("button", { text: t("modals.buttons.cancel") });
        cancelButton.onclick = () => this.close();
        const actionButton = buttonContainer.createEl("button", { text: this.action === "disable" ? t("modals.buttons.disable") : t("modals.buttons.enable") });
        actionButton.addClass("mod-cta");
        actionButton.onclick = async () => {
          this.close();
          await this.processFiles();
        };
      }
      async processFiles() {
        const filesToProcess = [...this.files];
        filesToProcess.sort((a, b) => a.stat.ctime - b.stat.ctime);
        if (this.action === "disable") {
          await this.plugin.propertyManager.ensurePropertyTypeIsCheckbox();
        }
        verboseLog(this.plugin, `Renaming ${filesToProcess.length} notes...`);
        const renamingMsg = t("notifications.renamingNNotes").replace("{{count}}", String(filesToProcess.length));
        const pleaseWaitNotice = new import_obsidian3.Notice(renamingMsg, 0);
        let processedCount = 0;
        const key = this.plugin.settings.disableRenamingKey;
        const value = this.plugin.settings.disableRenamingValue;
        try {
          for (const file of filesToProcess) {
            try {
              await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
                if (this.action === "disable") {
                  frontmatter[key] = value;
                } else {
                  delete frontmatter[key];
                }
              });
              processedCount++;
            } catch (error) {
              console.error(`Error processing ${file.path}`, error);
            }
          }
        } finally {
          pleaseWaitNotice.hide();
          const notificationKey = this.action === "disable" ? "notifications.disabledRenamingForNNotes" : "notifications.enabledRenamingForNNotes";
          const actionPast = this.action === "disable" ? "Disabled" : "Enabled";
          verboseLog(this.plugin, `${actionPast} renaming in ${processedCount} notes.`);
          new import_obsidian3.Notice(t(notificationKey).replace("{{count}}", String(processedCount)));
        }
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    InternalLinkModal = class extends import_obsidian3.Modal {
      constructor(app, plugin, onSubmit, withCaption = false) {
        super(app);
        this.plugin = plugin;
        this.onSubmit = onSubmit;
        this.withCaption = withCaption;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h3", { text: t("modals.internalLink"), cls: "flit-modal-heading-left" });
        const inputContainer = contentEl.createDiv({ cls: "flit-input-container" });
        const textInput = inputContainer.createEl("input", {
          type: "text",
          placeholder: t("modals.enterText"),
          cls: "flit-link-input-full"
        });
        textInput.focus();
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container flit-modal-button-container" });
        const addButton = buttonContainer.createEl("button", { text: t("modals.buttons.add") });
        addButton.addClass("mod-cta");
        const cancelButton = buttonContainer.createEl("button", { text: t("modals.buttons.cancel") });
        cancelButton.onclick = () => this.close();
        const handleSubmit = () => {
          const inputText = textInput.value.trim();
          if (inputText) {
            this.close();
            this.onSubmit(inputText, this.withCaption ? inputText : void 0);
          }
        };
        addButton.onclick = handleSubmit;
        textInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            handleSubmit();
          }
        });
        contentEl.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            e.preventDefault();
            this.close();
          }
        });
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FirstLineIsTitle
});
module.exports = __toCommonJS(main_exports);
var import_obsidian27 = require("obsidian");
init_constants();
init_i18n();
init_utils();
init_modals();

// src/settings/settings-main.ts
var import_obsidian14 = require("obsidian");
init_i18n();

// src/settings/tab-general.ts
var import_obsidian4 = require("obsidian");

// src/settings/settings-base.ts
init_constants();
init_utils();
var SettingsTabBase = class {
  constructor(plugin, containerEl) {
    this.plugin = plugin;
    this.containerEl = containerEl;
  }
  /**
   * Updates the interactive state of all elements within a container
   * @param container - The container element
   * @param enabled - Whether elements should be enabled (true) or disabled (false)
   */
  updateInteractiveState(container, enabled) {
    if (enabled) {
      container.classList.remove("flit-master-disabled");
      container.removeAttribute("inert");
      const interactiveElements = container.querySelectorAll("input, button, a, select, .dropdown, textarea");
      interactiveElements.forEach((el) => {
        if (el.getAttribute("data-original-tabindex") !== null) {
          const originalTabIndex = el.getAttribute("data-original-tabindex");
          if (originalTabIndex === "remove") {
            el.removeAttribute("tabindex");
          } else {
            el.tabIndex = parseInt(originalTabIndex || "0");
          }
          el.removeAttribute("data-original-tabindex");
        }
        el.removeAttribute("aria-disabled");
        el.style.pointerEvents = "";
      });
      this.updateDisabledRowsAccessibility(container);
    } else {
      container.classList.add("flit-master-disabled");
      container.setAttribute("inert", "");
      const interactiveElements = container.querySelectorAll("input, button, a, select, .dropdown, textarea");
      interactiveElements.forEach((el) => {
        if (el.hasAttribute("tabindex")) {
          el.setAttribute("data-original-tabindex", el.getAttribute("tabindex") || "0");
        } else {
          el.setAttribute("data-original-tabindex", "remove");
        }
        el.tabIndex = -1;
        el.setAttribute("aria-disabled", "true");
        el.style.pointerEvents = "none";
      });
    }
  }
  /**
   * Updates accessibility for disabled rows (removes them from tab order)
   * @param container - The container element to search for disabled rows
   */
  updateDisabledRowsAccessibility(container) {
    const disabledRows = container.querySelectorAll(".flit-row-disabled");
    disabledRows.forEach((row) => {
      const interactiveElements = row.querySelectorAll("input, button, a, select, .dropdown, textarea");
      interactiveElements.forEach((el) => {
        if (el.closest(".flit-enable-column") || el.closest(".flit-actions-column")) {
          return;
        }
        el.tabIndex = -1;
        el.setAttribute("aria-disabled", "true");
      });
    });
  }
  addForbiddenCharProtection(inputElement, forceWindowsAndroidProtection = false) {
    inputElement.addEventListener("input", (e) => {
      const inputEl = e.target;
      let value = inputEl.value;
      const universalForbidden = UNIVERSAL_FORBIDDEN_CHARS;
      const windowsAndroidForbidden = WINDOWS_ANDROID_CHARS;
      let forbiddenChars = [...universalForbidden];
      if (forceWindowsAndroidProtection) {
        forbiddenChars.push(...windowsAndroidForbidden);
      } else {
        const currentOS = detectOS();
        if (currentOS === "Windows") {
          forbiddenChars.push(...windowsAndroidForbidden);
        }
      }
      let filteredValue = "";
      for (let i = 0; i < value.length; i++) {
        const char = value[i];
        if (char === "." && i === 0) {
          continue;
        }
        if (forbiddenChars.includes(char)) {
          continue;
        }
        filteredValue += char;
      }
      if (filteredValue !== value) {
        inputEl.value = filteredValue;
        const cursorPos = Math.min(inputEl.selectionStart || 0, filteredValue.length);
        inputEl.setSelectionRange(cursorPos, cursorPos);
        inputEl.dispatchEvent(new Event("input", { bubbles: true }));
      }
    });
  }
};

// src/settings/tab-general.ts
init_modals();
init_i18n();
var GeneralTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
  }
  render() {
    let renameOnFocusContainer;
    let placeCursorSetting;
    let waitForTemplateCursorSetting;
    const updateAutomaticRenameVisibility = () => {
      if (this.plugin.settings.renameNotes === "automatically") {
        renameOnFocusContainer.show();
      } else {
        renameOnFocusContainer.hide();
      }
    };
    const renameNotesSetting = new import_obsidian4.Setting(this.containerEl).setName(t("settings.general.renameNotes.name")).setDesc("");
    const renameNotesDesc = renameNotesSetting.descEl;
    renameNotesDesc.appendText(t("settings.general.renameNotes.desc"));
    renameNotesSetting.addDropdown(
      (dropdown) => dropdown.addOption("automatically", t("settings.general.renameNotes.automatically")).addOption("manually", t("settings.general.renameNotes.manually")).setValue(this.plugin.settings.renameNotes).onChange(async (value) => {
        var _a, _b;
        this.plugin.settings.renameNotes = value;
        this.plugin.debugLog("renameNotes", value);
        await this.plugin.saveSettings();
        updateAutomaticRenameVisibility();
        (_b = (_a = this.plugin).updateAutomaticRenameVisibility) == null ? void 0 : _b.call(_a);
      })
    );
    const automaticRenameContainer = this.containerEl.createDiv("flit-sub-settings");
    const renameOnFocusSetting = new import_obsidian4.Setting(automaticRenameContainer).setName(t("settings.general.renameOnFocus.name")).setDesc(t("settings.general.renameOnFocus.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.renameOnFocus).onChange(async (value) => {
        this.plugin.settings.renameOnFocus = value;
        this.plugin.debugLog("renameOnFocus", value);
        await this.plugin.saveSettings();
      })
    );
    renameOnFocusContainer = automaticRenameContainer;
    updateAutomaticRenameVisibility();
    new import_obsidian4.Setting(this.containerEl).setName(t("settings.general.whatToPutInTitle.name")).setDesc(t("settings.general.whatToPutInTitle.desc")).addDropdown(
      (dropdown) => dropdown.addOption("any_first_line_content", t("settings.general.whatToPutInTitle.anyText")).addOption("headings_only", t("settings.general.whatToPutInTitle.headingsOnly")).setValue(this.plugin.settings.whatToPutInTitle).onChange(async (value) => {
        this.plugin.settings.whatToPutInTitle = value;
        this.plugin.debugLog("whatToPutInTitle", value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(this.containerEl).setName(t("settings.general.moveCursorToFirstLine.name")).setDesc(t("settings.general.moveCursorToFirstLine.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.moveCursorToFirstLine).onChange(async (value) => {
        this.plugin.settings.moveCursorToFirstLine = value;
        this.plugin.debugLog("moveCursorToFirstLine", value);
        await this.plugin.saveSettings();
        updateCursorOptionsVisibility();
      })
    );
    const cursorOptionsContainer = this.containerEl.createDiv("flit-sub-settings");
    placeCursorSetting = new import_obsidian4.Setting(cursorOptionsContainer).setName(t("settings.general.placeCursorAtLineEnd.name")).setDesc(t("settings.general.placeCursorAtLineEnd.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.placeCursorAtLineEnd).onChange(async (value) => {
        this.plugin.settings.placeCursorAtLineEnd = value;
        this.plugin.debugLog("placeCursorAtLineEnd", value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(cursorOptionsContainer).setName(t("settings.general.disableInExcludedFolders.name")).setDesc(t("settings.general.disableInExcludedFolders.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.disableCursorInExcludedFolders).onChange(async (value) => {
        this.plugin.settings.disableCursorInExcludedFolders = value;
        this.plugin.debugLog("disableCursorInExcludedFolders", value);
        await this.plugin.saveSettings();
      })
    );
    waitForTemplateCursorSetting = new import_obsidian4.Setting(cursorOptionsContainer).setName(t("settings.general.waitForTemplate.name")).setDesc(t("settings.general.waitForTemplate.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.waitForCursorTemplate).onChange(async (value) => {
        this.plugin.settings.waitForCursorTemplate = value;
        this.plugin.debugLog("waitForCursorTemplate", value);
        await this.plugin.saveSettings();
      })
    );
    const updateCursorOptionsVisibility = () => {
      if (this.plugin.settings.moveCursorToFirstLine) {
        cursorOptionsContainer.show();
      } else {
        cursorOptionsContainer.hide();
      }
    };
    updateCursorOptionsVisibility();
    let waitForTemplateContainer;
    const updateWaitForTemplateVisibility = () => {
      if (this.plugin.settings.insertTitleOnCreation) {
        waitForTemplateContainer.show();
      } else {
        waitForTemplateContainer.hide();
      }
    };
    const insertTitleSetting = new import_obsidian4.Setting(this.containerEl).setName(t("settings.general.insertTitleOnCreation.name")).setDesc("");
    const insertTitleDesc = insertTitleSetting.descEl;
    insertTitleDesc.appendText(t("settings.general.insertTitleOnCreation.desc.part1"));
    if (getCurrentLocale() === "ru") {
      insertTitleDesc.appendText("\xAB" + t("settings.general.insertTitleOnCreation.desc.untitled") + "\xBB");
    } else {
      insertTitleDesc.createEl("em", { text: t("settings.general.insertTitleOnCreation.desc.untitled") });
    }
    insertTitleDesc.appendText(t("settings.general.insertTitleOnCreation.desc.part2"));
    if (getCurrentLocale() === "ru") {
      insertTitleDesc.appendText("\xAB" + t("settings.general.insertTitleOnCreation.desc.replaceCharacters") + "\xBB");
    } else {
      insertTitleDesc.createEl("em", { text: t("settings.general.insertTitleOnCreation.desc.replaceCharacters") });
    }
    insertTitleDesc.appendText(t("settings.general.insertTitleOnCreation.desc.part3"));
    insertTitleSetting.addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.insertTitleOnCreation).onChange(async (value) => {
        this.plugin.settings.insertTitleOnCreation = value;
        this.plugin.debugLog("insertTitleOnCreation", value);
        await this.plugin.saveSettings();
        updateWaitForTemplateVisibility();
      })
    );
    waitForTemplateContainer = this.containerEl.createDiv("flit-sub-settings");
    const waitForTemplateSetting = new import_obsidian4.Setting(waitForTemplateContainer).setName(t("settings.general.insertAfterTemplate.name")).setDesc(t("settings.general.insertAfterTemplate.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.waitForTemplate).onChange(async (value) => {
        this.plugin.settings.waitForTemplate = value;
        this.plugin.debugLog("waitForTemplate", value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(waitForTemplateContainer).setName(t("settings.general.formatAsHeading.name")).setDesc(t("settings.general.formatAsHeading.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.addHeadingToTitle).onChange(async (value) => {
        this.plugin.settings.addHeadingToTitle = value;
        this.plugin.debugLog("addHeadingToTitle", value);
        await this.plugin.saveSettings();
      })
    );
    updateWaitForTemplateVisibility();
    new import_obsidian4.Setting(this.containerEl).setName(t("settings.general.renameOnSave.name")).setDesc(t("settings.general.renameOnSave.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.renameOnSave).onChange(async (value) => {
        this.plugin.settings.renameOnSave = value;
        this.plugin.debugLog("renameOnSave", value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(this.containerEl).setName(t("settings.general.renameAllNotes.name")).setDesc(t("settings.general.renameAllNotes.desc")).addButton(
      (button2) => button2.setButtonText(t("settings.general.renameAllNotes.button")).onClick(() => {
        new RenameAllFilesModal(this.plugin.app, this.plugin).open();
      })
    );
    const feedbackContainer = this.containerEl.createEl("div");
    feedbackContainer.style.cssText = `
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            margin: 20px 0;
            padding: 4px 0;
            overflow: visible;
        `;
    const button = feedbackContainer.createEl("button", {
      cls: "mod-cta flit-leave-feedback-button"
    });
    button.style.display = "flex";
    button.style.alignItems = "center";
    button.style.gap = "8px";
    button.addEventListener("click", () => {
      window.open("https://github.com/greetclammy/first-line-is-title/issues", "_blank");
    });
    const iconDiv = button.createEl("div");
    (0, import_obsidian4.setIcon)(iconDiv, "message-square-reply");
    button.appendText(t("settings.general.leaveFeedback"));
  }
};

// src/settings/tab-exclusions.ts
var import_obsidian6 = require("obsidian");

// src/suggests.ts
var import_obsidian5 = require("obsidian");
var FolderSuggest = class extends import_obsidian5.AbstractInputSuggest {
  constructor(app, inputEl, onSelectCallback) {
    super(app, inputEl);
    this.inputEl = inputEl;
    this.onSelectCallback = onSelectCallback;
  }
  getSuggestions(query) {
    const folders = this.app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian5.TFolder);
    if (!query) {
      return folders.slice(0, 10);
    }
    const lowerQuery = query.toLowerCase();
    return folders.filter(
      (folder) => folder.path.toLowerCase().includes(lowerQuery)
    ).slice(0, 10);
  }
  renderSuggestion(folder, el) {
    el.setText(folder.path);
  }
  selectSuggestion(folder, evt) {
    this.onSelectCallback(folder.path);
    this.inputEl.value = folder.path;
    this.inputEl.trigger("input");
    this.close();
  }
};
var TagSuggest = class extends import_obsidian5.AbstractInputSuggest {
  constructor(app, inputEl, onSelectCallback) {
    super(app, inputEl);
    this.inputEl = inputEl;
    this.onSelectCallback = onSelectCallback;
  }
  getSuggestions(query) {
    const allTags = Object.keys(this.app.metadataCache.getTags());
    if (!query) {
      return allTags.slice(0, 10);
    }
    const lowerQuery = query.toLowerCase();
    return allTags.filter(
      (tag) => tag.toLowerCase().includes(lowerQuery)
    ).slice(0, 10);
  }
  renderSuggestion(tag, el) {
    el.setText(tag);
  }
  selectSuggestion(tag, evt) {
    this.onSelectCallback(tag);
    this.inputEl.value = tag;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/settings/tab-exclusions.ts
init_constants();
init_i18n();
var IncludeExcludeTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
  }
  async render() {
    const tabDesc = this.containerEl.createEl("div", { cls: "setting-item-description" });
    tabDesc.createEl("strong", { text: t("settings.exclusions.desc") });
    tabDesc.style.marginBottom = "15px";
    const importantNote = this.containerEl.createEl("p", { cls: "setting-item-description" });
    importantNote.appendText(t("settings.exclusions.note"));
    importantNote.style.marginBottom = "15px";
    await this.checkFirstTimeExclusionsSetup();
    const foldersHeaderSetting = new import_obsidian6.Setting(this.containerEl).setName(t("settings.exclusions.folders.title")).setDesc(t("settings.exclusions.folders.desc"));
    foldersHeaderSetting.settingEl.addClass("flit-master-toggle");
    const folderNote = this.containerEl.createEl("p", { cls: "setting-item-description" });
    folderNote.style.marginTop = "15px";
    folderNote.style.marginBottom = "15px";
    folderNote.textContent = t("settings.exclusions.folders.renamedWarning");
    const subfolderSetting = new import_obsidian6.Setting(this.containerEl).setName(t("settings.exclusions.folders.matchSubfolders.name")).setDesc(t("settings.exclusions.folders.matchSubfolders.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.excludeSubfolders).onChange(async (value) => {
        this.plugin.settings.excludeSubfolders = value;
        this.plugin.debugLog("excludeSubfolders", value);
        await this.plugin.saveSettings();
      })
    );
    subfolderSetting.settingEl.style.borderTop = "none";
    const folderModeSetting = new import_obsidian6.Setting(this.containerEl).setName(t("settings.exclusions.folders.exclusionMode.name")).setDesc(t("settings.exclusions.folders.exclusionMode.desc")).addDropdown(
      (dropdown) => dropdown.addOption("Only exclude...", t("settings.exclusions.folders.exclusionMode.onlyExclude")).addOption("Exclude all except...", t("settings.exclusions.folders.exclusionMode.excludeAllExcept")).setValue(this.plugin.settings.folderScopeStrategy).onChange(async (value) => {
        this.plugin.settings.folderScopeStrategy = value;
        this.plugin.debugLog("folderScopeStrategy", value);
        await this.plugin.saveSettings();
      })
    );
    const folderContainer = this.containerEl.createDiv();
    const renderExcludedFolders = () => {
      folderContainer.empty();
      let addButton;
      this.plugin.settings.excludedFolders.forEach((folder, index) => {
        const folderSetting = new import_obsidian6.Setting(folderContainer);
        let textInput;
        let removeButton;
        const updateButtonState = () => {
          const isLastEmptyEntry = this.plugin.settings.excludedFolders.length === 1 && this.plugin.settings.excludedFolders[0].trim() === "";
          if (isLastEmptyEntry) {
            removeButton.setDisabled(true);
            removeButton.extraSettingsEl.style.opacity = "0.5";
            removeButton.extraSettingsEl.style.pointerEvents = "none";
            removeButton.extraSettingsEl.removeAttribute("aria-label");
            removeButton.extraSettingsEl.title = "";
          } else {
            removeButton.setDisabled(false);
            removeButton.extraSettingsEl.style.opacity = "1";
            removeButton.extraSettingsEl.style.pointerEvents = "auto";
            removeButton.setTooltip("Remove");
          }
        };
        folderSetting.addText((text) => {
          textInput = text;
          text.setPlaceholder(t("settings.exclusions.folders.placeholder")).setValue(folder).onChange(async (value) => {
            this.plugin.settings.excludedFolders[index] = value;
            this.plugin.debugLog("excludedFolders", this.plugin.settings.excludedFolders);
            await this.plugin.saveSettings();
            updateButtonState();
          });
          text.inputEl.style.width = "100%";
          try {
            new FolderSuggest(this.plugin.app, text.inputEl, async (selectedPath) => {
              this.plugin.settings.excludedFolders[index] = selectedPath;
              this.plugin.debugLog("excludedFolders", this.plugin.settings.excludedFolders);
              await this.plugin.saveSettings();
              updateButtonState();
            });
          } catch (error) {
            console.error("Failed to create FolderSuggest:", error);
          }
        }).addExtraButton((button) => {
          removeButton = button;
          button.setIcon("x");
          button.onClick(async () => {
            const isLastEmptyEntry = this.plugin.settings.excludedFolders.length === 1 && this.plugin.settings.excludedFolders[0].trim() === "";
            if (!isLastEmptyEntry) {
              this.plugin.settings.excludedFolders.splice(index, 1);
              if (this.plugin.settings.excludedFolders.length === 0) {
                this.plugin.settings.excludedFolders.push("");
              }
              await this.plugin.saveSettings();
              renderExcludedFolders();
            }
          });
          updateButtonState();
        });
        folderSetting.settingEl.addClass("flit-excluded-folder-setting");
      });
      const addButtonSetting = new import_obsidian6.Setting(folderContainer).addButton((button) => {
        button.setButtonText(t("settings.exclusions.folders.addButton")).onClick(async () => {
          const isBottomEntryEmpty = this.plugin.settings.excludedFolders.length > 0 && this.plugin.settings.excludedFolders[this.plugin.settings.excludedFolders.length - 1].trim() === "";
          if (isBottomEntryEmpty) {
            const textInputs = folderContainer.querySelectorAll('input[type="text"]');
            if (textInputs.length > 0) {
              const lastInput = textInputs[textInputs.length - 1];
              lastInput.focus();
            }
          } else {
            this.plugin.settings.excludedFolders.push("");
            await this.plugin.saveSettings();
            renderExcludedFolders();
            setTimeout(() => {
              const textInputs = folderContainer.querySelectorAll('input[type="text"]');
              if (textInputs.length > 0) {
                const lastInput = textInputs[textInputs.length - 1];
                lastInput.focus();
              }
            }, 0);
          }
        });
      });
      addButtonSetting.settingEl.addClass("flit-add-folder-button");
    };
    renderExcludedFolders();
    const tagsHeaderSetting = new import_obsidian6.Setting(this.containerEl).setName(t("settings.exclusions.tags.title")).setDesc(t("settings.exclusions.tags.desc"));
    tagsHeaderSetting.settingEl.addClass("flit-master-toggle");
    const tagNotes = this.containerEl.createEl("div", { cls: "setting-item-description" });
    tagNotes.style.marginTop = "15px";
    tagNotes.style.marginBottom = "15px";
    const tagUl = tagNotes.createEl("ul");
    tagUl.style.margin = "0";
    tagUl.style.paddingLeft = "20px";
    const tagLi1 = tagUl.createEl("li");
    tagLi1.appendText(t("settings.exclusions.tags.excludeAllNote.part1"));
    if (getCurrentLocale() === "ru") {
      tagLi1.appendText("\xAB" + t("settings.exclusions.tags.excludeAllNote.excludeAllExcept") + "\xBB");
    } else {
      tagLi1.createEl("em", { text: t("settings.exclusions.tags.excludeAllNote.excludeAllExcept") });
    }
    tagLi1.appendText(t("settings.exclusions.tags.excludeAllNote.part2"));
    const tagLi2 = tagUl.createEl("li");
    const tagWranglerText = t("settings.exclusions.tags.tagWranglerWarning");
    const parts = tagWranglerText.split("Tag Wrangler");
    tagLi2.appendText(parts[0]);
    tagLi2.createEl("a", {
      text: "Tag Wrangler",
      href: "obsidian://show-plugin?id=tag-wrangler"
    });
    tagLi2.appendText(parts[1] || "");
    const tagMatchingSetting = new import_obsidian6.Setting(this.containerEl).setName(t("settings.exclusions.tags.matchTags.name")).setDesc(t("settings.exclusions.tags.matchTags.desc")).addDropdown(
      (dropdown) => dropdown.addOption("In Properties and note body", t("settings.exclusions.tags.matchTags.inPropertiesAndBody")).addOption("In Properties only", t("settings.exclusions.tags.matchTags.inPropertiesOnly")).addOption("In note body only", t("settings.exclusions.tags.matchTags.inBodyOnly")).setValue(this.plugin.settings.tagMatchingMode).onChange(async (value) => {
        this.plugin.settings.tagMatchingMode = value;
        this.plugin.debugLog("tagMatchingMode", value);
        await this.plugin.saveSettings();
      })
    );
    tagMatchingSetting.settingEl.style.borderTop = "none";
    const childTagsSetting = new import_obsidian6.Setting(this.containerEl).setName(t("settings.exclusions.tags.matchChildTags.name")).setDesc(t("settings.exclusions.tags.matchChildTags.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.excludeChildTags).onChange(async (value) => {
        this.plugin.settings.excludeChildTags = value;
        this.plugin.debugLog("excludeChildTags", value);
        await this.plugin.saveSettings();
      })
    );
    const tagModeSetting = new import_obsidian6.Setting(this.containerEl).setName(t("settings.exclusions.tags.exclusionMode.name")).setDesc(t("settings.exclusions.tags.exclusionMode.desc")).addDropdown(
      (dropdown) => dropdown.addOption("Only exclude...", t("settings.exclusions.folders.exclusionMode.onlyExclude")).addOption("Exclude all except...", t("settings.exclusions.folders.exclusionMode.excludeAllExcept")).setValue(this.plugin.settings.tagScopeStrategy).onChange(async (value) => {
        this.plugin.settings.tagScopeStrategy = value;
        this.plugin.debugLog("tagScopeStrategy", value);
        await this.plugin.saveSettings();
      })
    );
    const tagContainer = this.containerEl.createDiv();
    const renderExcludedTags = () => {
      tagContainer.empty();
      let addTagButton;
      this.plugin.settings.excludedTags.forEach((tag, index) => {
        const tagSetting = new import_obsidian6.Setting(tagContainer);
        let textInput;
        let removeButton;
        const updateButtonState = () => {
          const isLastEmptyEntry = this.plugin.settings.excludedTags.length === 1 && this.plugin.settings.excludedTags[0].trim() === "";
          if (isLastEmptyEntry) {
            removeButton.setDisabled(true);
            removeButton.extraSettingsEl.style.opacity = "0.5";
            removeButton.extraSettingsEl.style.pointerEvents = "none";
            removeButton.extraSettingsEl.removeAttribute("aria-label");
            removeButton.extraSettingsEl.title = "";
          } else {
            removeButton.setDisabled(false);
            removeButton.extraSettingsEl.style.opacity = "1";
            removeButton.extraSettingsEl.style.pointerEvents = "auto";
            removeButton.setTooltip("Remove");
          }
        };
        tagSetting.addText((text) => {
          textInput = text;
          text.setPlaceholder(t("settings.exclusions.tags.placeholder")).setValue(tag).onChange(async (value) => {
            this.plugin.settings.excludedTags[index] = value;
            this.plugin.debugLog("excludedTags", this.plugin.settings.excludedTags);
            await this.plugin.saveSettings();
            updateButtonState();
          });
          text.inputEl.style.width = "100%";
          try {
            new TagSuggest(this.plugin.app, text.inputEl, async (selectedTag) => {
              this.plugin.settings.excludedTags[index] = selectedTag;
              this.plugin.debugLog("excludedTags", this.plugin.settings.excludedTags);
              await this.plugin.saveSettings();
              updateButtonState();
            });
          } catch (error) {
            console.error("Failed to create TagSuggest:", error);
          }
        }).addExtraButton((button) => {
          removeButton = button;
          button.setIcon("x");
          button.onClick(async () => {
            const isLastEmptyEntry = this.plugin.settings.excludedTags.length === 1 && this.plugin.settings.excludedTags[0].trim() === "";
            if (!isLastEmptyEntry) {
              this.plugin.settings.excludedTags.splice(index, 1);
              if (this.plugin.settings.excludedTags.length === 0) {
                this.plugin.settings.excludedTags.push("");
              }
              await this.plugin.saveSettings();
              renderExcludedTags();
            }
          });
          updateButtonState();
        });
        tagSetting.settingEl.addClass("flit-excluded-folder-setting");
      });
      const addTagButtonSetting = new import_obsidian6.Setting(tagContainer).addButton((button) => {
        button.setButtonText(t("settings.exclusions.tags.addButton")).onClick(async () => {
          const isBottomEntryEmpty = this.plugin.settings.excludedTags.length > 0 && this.plugin.settings.excludedTags[this.plugin.settings.excludedTags.length - 1].trim() === "";
          if (isBottomEntryEmpty) {
            const textInputs = tagContainer.querySelectorAll('input[type="text"]');
            if (textInputs.length > 0) {
              const lastInput = textInputs[textInputs.length - 1];
              lastInput.focus();
            }
          } else {
            this.plugin.settings.excludedTags.push("");
            await this.plugin.saveSettings();
            renderExcludedTags();
            setTimeout(() => {
              const textInputs = tagContainer.querySelectorAll('input[type="text"]');
              if (textInputs.length > 0) {
                const lastInput = textInputs[textInputs.length - 1];
                lastInput.focus();
              }
            }, 0);
          }
        });
      });
      addTagButtonSetting.settingEl.addClass("flit-add-folder-button");
    };
    renderExcludedTags();
    const propertiesHeaderSetting = new import_obsidian6.Setting(this.containerEl).setName(t("settings.exclusions.properties.title")).setDesc(t("settings.exclusions.properties.desc"));
    propertiesHeaderSetting.settingEl.addClass("flit-master-toggle");
    const propertyNotes = this.containerEl.createEl("div", { cls: "setting-item-description" });
    propertyNotes.style.marginTop = "15px";
    propertyNotes.style.marginBottom = "15px";
    const ul = propertyNotes.createEl("ul");
    ul.style.margin = "0";
    ul.style.paddingLeft = "20px";
    const propLi1 = ul.createEl("li");
    propLi1.appendText(t("settings.exclusions.properties.leaveBlank.part1"));
    if (getCurrentLocale() === "ru") {
      propLi1.appendText("\xAB" + t("settings.exclusions.properties.leaveBlank.value") + "\xBB");
    } else {
      propLi1.createEl("em", { text: t("settings.exclusions.properties.leaveBlank.value") });
    }
    propLi1.appendText(t("settings.exclusions.properties.leaveBlank.part2"));
    ul.createEl("li", { text: t("settings.exclusions.properties.caseInsensitive") });
    const propLi3 = ul.createEl("li");
    propLi3.appendText(t("settings.exclusions.properties.excludeAllNote.part1"));
    if (getCurrentLocale() === "ru") {
      propLi3.appendText("\xAB" + t("settings.exclusions.properties.excludeAllNote.excludeAllExcept") + "\xBB");
    } else {
      propLi3.createEl("em", { text: t("settings.exclusions.properties.excludeAllNote.excludeAllExcept") });
    }
    propLi3.appendText(t("settings.exclusions.properties.excludeAllNote.part2"));
    ul.createEl("li", { text: t("settings.exclusions.properties.renamedWarning") });
    const propertyModeSetting = new import_obsidian6.Setting(this.containerEl).setName(t("settings.exclusions.properties.exclusionMode.name")).setDesc(t("settings.exclusions.properties.exclusionMode.desc")).addDropdown(
      (dropdown) => dropdown.addOption("Only exclude...", t("settings.exclusions.folders.exclusionMode.onlyExclude")).addOption("Exclude all except...", t("settings.exclusions.folders.exclusionMode.excludeAllExcept")).setValue(this.plugin.settings.propertyScopeStrategy).onChange(async (value) => {
        this.plugin.settings.propertyScopeStrategy = value;
        this.plugin.debugLog("propertyScopeStrategy", value);
        await this.plugin.saveSettings();
      })
    );
    propertyModeSetting.settingEl.style.borderTop = "none";
    const propertyContainer = this.containerEl.createDiv();
    const renderExcludedProperties = () => {
      propertyContainer.empty();
      if (this.plugin.settings.excludedProperties.length === 0) {
        this.plugin.settings.excludedProperties.push({ key: "", value: "" });
      }
      let addPropertyButton;
      this.plugin.settings.excludedProperties.forEach((property, index) => {
        const propertySetting = new import_obsidian6.Setting(propertyContainer);
        let keyInput2;
        let valueInput2;
        let removeButton;
        const updateButtonState = () => {
          const isLastEmptyEntry = this.plugin.settings.excludedProperties.length === 1 && this.plugin.settings.excludedProperties[0].key.trim() === "" && this.plugin.settings.excludedProperties[0].value.trim() === "";
          if (isLastEmptyEntry) {
            removeButton.setDisabled(true);
            removeButton.extraSettingsEl.style.opacity = "0.5";
            removeButton.extraSettingsEl.style.pointerEvents = "none";
            removeButton.extraSettingsEl.removeAttribute("aria-label");
            removeButton.extraSettingsEl.title = "";
          } else {
            removeButton.setDisabled(false);
            removeButton.extraSettingsEl.style.opacity = "1";
            removeButton.extraSettingsEl.style.pointerEvents = "auto";
            removeButton.setTooltip("Remove");
          }
        };
        const propertyInputContainer2 = propertySetting.controlEl.createDiv({ cls: "flit-property-container" });
        propertyInputContainer2.style.display = "flex";
        propertyInputContainer2.style.gap = "10px";
        propertyInputContainer2.style.alignItems = "center";
        keyInput2 = propertyInputContainer2.createEl("input", { type: "text", cls: "flit-property-key-input" });
        keyInput2.placeholder = t("settings.exclusions.properties.keyPlaceholder");
        keyInput2.value = property.key;
        const colonSpan2 = propertyInputContainer2.createEl("span", { text: t("settings.exclusions.properties.separator"), cls: "flit-colon-separator" });
        valueInput2 = propertyInputContainer2.createEl("input", { type: "text", cls: "flit-property-value-input" });
        valueInput2.placeholder = t("settings.exclusions.properties.valuePlaceholder");
        valueInput2.value = property.value;
        keyInput2.addEventListener("input", async (e) => {
          this.plugin.settings.excludedProperties[index].key = e.target.value;
          this.plugin.debugLog("excludedProperties", this.plugin.settings.excludedProperties);
          await this.plugin.saveSettings();
          updateButtonState();
        });
        valueInput2.addEventListener("input", async (e) => {
          this.plugin.settings.excludedProperties[index].value = e.target.value;
          this.plugin.debugLog("excludedProperties", this.plugin.settings.excludedProperties);
          await this.plugin.saveSettings();
          updateButtonState();
        });
        propertySetting.addExtraButton((button) => {
          removeButton = button;
          button.setIcon("x");
          button.onClick(async () => {
            if (this.plugin.settings.excludedProperties.length === 1) {
              this.plugin.settings.excludedProperties[0] = { key: "", value: "" };
            } else {
              this.plugin.settings.excludedProperties.splice(index, 1);
            }
            await this.plugin.saveSettings();
            renderExcludedProperties();
          });
          updateButtonState();
        });
        propertySetting.settingEl.addClass("flit-excluded-folder-setting");
      });
      const addPropertyButtonSetting = new import_obsidian6.Setting(propertyContainer).addButton((button) => {
        button.setButtonText(t("settings.exclusions.properties.addButton")).onClick(async () => {
          const lastProperty = this.plugin.settings.excludedProperties[this.plugin.settings.excludedProperties.length - 1];
          const isBottomEntryEmpty = this.plugin.settings.excludedProperties.length > 0 && lastProperty.key.trim() === "" && lastProperty.value.trim() === "";
          if (isBottomEntryEmpty) {
            const keyInputs = propertyContainer.querySelectorAll(".flit-property-key-input");
            if (keyInputs.length > 0) {
              const lastInput = keyInputs[keyInputs.length - 1];
              lastInput.focus();
            }
          } else {
            this.plugin.settings.excludedProperties.push({ key: "", value: "" });
            await this.plugin.saveSettings();
            renderExcludedProperties();
            setTimeout(() => {
              const keyInputs = propertyContainer.querySelectorAll(".flit-property-key-input");
              if (keyInputs.length > 0) {
                const lastInput = keyInputs[keyInputs.length - 1];
                lastInput.focus();
              }
            }, 0);
          }
        });
      });
      addPropertyButtonSetting.settingEl.addClass("flit-add-folder-button");
    };
    renderExcludedProperties();
    const propertyDisableSetting = new import_obsidian6.Setting(this.containerEl).setName(t("settings.exclusions.disableProperty.title")).setDesc("");
    propertyDisableSetting.settingEl.addClass("flit-master-toggle");
    const propertyDesc = propertyDisableSetting.descEl;
    propertyDesc.appendText(t("settings.exclusions.disableProperty.desc"));
    const propertyDisableNotes = this.containerEl.createEl("div", { cls: "setting-item-description" });
    propertyDisableNotes.style.marginTop = "15px";
    propertyDisableNotes.style.marginBottom = "15px";
    const disableUl = propertyDisableNotes.createEl("ul");
    disableUl.style.margin = "0";
    disableUl.style.paddingLeft = "20px";
    disableUl.createEl("li", { text: t("settings.exclusions.disableProperty.alwaysRespected") });
    disableUl.createEl("li", { text: t("settings.exclusions.disableProperty.caseInsensitive") });
    disableUl.createEl("li", { text: t("settings.exclusions.disableProperty.updateWarning") });
    const propertyInputSetting = new import_obsidian6.Setting(this.containerEl);
    propertyInputSetting.settingEl.addClass("flit-excluded-folder-setting");
    propertyInputSetting.settingEl.style.borderTop = "none";
    const propertyControlWrapper = propertyInputSetting.controlEl.createDiv({
      cls: "flit-property-control-wrapper"
    });
    propertyControlWrapper.style.display = "flex";
    propertyControlWrapper.style.alignItems = "center";
    propertyControlWrapper.style.gap = "8px";
    propertyControlWrapper.style.width = "100%";
    const propertyRestoreButtonContainer = propertyControlWrapper.createDiv({
      cls: "flit-restore-button-container"
    });
    const propertyRestoreButton = propertyRestoreButtonContainer.createEl("button", {
      cls: "clickable-icon flit-restore-icon",
      attr: { "aria-label": t("settings.replaceCharacters.restoreDefault") }
    });
    (0, import_obsidian6.setIcon)(propertyRestoreButton, "rotate-ccw");
    const propertyInputContainer = propertyControlWrapper.createDiv({ cls: "flit-property-container" });
    propertyInputContainer.style.display = "flex";
    propertyInputContainer.style.gap = "10px";
    propertyInputContainer.style.alignItems = "center";
    const keyInput = propertyInputContainer.createEl("input", { type: "text", cls: "flit-property-key-input" });
    keyInput.placeholder = t("settings.exclusions.properties.keyPlaceholder");
    keyInput.value = this.plugin.settings.disableRenamingKey;
    const colonSpan = propertyInputContainer.createEl("span", { text: t("settings.exclusions.properties.separator"), cls: "flit-colon-separator" });
    const valueInput = propertyInputContainer.createEl("input", { type: "text", cls: "flit-property-value-input" });
    valueInput.placeholder = t("settings.exclusions.properties.valuePlaceholder");
    valueInput.value = this.plugin.settings.disableRenamingValue;
    keyInput.addEventListener("input", async (e) => {
      this.plugin.settings.disableRenamingKey = e.target.value;
      await this.plugin.saveSettings();
    });
    valueInput.addEventListener("input", async (e) => {
      this.plugin.settings.disableRenamingValue = e.target.value;
      await this.plugin.saveSettings();
    });
    propertyRestoreButton.addEventListener("click", async () => {
      this.plugin.settings.disableRenamingKey = DEFAULT_SETTINGS.disableRenamingKey;
      this.plugin.settings.disableRenamingValue = DEFAULT_SETTINGS.disableRenamingValue;
      keyInput.value = this.plugin.settings.disableRenamingKey;
      valueInput.value = this.plugin.settings.disableRenamingValue;
      await this.plugin.saveSettings();
    });
    const defaultTextContainer = this.containerEl.createEl("div", { cls: "setting-item-description" });
    defaultTextContainer.createEl("small").createEl("strong", { text: t("settings.exclusions.disableProperty.default") });
    defaultTextContainer.style.marginTop = "5px";
    defaultTextContainer.style.marginBottom = "20px";
    propertyDisableSetting.settingEl.style.marginBottom = "20px";
  }
  async checkFirstTimeExclusionsSetup() {
    if (this.plugin.settings.hasSetupExclusions) {
      return;
    }
    const excalidrawPlugin = this.plugin.app.plugins.getPlugin("obsidian-excalidraw-plugin");
    if (excalidrawPlugin && excalidrawPlugin._loaded) {
      const hasExcalidrawProperty = this.plugin.settings.excludedProperties.some(
        (prop) => prop.key === "excalidraw-plugin" && prop.value === "parsed"
      );
      if (!hasExcalidrawProperty) {
        this.plugin.settings.excludedProperties.push({
          key: "excalidraw-plugin",
          value: "parsed"
        });
        await this.plugin.saveSettings();
      }
    }
    if (this.plugin.settings.verboseLogging) console.debug("Checking for template plugin folders to auto-exclude");
    const adapter = this.plugin.app.vault.adapter;
    const configDir = this.plugin.app.vault.configDir;
    if (this.plugin.settings.verboseLogging) console.debug("Vault config directory is:", configDir);
    let templatesFolder = null;
    let templaterFolder = null;
    try {
      const corePluginsPath = `${configDir}/core-plugins.json`;
      if (this.plugin.settings.verboseLogging) console.debug("Reading core plugins configuration from:", corePluginsPath);
      const corePluginsData = await adapter.read(corePluginsPath);
      const corePlugins = JSON.parse(corePluginsData);
      if (this.plugin.settings.verboseLogging) console.debug("Core Templates plugin enabled status:", corePlugins.templates);
      if (corePlugins.templates === true) {
        if (this.plugin.settings.verboseLogging) console.debug("Core Templates plugin is enabled, checking for templates folder");
        const templatesDataPath = `${configDir}/templates.json`;
        if (this.plugin.settings.verboseLogging) console.debug("Reading templates configuration from:", templatesDataPath);
        const templatesData = await adapter.read(templatesDataPath);
        const templatesConfig = JSON.parse(templatesData);
        templatesFolder = templatesConfig.folder;
        if (this.plugin.settings.verboseLogging) console.debug("Core Templates folder configured as:", templatesFolder);
      } else {
        if (this.plugin.settings.verboseLogging) console.debug("Core Templates plugin is disabled, skipping");
      }
    } catch (error) {
      if (this.plugin.settings.verboseLogging) console.debug("Could not read core Templates plugin configuration:", error);
    }
    if (this.plugin.settings.verboseLogging) console.debug("Checking for Templater community plugin");
    const templaterPlugin = this.plugin.app.plugins.getPlugin("templater-obsidian");
    if (this.plugin.settings.verboseLogging) console.debug("Templater plugin found:", !!templaterPlugin, "| loaded:", templaterPlugin == null ? void 0 : templaterPlugin._loaded);
    if (templaterPlugin && templaterPlugin._loaded) {
      try {
        const templaterDataPath = `${configDir}/plugins/templater-obsidian/data.json`;
        if (this.plugin.settings.verboseLogging) console.debug("Reading Templater configuration from:", templaterDataPath);
        const templaterData = await adapter.read(templaterDataPath);
        const templaterConfig = JSON.parse(templaterData);
        templaterFolder = templaterConfig.templates_folder;
        if (this.plugin.settings.verboseLogging) console.debug("Templater folder configured as:", templaterFolder);
      } catch (error) {
        if (this.plugin.settings.verboseLogging) console.debug("Could not read Templater plugin configuration:", error);
      }
    } else {
      if (this.plugin.settings.verboseLogging) console.debug("Templater plugin not loaded, skipping");
    }
    const foldersToAdd = [];
    if (templatesFolder && templatesFolder.trim() !== "") {
      foldersToAdd.push(templatesFolder);
      if (this.plugin.settings.verboseLogging) console.debug("Queued core Templates folder for exclusion:", templatesFolder);
    } else {
      if (this.plugin.settings.verboseLogging) console.debug("No valid core Templates folder to add");
    }
    if (templaterFolder && templaterFolder.trim() !== "") {
      if (templaterFolder !== templatesFolder) {
        foldersToAdd.push(templaterFolder);
        if (this.plugin.settings.verboseLogging) console.debug("Queued Templater folder for exclusion:", templaterFolder);
      } else {
        if (this.plugin.settings.verboseLogging) console.debug("Templater folder matches core Templates folder (" + templaterFolder + "), will not add duplicate");
      }
    } else {
      if (this.plugin.settings.verboseLogging) console.debug("No valid Templater folder to add");
    }
    if (this.plugin.settings.verboseLogging) console.debug("Total folders to add to exclusions:", foldersToAdd);
    if (this.plugin.settings.verboseLogging) console.debug("Current excluded folders before processing:", this.plugin.settings.excludedFolders);
    for (const folder of foldersToAdd) {
      const hasFolderExcluded = this.plugin.settings.excludedFolders.some(
        (existingFolder) => existingFolder === folder
      );
      if (!hasFolderExcluded) {
        if (this.plugin.settings.excludedFolders.length === 1 && this.plugin.settings.excludedFolders[0].trim() === "") {
          this.plugin.settings.excludedFolders = [];
          if (this.plugin.settings.verboseLogging) console.debug("Removed default empty string entry from excluded folders");
        }
        this.plugin.settings.excludedFolders.push(folder);
        if (this.plugin.settings.verboseLogging) console.debug("Successfully added folder to exclusions:", folder);
      } else {
        if (this.plugin.settings.verboseLogging) console.debug("Folder already in exclusions list, skipping:", folder);
      }
    }
    if (foldersToAdd.length > 0) {
      await this.plugin.saveSettings();
      if (this.plugin.settings.verboseLogging) console.debug("Saved settings after adding template folders to exclusions");
    } else {
      if (this.plugin.settings.verboseLogging) console.debug("No folders were added, skipping settings save");
    }
    if (this.plugin.settings.verboseLogging) console.debug("Final excluded folders after processing:", this.plugin.settings.excludedFolders);
    this.plugin.settings.hasSetupExclusions = true;
    await this.plugin.saveSettings();
  }
};

// src/settings/tab-alias.ts
var import_obsidian7 = require("obsidian");
init_constants();
init_i18n();
var PropertiesTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
  }
  render() {
    const updateAliasConditionalSettings = async () => {
      const customRulesEnabled = this.plugin.settings.enableCustomReplacements;
      applyCustomRulesInAliasSetting.components[0].setDisabled(!customRulesEnabled);
      if (customRulesEnabled) {
        applyCustomRulesInAliasSetting.settingEl.classList.remove("flit-row-disabled");
        applyCustomRulesToggle.toggleEl.tabIndex = 0;
        applyCustomRulesToggle.toggleEl.removeAttribute("aria-disabled");
        applyCustomRulesToggle.toggleEl.style.pointerEvents = "";
      } else {
        applyCustomRulesInAliasSetting.settingEl.classList.add("flit-row-disabled");
        applyCustomRulesToggle.toggleEl.tabIndex = -1;
        applyCustomRulesToggle.toggleEl.setAttribute("aria-disabled", "true");
        applyCustomRulesToggle.toggleEl.style.pointerEvents = "none";
        if (this.plugin.settings.applyCustomRulesInAlias) {
          this.plugin.settings.applyCustomRulesInAlias = false;
          await this.plugin.saveSettings();
          applyCustomRulesInAliasSetting.components[0].setValue(false);
        }
      }
      const stripMarkupEnabled = this.plugin.settings.enableStripMarkup;
      stripMarkupInAliasSetting.components[0].setDisabled(!stripMarkupEnabled);
      if (stripMarkupEnabled) {
        stripMarkupInAliasSetting.settingEl.classList.remove("flit-row-disabled");
        stripMarkupToggle.toggleEl.tabIndex = 0;
        stripMarkupToggle.toggleEl.removeAttribute("aria-disabled");
        stripMarkupToggle.toggleEl.style.pointerEvents = "";
      } else {
        stripMarkupInAliasSetting.settingEl.classList.add("flit-row-disabled");
        stripMarkupToggle.toggleEl.tabIndex = -1;
        stripMarkupToggle.toggleEl.setAttribute("aria-disabled", "true");
        stripMarkupToggle.toggleEl.style.pointerEvents = "none";
        if (this.plugin.settings.stripMarkupInAlias) {
          this.plugin.settings.stripMarkupInAlias = false;
          await this.plugin.saveSettings();
          stripMarkupInAliasSetting.components[0].setValue(false);
        }
      }
    };
    const aliasToggleSetting = new import_obsidian7.Setting(this.containerEl).setName(t("settings.alias.addAlias.name")).setDesc(t("settings.alias.addAlias.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableAliases).onChange(async (value) => {
        this.plugin.settings.enableAliases = value;
        this.plugin.debugLog("enableAliases", value);
        if (value && !this.plugin.settings.hasEnabledAliases) {
          this.plugin.settings.keepEmptyAliasProperty = true;
          if (this.plugin.settings.enableStripMarkup) {
            this.plugin.settings.stripMarkupInAlias = true;
          }
          if (this.plugin.settings.enableCustomReplacements) {
            this.plugin.settings.applyCustomRulesInAlias = true;
          }
          this.plugin.settings.hasEnabledAliases = true;
        }
        await this.plugin.saveSettings();
        renderAliasSettings();
      })
    );
    aliasToggleSetting.settingEl.addClass("flit-master-toggle");
    aliasToggleSetting.settingEl.addClass("flit-no-border");
    aliasToggleSetting.settingEl.style.marginBottom = "20px";
    const aliasContainer = this.containerEl.createDiv({ cls: "flit-alias-container" });
    let addAliasConditionalToggle;
    let truncateAliasToggle;
    let applyCustomRulesToggle;
    let stripMarkupToggle;
    let keepEmptyToggle;
    let hideInSidebarToggle;
    let suppressMergeToggle;
    const renderAliasSettings = () => {
      this.updateInteractiveState(aliasContainer, this.plugin.settings.enableAliases);
      this.updateDisabledRowsAccessibility(aliasContainer);
      const showActualState = this.plugin.settings.hasEnabledAliases;
      if (addAliasConditionalToggle) {
        addAliasConditionalToggle.setValue(showActualState ? this.plugin.settings.addAliasOnlyIfFirstLineDiffers : false);
      }
      if (truncateAliasToggle) {
        truncateAliasToggle.setValue(showActualState ? this.plugin.settings.truncateAlias : false);
      }
      if (applyCustomRulesToggle) {
        applyCustomRulesToggle.setValue(showActualState ? this.plugin.settings.applyCustomRulesInAlias : false);
      }
      if (stripMarkupToggle) {
        stripMarkupToggle.setValue(showActualState ? this.plugin.settings.stripMarkupInAlias : false);
      }
      if (keepEmptyToggle) {
        keepEmptyToggle.setValue(showActualState ? this.plugin.settings.keepEmptyAliasProperty : false);
      }
      if (hideInSidebarToggle) {
        hideInSidebarToggle.setValue(showActualState ? this.plugin.settings.hideAliasInSidebar : false);
      }
      if (suppressMergeToggle) {
        suppressMergeToggle.setValue(showActualState ? this.plugin.settings.suppressMergeNotifications : false);
      }
      updateAliasConditionalSettings();
    };
    const aliasPropertyKeySetting = new import_obsidian7.Setting(aliasContainer).setName(t("settings.alias.aliasPropertyName.name")).setDesc("");
    const aliasKeyDesc = aliasPropertyKeySetting.descEl;
    aliasKeyDesc.appendText(t("settings.alias.aliasPropertyName.desc"));
    const aliasNotesDesc = aliasKeyDesc.createEl("div");
    aliasNotesDesc.style.marginTop = "6px";
    aliasNotesDesc.style.marginBottom = "0px";
    const ul = aliasNotesDesc.createEl("ul");
    ul.style.margin = "0";
    ul.style.paddingLeft = "20px";
    ul.createEl("li", { text: t("settings.alias.aliasPropertyName.quickSwitcher") });
    ul.createEl("li", { text: t("settings.alias.aliasPropertyName.multipleProperties") });
    const li2 = ul.createEl("li");
    li2.appendText(t("settings.alias.aliasPropertyName.noteTitle.part1"));
    li2.createEl("a", {
      text: "Omnisearch",
      href: "obsidian://show-plugin?id=omnisearch"
    });
    li2.appendText(t("settings.alias.aliasPropertyName.noteTitle.part2"));
    li2.createEl("a", {
      text: "Notebook Navigator",
      href: "obsidian://show-plugin?id=notebook-navigator"
    });
    li2.appendText(t("settings.alias.aliasPropertyName.noteTitle.part3"));
    li2.createEl("a", {
      text: "Front Matter Title",
      href: "obsidian://show-plugin?id=obsidian-front-matter-title-plugin"
    });
    li2.appendText(t("settings.alias.aliasPropertyName.noteTitle.part4"));
    aliasKeyDesc.createEl("br");
    aliasKeyDesc.createEl("small").createEl("strong", { text: t("settings.alias.aliasPropertyName.default") });
    const aliasPropertyKeyContainer = aliasPropertyKeySetting.controlEl.createDiv({ cls: "flit-char-text-input-container" });
    const aliasPropertyKeyRestoreButton = aliasPropertyKeyContainer.createEl("button", {
      cls: "clickable-icon flit-restore-icon",
      attr: { "aria-label": t("settings.replaceCharacters.restoreDefault") }
    });
    (0, import_obsidian7.setIcon)(aliasPropertyKeyRestoreButton, "rotate-ccw");
    const aliasPropertyKeyTextInput = aliasPropertyKeyContainer.createEl("input", { type: "text", cls: "flit-char-text-input" });
    aliasPropertyKeyTextInput.placeholder = t("settings.replaceCharacters.emptyPlaceholder");
    aliasPropertyKeyTextInput.style.width = "120px";
    aliasPropertyKeyTextInput.value = this.plugin.settings.aliasPropertyKey;
    aliasPropertyKeyRestoreButton.addEventListener("click", async () => {
      this.plugin.settings.aliasPropertyKey = DEFAULT_SETTINGS.aliasPropertyKey;
      aliasPropertyKeyTextInput.value = DEFAULT_SETTINGS.aliasPropertyKey;
      this.plugin.debugLog("aliasPropertyKey", this.plugin.settings.aliasPropertyKey);
      await this.plugin.saveSettings();
    });
    aliasPropertyKeyTextInput.addEventListener("input", async (e) => {
      const value = e.target.value;
      this.plugin.settings.aliasPropertyKey = value.trim() || "aliases";
      this.plugin.debugLog("aliasPropertyKey", this.plugin.settings.aliasPropertyKey);
      await this.plugin.saveSettings();
    });
    const addAliasConditionalSetting = new import_obsidian7.Setting(aliasContainer).setName(t("settings.alias.onlyAddIfDiffers.name")).setDesc(t("settings.alias.onlyAddIfDiffers.desc")).addToggle((toggle) => {
      addAliasConditionalToggle = toggle;
      toggle.setValue(this.plugin.settings.hasEnabledAliases ? this.plugin.settings.addAliasOnlyIfFirstLineDiffers : false).onChange(async (value) => {
        this.plugin.settings.addAliasOnlyIfFirstLineDiffers = value;
        this.plugin.debugLog("addAliasOnlyIfFirstLineDiffers", value);
        await this.plugin.saveSettings();
      });
    });
    const truncateAliasSetting = new import_obsidian7.Setting(aliasContainer).setName(t("settings.alias.truncateAlias.name")).setDesc("");
    const truncateDesc = truncateAliasSetting.descEl;
    truncateDesc.appendText(t("settings.alias.truncateAlias.desc.part1"));
    if (getCurrentLocale() === "ru") {
      truncateDesc.appendText("\xAB" + t("settings.alias.truncateAlias.desc.charCount") + "\xBB");
    } else {
      truncateDesc.createEl("em", { text: t("settings.alias.truncateAlias.desc.charCount") });
    }
    truncateDesc.appendText(t("settings.alias.truncateAlias.desc.part2"));
    if (getCurrentLocale() === "ru") {
      truncateDesc.appendText("\xAB" + t("settings.alias.truncateAlias.desc.miscellaneous") + "\xBB");
    } else {
      truncateDesc.createEl("em", { text: t("settings.alias.truncateAlias.desc.miscellaneous") });
    }
    truncateDesc.appendText(t("settings.alias.truncateAlias.desc.part3"));
    truncateAliasSetting.addToggle((toggle) => {
      truncateAliasToggle = toggle;
      toggle.setValue(this.plugin.settings.hasEnabledAliases ? this.plugin.settings.truncateAlias : false).onChange(async (value) => {
        this.plugin.settings.truncateAlias = value;
        this.plugin.debugLog("truncateAlias", value);
        await this.plugin.saveSettings();
      });
    });
    const applyCustomRulesInAliasSetting = new import_obsidian7.Setting(aliasContainer).setName(t("settings.alias.applyCustomRules.name")).setDesc("");
    const customRulesDesc = applyCustomRulesInAliasSetting.descEl;
    customRulesDesc.appendText(t("settings.alias.applyCustomRules.desc.part1"));
    if (getCurrentLocale() === "ru") {
      customRulesDesc.appendText("\xAB" + t("settings.alias.applyCustomRules.desc.customRules") + "\xBB");
    } else {
      customRulesDesc.createEl("em", { text: t("settings.alias.applyCustomRules.desc.customRules") });
    }
    customRulesDesc.appendText(t("settings.alias.applyCustomRules.desc.part2"));
    applyCustomRulesInAliasSetting.addToggle((toggle) => {
      applyCustomRulesToggle = toggle;
      toggle.setValue(this.plugin.settings.hasEnabledAliases ? this.plugin.settings.applyCustomRulesInAlias : false).setDisabled(!this.plugin.settings.enableCustomReplacements).onChange(async (value) => {
        this.plugin.settings.applyCustomRulesInAlias = value;
        this.plugin.debugLog("applyCustomRulesInAlias", value);
        await this.plugin.saveSettings();
      });
      if (!this.plugin.settings.enableCustomReplacements) {
        toggle.toggleEl.tabIndex = -1;
        toggle.toggleEl.setAttribute("aria-disabled", "true");
        toggle.toggleEl.style.pointerEvents = "none";
      }
    });
    const stripMarkupInAliasSetting = new import_obsidian7.Setting(aliasContainer).setName(t("settings.alias.stripMarkup.name")).setDesc("");
    const stripMarkupDesc = stripMarkupInAliasSetting.descEl;
    stripMarkupDesc.appendText(t("settings.alias.stripMarkup.desc.part1"));
    if (getCurrentLocale() === "ru") {
      stripMarkupDesc.appendText("\xAB" + t("settings.alias.stripMarkup.desc.stripMarkup") + "\xBB");
    } else {
      stripMarkupDesc.createEl("em", { text: t("settings.alias.stripMarkup.desc.stripMarkup") });
    }
    stripMarkupDesc.appendText(t("settings.alias.stripMarkup.desc.part2"));
    stripMarkupInAliasSetting.addToggle((toggle) => {
      stripMarkupToggle = toggle;
      toggle.setValue(this.plugin.settings.hasEnabledAliases ? this.plugin.settings.stripMarkupInAlias : false).setDisabled(!this.plugin.settings.enableStripMarkup).onChange(async (value) => {
        this.plugin.settings.stripMarkupInAlias = value;
        this.plugin.debugLog("stripMarkupInAlias", value);
        await this.plugin.saveSettings();
      });
      if (!this.plugin.settings.enableStripMarkup) {
        toggle.toggleEl.tabIndex = -1;
        toggle.toggleEl.setAttribute("aria-disabled", "true");
        toggle.toggleEl.style.pointerEvents = "none";
      }
    });
    const keepEmptyAliasPropertySetting = new import_obsidian7.Setting(aliasContainer).setName(t("settings.alias.keepEmptyProperty.name")).setDesc(t("settings.alias.keepEmptyProperty.desc")).addToggle((toggle) => {
      keepEmptyToggle = toggle;
      toggle.setValue(this.plugin.settings.hasEnabledAliases ? this.plugin.settings.keepEmptyAliasProperty : false).onChange(async (value) => {
        this.plugin.settings.keepEmptyAliasProperty = value;
        this.plugin.debugLog("keepEmptyAliasProperty", value);
        await this.plugin.saveSettings();
      });
    });
    const hideAliasPropertySetting = new import_obsidian7.Setting(aliasContainer).setName(t("settings.alias.hideProperty.name")).setDesc(t("settings.alias.hideProperty.desc")).addDropdown(
      (dropdown) => dropdown.addOption("never", t("settings.alias.hideProperty.never")).addOption("when_empty", t("settings.alias.hideProperty.onlyWhenEmpty")).addOption("always", t("settings.alias.hideProperty.always")).setValue(this.plugin.settings.hideAliasProperty).onChange(async (value) => {
        this.plugin.settings.hideAliasProperty = value;
        this.plugin.debugLog("hideAliasProperty", value);
        await this.plugin.saveSettings();
        this.updatePropertyVisibility();
        hideInSidebarSetting.settingEl.style.display = value === "when_empty" || value === "always" ? "" : "none";
      })
    );
    const hideInSidebarContainer = aliasContainer.createDiv("flit-sub-settings");
    const hideInSidebarSetting = new import_obsidian7.Setting(hideInSidebarContainer).setName(t("settings.alias.hideInSidebar.name")).setDesc(t("settings.alias.hideInSidebar.desc")).addToggle((toggle) => {
      hideInSidebarToggle = toggle;
      toggle.setValue(this.plugin.settings.hasEnabledAliases ? this.plugin.settings.hideAliasInSidebar : false).onChange(async (value) => {
        this.plugin.settings.hideAliasInSidebar = value;
        this.plugin.debugLog("hideAliasInSidebar", value);
        await this.plugin.saveSettings();
        this.updatePropertyVisibility();
      });
    });
    hideInSidebarSetting.settingEl.style.display = this.plugin.settings.hideAliasProperty === "when_empty" || this.plugin.settings.hideAliasProperty === "always" ? "" : "none";
    const suppressMergeNotificationsSetting = new import_obsidian7.Setting(aliasContainer).setName(t("settings.alias.hideMergeNotifications.name")).setDesc(t("settings.alias.hideMergeNotifications.desc")).addToggle((toggle) => {
      suppressMergeToggle = toggle;
      toggle.setValue(this.plugin.settings.hasEnabledAliases ? this.plugin.settings.suppressMergeNotifications : false).onChange(async (value) => {
        this.plugin.settings.suppressMergeNotifications = value;
        this.plugin.debugLog("suppressMergeNotifications", value);
        await this.plugin.saveSettings();
      });
    });
    if (!import_obsidian7.Platform.isMobile) {
      const limitationsSetting = new import_obsidian7.Setting(aliasContainer).setName(t("settings.alias.limitations.title")).setDesc("");
      limitationsSetting.settingEl.addClass("flit-section-header");
      const limitationsContainer = aliasContainer.createDiv();
      const limitationsDesc = limitationsContainer.createEl("p", { cls: "setting-item-description" });
      limitationsDesc.style.marginTop = "12px";
      limitationsDesc.appendText(t("settings.alias.limitations.desc.part1"));
      limitationsDesc.createEl("a", {
        text: "Hover Editor",
        href: "obsidian://show-plugin?id=obsidian-hover-editor"
      });
      limitationsDesc.appendText(t("settings.alias.limitations.desc.part2"));
    }
    renderAliasSettings();
    updateAliasConditionalSettings();
    this.plugin.updateAliasConditionalSettings = updateAliasConditionalSettings;
  }
  updatePropertyVisibility() {
    this.plugin.updatePropertyVisibility();
  }
};

// src/settings/tab-replace-characters.ts
var import_obsidian8 = require("obsidian");
init_utils();
init_constants();
init_i18n();
var ForbiddenCharsTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
  }
  render() {
    const headerToggleSetting = new import_obsidian8.Setting(this.containerEl).setName(t("settings.replaceCharacters.name")).setDesc("").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableForbiddenCharReplacements).onChange(async (value) => {
        this.plugin.settings.enableForbiddenCharReplacements = value;
        this.plugin.debugLog("enableForbiddenCharReplacements", value);
        if (value && !this.plugin.settings.hasEnabledForbiddenChars) {
          const allOSesKeys = ["leftBracket", "rightBracket", "hash", "caret", "pipe", "slash", "colon"];
          allOSesKeys.forEach((key) => {
            this.plugin.settings.charReplacementEnabled[key] = true;
          });
          this.plugin.settings.hasEnabledForbiddenChars = true;
          const currentOS = detectOS();
          if (currentOS === "Windows" && !this.plugin.settings.hasEnabledWindowsAndroid) {
            this.plugin.settings.windowsAndroidEnabled = true;
            const windowsAndroidKeys = ["asterisk", "quote", "lessThan", "greaterThan", "question"];
            windowsAndroidKeys.forEach((key) => {
              this.plugin.settings.charReplacementEnabled[key] = true;
            });
            this.plugin.settings.hasEnabledWindowsAndroid = true;
          }
        }
        await this.plugin.saveSettings();
        updateCharacterSettings();
        updateCharacterReplacementUI();
        updateWindowsAndroidUI();
        if (windowsAndroidToggleComponent) {
          windowsAndroidToggleComponent.setDisabled(!value);
          if (value) {
            windowsAndroidToggleComponent.toggleEl.style.pointerEvents = "";
            windowsAndroidToggleComponent.toggleEl.style.opacity = "";
            windowsAndroidToggleComponent.toggleEl.tabIndex = 0;
            windowsAndroidToggleComponent.toggleEl.removeAttribute("aria-disabled");
          } else {
            windowsAndroidToggleComponent.toggleEl.style.pointerEvents = "none";
            windowsAndroidToggleComponent.toggleEl.style.opacity = "0.5";
            windowsAndroidToggleComponent.toggleEl.tabIndex = -1;
            windowsAndroidToggleComponent.toggleEl.setAttribute("aria-disabled", "true");
          }
        }
      });
    });
    headerToggleSetting.settingEl.addClass("flit-master-toggle");
    headerToggleSetting.settingEl.addClass("flit-no-border");
    const charDescEl = this.containerEl.createEl("div", { cls: "setting-item-description" });
    const updateCharDescriptionContent = () => {
      charDescEl.setText(t("settings.replaceCharacters.desc"));
    };
    updateCharDescriptionContent();
    this.containerEl.createEl("br");
    this.containerEl.createEl("br");
    const charSettingsContainer = this.containerEl.createDiv({ cls: "flit-char-settings-container" });
    const updateCharacterReplacementUI = () => {
      this.updateInteractiveState(
        charSettingsContainer,
        this.plugin.settings.enableForbiddenCharReplacements
      );
      this.updateDisabledRowsAccessibility(charSettingsContainer);
      const tableContainers = charSettingsContainer.querySelectorAll(".flit-table-container");
      tableContainers.forEach((container) => {
        if (this.plugin.settings.enableForbiddenCharReplacements) {
          container.classList.remove("flit-master-disabled");
        } else {
          container.classList.add("flit-master-disabled");
        }
      });
    };
    const primaryCharSettings = [
      { key: "leftBracket", name: t("settings.replaceCharacters.characters.leftBracket"), char: "[" },
      { key: "rightBracket", name: t("settings.replaceCharacters.characters.rightBracket"), char: "]" },
      { key: "hash", name: t("settings.replaceCharacters.characters.hash"), char: "#" },
      { key: "caret", name: t("settings.replaceCharacters.characters.caret"), char: "^" },
      { key: "pipe", name: t("settings.replaceCharacters.characters.pipe"), char: "|" },
      { key: "backslash", name: t("settings.replaceCharacters.characters.backslash"), char: String.fromCharCode(92) },
      { key: "slash", name: t("settings.replaceCharacters.characters.forwardSlash"), char: "/" },
      { key: "colon", name: t("settings.replaceCharacters.characters.colon"), char: ":" },
      { key: "dot", name: t("settings.replaceCharacters.characters.dot"), char: ".", description: t("settings.replaceCharacters.characters.dotNote") }
    ];
    const windowsAndroidChars = [
      { key: "asterisk", name: t("settings.replaceCharacters.characters.asterisk"), char: "*" },
      { key: "quote", name: t("settings.replaceCharacters.characters.quote"), char: '"' },
      { key: "lessThan", name: t("settings.replaceCharacters.characters.lessThan"), char: "<" },
      { key: "greaterThan", name: t("settings.replaceCharacters.characters.greaterThan"), char: ">" },
      { key: "question", name: t("settings.replaceCharacters.characters.questionMark"), char: "?" }
    ];
    let windowsAndroidTableContainer;
    let windowsAndroidToggleComponent;
    const updateCharacterSettings = () => {
      charSettingsContainer.empty();
      const allOSesHeaderSetting = new import_obsidian8.Setting(charSettingsContainer).setName(t("settings.replaceCharacters.allOSes.title")).setDesc(t("settings.replaceCharacters.allOSes.desc"));
      allOSesHeaderSetting.settingEl.addClass("flit-master-toggle");
      const allOSesNoteEl = charSettingsContainer.createEl("div", { cls: "setting-item-description" });
      allOSesNoteEl.style.marginTop = "15px";
      allOSesNoteEl.style.marginBottom = "15px";
      allOSesNoteEl.appendText(t("settings.replaceCharacters.allOSes.note.part1"));
      if (getCurrentLocale() === "ru") {
        allOSesNoteEl.appendText("\xAB" + t("settings.replaceCharacters.allOSes.note.trimLeft") + "\xBB");
      } else {
        allOSesNoteEl.createEl("em", { text: t("settings.replaceCharacters.allOSes.note.trimLeft") });
      }
      allOSesNoteEl.appendText(t("settings.replaceCharacters.allOSes.note.part2"));
      if (getCurrentLocale() === "ru") {
        allOSesNoteEl.appendText("\xAB" + t("settings.replaceCharacters.allOSes.note.trimRight") + "\xBB");
      } else {
        allOSesNoteEl.createEl("em", { text: t("settings.replaceCharacters.allOSes.note.trimRight") });
      }
      allOSesNoteEl.appendText(t("settings.replaceCharacters.allOSes.note.part3"));
      const allOSesTableContainer = charSettingsContainer.createEl("div", { cls: "flit-table-container" });
      const allOSesTableWrapper = allOSesTableContainer.createEl("div", { cls: "flit-table-wrapper" });
      const headerRow = allOSesTableWrapper.createEl("div", { cls: "flit-char-replacement-header" });
      const enableHeader = headerRow.createDiv({ cls: "flit-enable-column" });
      enableHeader.textContent = t("settings.replaceCharacters.headers.enable");
      const charNameHeader = headerRow.createDiv({ cls: "flit-char-name-column" });
      charNameHeader.textContent = t("settings.replaceCharacters.headers.character");
      const inputHeader = headerRow.createDiv({ cls: "flit-char-text-input-container" });
      inputHeader.textContent = t("settings.replaceCharacters.headers.replaceWith");
      const trimLeftHeader = headerRow.createDiv({ cls: "flit-toggle-column center" });
      const trimLeftLine1 = trimLeftHeader.createDiv();
      trimLeftLine1.textContent = t("settings.replaceCharacters.headers.trimLeft");
      const trimRightHeader = headerRow.createDiv({ cls: "flit-toggle-column center" });
      const trimRightLine1 = trimRightHeader.createDiv();
      trimRightLine1.textContent = t("settings.replaceCharacters.headers.trimRight");
      primaryCharSettings.forEach((setting) => {
        const rowEl = allOSesTableWrapper.createEl("div", { cls: "flit-char-replacement-setting" });
        const toggleContainer = rowEl.createDiv({ cls: "flit-enable-column" });
        const toggleSetting = new import_obsidian8.Setting(document.createElement("div"));
        toggleSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledForbiddenChars ? this.plugin.settings.charReplacementEnabled[setting.key] : false).onChange(async (value) => {
            this.plugin.settings.charReplacementEnabled[setting.key] = value;
            this.plugin.debugLog(`charReplacementEnabled.${setting.key}`, value);
            await this.plugin.saveSettings();
            updateRowAppearance();
          });
          toggle.toggleEl.style.margin = "0";
          toggleContainer.appendChild(toggle.toggleEl);
        });
        const updateRowAppearance = () => {
          if (this.plugin.settings.charReplacementEnabled[setting.key]) {
            rowEl.classList.remove("flit-row-disabled");
          } else {
            rowEl.classList.add("flit-row-disabled");
          }
        };
        const nameContainer = rowEl.createEl("div", { cls: "flit-char-name-column" });
        const nameEl = nameContainer.createEl("div", { text: setting.name, cls: "setting-item-name" });
        if (setting.description) {
          const descEl = nameContainer.createEl("div", { cls: "setting-item-description" });
          descEl.textContent = setting.description;
        }
        const inputContainer = rowEl.createDiv({ cls: "flit-char-text-input-container" });
        const restoreButton = inputContainer.createEl("button", {
          cls: "clickable-icon flit-restore-icon",
          attr: { "aria-label": t("settings.replaceCharacters.restoreDefault") }
        });
        (0, import_obsidian8.setIcon)(restoreButton, "rotate-ccw");
        restoreButton.addEventListener("click", async () => {
          this.plugin.settings.charReplacements[setting.key] = DEFAULT_SETTINGS.charReplacements[setting.key];
          textInput.value = DEFAULT_SETTINGS.charReplacements[setting.key];
          await this.plugin.saveSettings();
        });
        const textInput = inputContainer.createEl("input", { type: "text", cls: "flit-char-text-input" });
        textInput.placeholder = t("settings.replaceCharacters.emptyPlaceholder");
        textInput.value = this.plugin.settings.charReplacements[setting.key];
        textInput.style.width = "120px";
        textInput.addEventListener("input", async (e) => {
          this.plugin.settings.charReplacements[setting.key] = e.target.value;
          this.plugin.debugLog(`charReplacements[${setting.key}]`, this.plugin.settings.charReplacements[setting.key]);
          await this.plugin.saveSettings();
        });
        this.addForbiddenCharProtection(textInput);
        const trimLeftContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const trimLeftSetting = new import_obsidian8.Setting(document.createElement("div"));
        trimLeftSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledForbiddenChars ? this.plugin.settings.charReplacementTrimLeft[setting.key] : false).onChange(async (value) => {
            this.plugin.settings.charReplacementTrimLeft[setting.key] = value;
            this.plugin.debugLog(`charReplacementTrimLeft.${setting.key}`, value);
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          trimLeftContainer.appendChild(toggle.toggleEl);
        });
        const trimRightContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const trimRightSetting = new import_obsidian8.Setting(document.createElement("div"));
        trimRightSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledForbiddenChars ? this.plugin.settings.charReplacementTrimRight[setting.key] : false).onChange(async (value) => {
            this.plugin.settings.charReplacementTrimRight[setting.key] = value;
            this.plugin.debugLog(`charReplacementTrimRight.${setting.key}`, value);
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          trimRightContainer.appendChild(toggle.toggleEl);
        });
        updateRowAppearance();
      });
      const windowsAndroidHeaderSetting = new import_obsidian8.Setting(charSettingsContainer).setName(t("settings.replaceCharacters.windowsAndroid.title")).setDesc(t("settings.replaceCharacters.windowsAndroid.desc")).addToggle((toggle) => {
        windowsAndroidToggleComponent = toggle;
        toggle.setValue(this.plugin.settings.windowsAndroidEnabled).setDisabled(!this.plugin.settings.enableForbiddenCharReplacements).onChange(async (value) => {
          this.plugin.settings.windowsAndroidEnabled = value;
          this.plugin.debugLog("windowsAndroidEnabled", value);
          if (value && !this.plugin.settings.hasEnabledWindowsAndroid) {
            windowsAndroidChars.forEach((setting) => {
              this.plugin.settings.charReplacementEnabled[setting.key] = true;
            });
            this.plugin.settings.hasEnabledWindowsAndroid = true;
          }
          await this.plugin.saveSettings();
          updateWindowsAndroidUI();
        });
        if (!this.plugin.settings.enableForbiddenCharReplacements) {
          toggle.toggleEl.style.pointerEvents = "none";
          toggle.toggleEl.style.opacity = "0.5";
          toggle.toggleEl.tabIndex = -1;
          toggle.toggleEl.setAttribute("aria-disabled", "true");
        }
      });
      windowsAndroidHeaderSetting.settingEl.addClass("flit-master-toggle");
      windowsAndroidHeaderSetting.settingEl.addClass("flit-windows-android-header");
      charSettingsContainer.createEl("br");
      windowsAndroidTableContainer = charSettingsContainer.createEl("div", { cls: "flit-table-container flit-windows-android-table" });
      const windowsAndroidTableWrapper = windowsAndroidTableContainer.createEl("div", { cls: "flit-table-wrapper" });
      const winAndroidHeaderRow = windowsAndroidTableWrapper.createEl("div", { cls: "flit-char-replacement-header" });
      const winEnableHeader = winAndroidHeaderRow.createDiv({ cls: "flit-enable-column" });
      winEnableHeader.textContent = t("settings.replaceCharacters.headers.enable");
      const winCharNameHeader = winAndroidHeaderRow.createDiv({ cls: "flit-char-name-column" });
      winCharNameHeader.textContent = t("settings.replaceCharacters.headers.character");
      const winInputHeader = winAndroidHeaderRow.createDiv({ cls: "flit-char-text-input-container" });
      winInputHeader.textContent = t("settings.replaceCharacters.headers.replaceWith");
      const winTrimLeftHeader = winAndroidHeaderRow.createDiv({ cls: "flit-toggle-column center" });
      const winTrimLeftLine1 = winTrimLeftHeader.createDiv();
      winTrimLeftLine1.textContent = t("settings.replaceCharacters.headers.trimLeft");
      const winTrimRightHeader = winAndroidHeaderRow.createDiv({ cls: "flit-toggle-column center" });
      const winTrimRightLine1 = winTrimRightHeader.createDiv();
      winTrimRightLine1.textContent = t("settings.replaceCharacters.headers.trimRight");
      windowsAndroidChars.forEach((setting) => {
        const rowEl = windowsAndroidTableWrapper.createEl("div", { cls: "flit-char-replacement-setting" });
        const toggleContainer = rowEl.createDiv({ cls: "flit-enable-column" });
        const toggleSetting = new import_obsidian8.Setting(document.createElement("div"));
        toggleSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledForbiddenChars && this.plugin.settings.hasEnabledWindowsAndroid ? this.plugin.settings.charReplacementEnabled[setting.key] : false).onChange(async (value) => {
            this.plugin.settings.charReplacementEnabled[setting.key] = value;
            this.plugin.debugLog(`charReplacementEnabled.${setting.key}`, value);
            await this.plugin.saveSettings();
            updateRowAppearance();
          });
          toggle.toggleEl.style.margin = "0";
          toggleContainer.appendChild(toggle.toggleEl);
        });
        const updateRowAppearance = () => {
          if (this.plugin.settings.charReplacementEnabled[setting.key]) {
            rowEl.classList.remove("flit-row-disabled");
          } else {
            rowEl.classList.add("flit-row-disabled");
          }
        };
        const nameContainer = rowEl.createEl("div", { cls: "flit-char-name-column" });
        const nameEl = nameContainer.createEl("div", { text: setting.name, cls: "setting-item-name" });
        const inputContainer = rowEl.createDiv({ cls: "flit-char-text-input-container" });
        const restoreButton = inputContainer.createEl("button", {
          cls: "clickable-icon flit-restore-icon",
          attr: { "aria-label": t("settings.replaceCharacters.restoreDefault") }
        });
        (0, import_obsidian8.setIcon)(restoreButton, "rotate-ccw");
        restoreButton.addEventListener("click", async () => {
          this.plugin.settings.charReplacements[setting.key] = DEFAULT_SETTINGS.charReplacements[setting.key];
          textInput.value = DEFAULT_SETTINGS.charReplacements[setting.key];
          await this.plugin.saveSettings();
        });
        const textInput = inputContainer.createEl("input", { type: "text", cls: "flit-char-text-input" });
        textInput.placeholder = t("settings.replaceCharacters.emptyPlaceholder");
        textInput.value = this.plugin.settings.charReplacements[setting.key];
        textInput.style.width = "120px";
        textInput.addEventListener("input", async (e) => {
          this.plugin.settings.charReplacements[setting.key] = e.target.value;
          this.plugin.debugLog(`charReplacements[${setting.key}]`, this.plugin.settings.charReplacements[setting.key]);
          await this.plugin.saveSettings();
        });
        this.addForbiddenCharProtection(textInput, true);
        const trimLeftContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const trimLeftSetting = new import_obsidian8.Setting(document.createElement("div"));
        trimLeftSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledForbiddenChars && this.plugin.settings.hasEnabledWindowsAndroid ? this.plugin.settings.charReplacementTrimLeft[setting.key] : false).onChange(async (value) => {
            this.plugin.settings.charReplacementTrimLeft[setting.key] = value;
            this.plugin.debugLog(`charReplacementTrimLeft.${setting.key}`, value);
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          trimLeftContainer.appendChild(toggle.toggleEl);
        });
        const trimRightContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const trimRightSetting = new import_obsidian8.Setting(document.createElement("div"));
        trimRightSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledForbiddenChars && this.plugin.settings.hasEnabledWindowsAndroid ? this.plugin.settings.charReplacementTrimRight[setting.key] : false).onChange(async (value) => {
            this.plugin.settings.charReplacementTrimRight[setting.key] = value;
            this.plugin.debugLog(`charReplacementTrimRight.${setting.key}`, value);
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          trimRightContainer.appendChild(toggle.toggleEl);
        });
        updateRowAppearance();
      });
    };
    const updateWindowsAndroidUI = () => {
      if (this.plugin.settings.windowsAndroidEnabled) {
        windowsAndroidTableContainer.show();
      } else {
        windowsAndroidTableContainer.hide();
      }
    };
    updateCharacterSettings();
    updateCharacterReplacementUI();
    updateWindowsAndroidUI();
  }
};

// src/settings/tab-strip-markup.ts
var import_obsidian9 = require("obsidian");
init_i18n();
var StripMarkupTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
  }
  render() {
    const masterToggleSetting = new import_obsidian9.Setting(this.containerEl).setName(t("settings.stripMarkup.name")).setDesc(t("settings.stripMarkup.desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableStripMarkup).onChange(async (value) => {
        var _a, _b;
        this.plugin.settings.enableStripMarkup = value;
        this.plugin.debugLog("enableStripMarkup", value);
        if (!value) {
          if (this.plugin.settings.stripMarkupInAlias) {
            this.plugin.settings.stripMarkupInAlias = false;
          }
        }
        await this.plugin.saveSettings();
        updateStripMarkupUI();
        (_b = (_a = this.plugin).updateAliasConditionalSettings) == null ? void 0 : _b.call(_a);
      });
    });
    masterToggleSetting.settingEl.addClass("flit-master-toggle");
    masterToggleSetting.settingEl.addClass("flit-no-border");
    masterToggleSetting.settingEl.style.marginBottom = "20px";
    const stripMarkupContainer = this.containerEl.createDiv({ cls: "flit-strip-markup-container" });
    const updateStripMarkupUI = () => {
      this.updateInteractiveState(stripMarkupContainer, this.plugin.settings.enableStripMarkup);
      this.updateDisabledRowsAccessibility(stripMarkupContainer);
    };
    const markupToggles = [
      { key: "headings" },
      { key: "bold" },
      { key: "italic" },
      { key: "strikethrough" },
      { key: "highlight" },
      { key: "wikilinks" },
      { key: "markdownLinks" },
      { key: "quote" },
      { key: "callouts" },
      { key: "unorderedLists" },
      { key: "orderedLists" },
      { key: "taskLists" },
      { key: "code" },
      { key: "codeBlocks" },
      { key: "footnotes" },
      { key: "comments" },
      { key: "stripTableMarkup", isCustom: true },
      { key: "htmlTags" }
    ];
    let stripCommentsEntirelyContainer;
    const updateStripCommentsEntirelyVisibility = () => {
      if (this.plugin.settings.stripMarkupSettings.comments) {
        stripCommentsEntirelyContainer.show();
      } else {
        stripCommentsEntirelyContainer.hide();
      }
    };
    markupToggles.forEach((toggle) => {
      const setting = new import_obsidian9.Setting(stripMarkupContainer).setName(t(`settings.stripMarkup.${toggle.key}.name`)).setDesc("");
      if (toggle.key === "stripTableMarkup") {
        const desc = setting.descEl;
        desc.appendText(t("settings.stripMarkup.stripTableMarkup.desc.part1"));
        if (getCurrentLocale() === "ru") {
          desc.appendText("\xAB" + t("settings.stripMarkup.stripTableMarkup.desc.table") + "\xBB");
        } else {
          desc.createEl("em", { text: t("settings.stripMarkup.stripTableMarkup.desc.table") });
        }
        desc.appendText(t("settings.stripMarkup.stripTableMarkup.desc.part2"));
      } else {
        setting.descEl.appendText(t(`settings.stripMarkup.${toggle.key}.desc`));
      }
      setting.addToggle((toggleControl) => {
        if (toggle.isCustom) {
          toggleControl.setValue(this.plugin.settings[toggle.key]).onChange(async (value) => {
            this.plugin.settings[toggle.key] = value;
            this.plugin.debugLog(toggle.key, value);
            await this.plugin.saveSettings();
          });
        } else {
          toggleControl.setValue(this.plugin.settings.stripMarkupSettings[toggle.key]).onChange(async (value) => {
            this.plugin.settings.stripMarkupSettings[toggle.key] = value;
            this.plugin.debugLog(`stripMarkupSettings.${toggle.key}`, value);
            await this.plugin.saveSettings();
            if (toggle.key === "comments") {
              updateStripCommentsEntirelyVisibility();
            }
          });
        }
      });
      if (toggle.key === "comments") {
        const stripCommentsEntirelySetting = new import_obsidian9.Setting(stripMarkupContainer).setName(t("settings.stripMarkup.commentsEntirely.name")).setDesc(t("settings.stripMarkup.commentsEntirely.desc")).addToggle(
          (toggle2) => toggle2.setValue(this.plugin.settings.stripCommentsEntirely).onChange(async (value) => {
            this.plugin.settings.stripCommentsEntirely = value;
            this.plugin.debugLog("stripCommentsEntirely", value);
            await this.plugin.saveSettings();
          })
        );
        stripCommentsEntirelyContainer = stripMarkupContainer.createDiv("flit-sub-settings");
        stripCommentsEntirelyContainer.appendChild(stripCommentsEntirelySetting.settingEl);
        updateStripCommentsEntirelyVisibility();
      }
    });
    const templaterSetting = new import_obsidian9.Setting(stripMarkupContainer).setName(t("settings.stripMarkup.templater.name")).setDesc("");
    const templaterDesc = templaterSetting.descEl;
    templaterDesc.appendText(t("settings.stripMarkup.templater.desc.part1"));
    templaterDesc.createEl("a", {
      text: "Templater",
      href: "obsidian://show-plugin?id=templater-obsidian"
    });
    templaterDesc.appendText(t("settings.stripMarkup.templater.desc.part2"));
    templaterDesc.createEl("code", { text: t("settings.stripMarkup.templater.desc.code") });
    templaterDesc.appendText(t("settings.stripMarkup.templater.desc.part3"));
    templaterSetting.addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.stripTemplaterSyntax).onChange(async (value) => {
        this.plugin.settings.stripTemplaterSyntax = value;
        this.plugin.debugLog("stripTemplaterSyntax", value);
        await this.plugin.saveSettings();
      })
    );
    updateStripMarkupUI();
  }
};

// src/settings/tab-custom-rules.ts
var import_obsidian10 = require("obsidian");
init_i18n();
var CustomReplacementsTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
  }
  render() {
    const customHeaderToggleSetting = new import_obsidian10.Setting(this.containerEl).setName(t("settings.customRules.name")).setDesc("").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableCustomReplacements).onChange(async (value) => {
        var _a, _b;
        this.plugin.settings.enableCustomReplacements = value;
        this.plugin.debugLog("enableCustomReplacements", value);
        if (value && !this.plugin.settings.hasEnabledCustomReplacements) {
          this.plugin.settings.customReplacements.forEach((replacement) => {
            replacement.enabled = true;
          });
          this.plugin.settings.hasEnabledCustomReplacements = true;
        }
        if (!value) {
          if (this.plugin.settings.applyCustomRulesInAlias) {
            this.plugin.settings.applyCustomRulesInAlias = false;
          }
        }
        await this.plugin.saveSettings();
        updateCustomReplacementUI();
        renderCustomReplacements();
        (_b = (_a = this.plugin).updateAliasConditionalSettings) == null ? void 0 : _b.call(_a);
      });
    });
    customHeaderToggleSetting.settingEl.addClass("flit-master-toggle");
    customHeaderToggleSetting.settingEl.addClass("flit-no-border");
    const customDescEl = this.containerEl.createEl("div", { cls: "setting-item-description" });
    const customBulletListEl = this.containerEl.createEl("div", { cls: "setting-item-description" });
    const updateCustomDescriptionContent = () => {
      customDescEl.empty();
      customBulletListEl.empty();
      customDescEl.createEl("span", { text: t("settings.customRules.desc") });
      customDescEl.createEl("br");
      customDescEl.createEl("br");
      const ul = customBulletListEl.createEl("ul");
      ul.style.margin = "0";
      ul.style.paddingLeft = "20px";
      const li1 = ul.createEl("li", { text: t("settings.customRules.rulesAppliedSequentially") });
      const li3 = ul.createEl("li", { text: t("settings.customRules.whitespacePreserved") });
      const li4 = ul.createEl("li");
      li4.appendText(t("settings.customRules.leaveBlank.part1"));
      if (getCurrentLocale() === "ru") {
        li4.appendText("\xAB" + t("settings.customRules.leaveBlank.replaceWith") + "\xBB");
      } else {
        li4.createEl("em", { text: t("settings.customRules.leaveBlank.replaceWith") });
      }
      li4.appendText(t("settings.customRules.leaveBlank.part2"));
      const li5 = ul.createEl("li");
      li5.appendText(t("settings.customRules.untitledWarning.part1"));
      if (getCurrentLocale() === "ru") {
        li5.appendText("\xAB" + t("settings.customRules.untitledWarning.replaceWith") + "\xBB");
      } else {
        li5.createEl("em", { text: t("settings.customRules.untitledWarning.replaceWith") });
      }
      li5.appendText(t("settings.customRules.untitledWarning.part2"));
      if (getCurrentLocale() === "ru") {
        li5.appendText("\xAB" + t("settings.customRules.untitledWarning.textToReplace") + "\xBB");
      } else {
        li5.createEl("em", { text: t("settings.customRules.untitledWarning.textToReplace") });
      }
      li5.appendText(t("settings.customRules.untitledWarning.part3"));
      if (getCurrentLocale() === "ru") {
        li5.appendText("\xAB" + t("settings.customRules.untitledWarning.untitled") + "\xBB");
      } else {
        li5.createEl("em", { text: t("settings.customRules.untitledWarning.untitled") });
      }
      li5.appendText(t("settings.customRules.untitledWarning.part4"));
    };
    updateCustomDescriptionContent();
    this.containerEl.createEl("br");
    const customReplacementsContainer = this.containerEl.createDiv({ cls: "flit-custom-replacements-container" });
    let processingOrderContainer;
    let globalProcessingHeaderSetting;
    let markupToggleContainer;
    let markupToggleSetting;
    let markupToggle;
    const updateCustomReplacementUI = () => {
      const enabled = this.plugin.settings.enableCustomReplacements;
      this.updateInteractiveState(customBulletListEl, enabled);
      this.updateInteractiveState(customReplacementsContainer, enabled);
      if (processingOrderContainer) {
        this.updateInteractiveState(processingOrderContainer, enabled);
      }
      if (globalProcessingHeaderSetting) {
        if (enabled) {
          globalProcessingHeaderSetting.settingEl.classList.remove("flit-master-disabled");
        } else {
          globalProcessingHeaderSetting.settingEl.classList.add("flit-master-disabled");
        }
      }
      if (markupToggleContainer) {
        markupToggleContainer.style.opacity = "";
      }
      if (markupToggleSetting) {
        updateMarkupToggleVisibility();
      }
      this.updateDisabledRowsAccessibility(customReplacementsContainer);
      const tableContainers = customReplacementsContainer.querySelectorAll(".flit-table-container");
      tableContainers.forEach((container) => {
        if (enabled) {
          container.classList.remove("flit-master-disabled");
        } else {
          container.classList.add("flit-master-disabled");
        }
      });
    };
    const renderCustomReplacements = () => {
      customReplacementsContainer.empty();
      const existingAddButton = this.containerEl.querySelector(".flit-add-replacement-button");
      if (existingAddButton) existingAddButton.remove();
      const tableContainer = customReplacementsContainer.createEl("div", { cls: "flit-table-container flit-custom-table-container" });
      const tableWrapper = tableContainer.createEl("div", { cls: "flit-table-wrapper" });
      const headerRow = tableWrapper.createEl("div", { cls: "flit-custom-replacement-header" });
      const enableHeader = headerRow.createDiv({ cls: "flit-enable-column" });
      enableHeader.textContent = t("settings.customRules.headers.enable");
      const textToReplaceHeader = headerRow.createDiv({ cls: "flit-text-column" });
      textToReplaceHeader.textContent = t("settings.customRules.headers.textToReplace");
      const replaceWithHeader = headerRow.createDiv({ cls: "flit-text-column" });
      replaceWithHeader.textContent = t("settings.customRules.headers.replaceWith");
      const startOnlyHeader = headerRow.createDiv({ cls: "flit-toggle-column" });
      const startLine1 = startOnlyHeader.createDiv();
      startLine1.textContent = t("settings.customRules.headers.onlyMatchLineStart").split("\n")[0];
      const startLine2 = startOnlyHeader.createDiv();
      startLine2.textContent = t("settings.customRules.headers.onlyMatchLineStart").split("\n")[1] || "";
      const wholeLineHeader = headerRow.createDiv({ cls: "flit-toggle-column" });
      const wholeLine1 = wholeLineHeader.createDiv();
      wholeLine1.textContent = t("settings.customRules.headers.onlyMatchWholeLine").split("\n")[0];
      const wholeLine2 = wholeLineHeader.createDiv();
      wholeLine2.textContent = t("settings.customRules.headers.onlyMatchWholeLine").split("\n")[1] || "";
      const actionsHeader = headerRow.createDiv({ cls: "flit-actions-column" });
      actionsHeader.textContent = "";
      this.plugin.settings.customReplacements.forEach((replacement, index) => {
        const rowEl = tableWrapper.createEl("div", { cls: "flit-custom-replacement-setting" });
        let deleteButton;
        let updateButtonState;
        const toggleContainer = rowEl.createDiv({ cls: "flit-enable-column" });
        const individualToggleSetting = new import_obsidian10.Setting(document.createElement("div"));
        individualToggleSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledCustomReplacements ? replacement.enabled : false).onChange(async (value) => {
            this.plugin.settings.customReplacements[index].enabled = value;
            this.plugin.debugLog(`customReplacements[${index}].enabled`, value);
            await this.plugin.saveSettings();
            updateRowAppearance();
          });
          toggle.toggleEl.style.margin = "0";
          toggleContainer.appendChild(toggle.toggleEl);
        });
        const updateRowAppearance = () => {
          const isRowEnabled = this.plugin.settings.customReplacements[index].enabled;
          const masterEnabled = this.plugin.settings.enableCustomReplacements;
          const shouldApplyInlineOpacity = masterEnabled;
          if (isRowEnabled) {
            rowEl.classList.remove("flit-row-disabled");
            input1.style.opacity = "";
            input1.style.pointerEvents = "";
            input1.disabled = false;
            input1.tabIndex = 0;
            input1.removeAttribute("aria-disabled");
            input2.style.opacity = "";
            input2.style.pointerEvents = "";
            input2.disabled = false;
            input2.tabIndex = 0;
            input2.removeAttribute("aria-disabled");
            startToggleContainer.style.opacity = "";
            startToggleContainer.style.pointerEvents = "";
            wholeToggleContainer.style.opacity = "";
            wholeToggleContainer.style.pointerEvents = "";
            [startToggleContainer, wholeToggleContainer].forEach((container) => {
              const toggleEls = container.querySelectorAll('input[type="checkbox"]');
              toggleEls.forEach((el) => {
                el.tabIndex = 0;
                el.removeAttribute("aria-disabled");
              });
            });
          } else {
            rowEl.classList.add("flit-row-disabled");
            input1.style.opacity = shouldApplyInlineOpacity ? "0.5" : "";
            input1.style.pointerEvents = "none";
            input1.disabled = true;
            input1.tabIndex = -1;
            input1.setAttribute("aria-disabled", "true");
            input2.style.opacity = shouldApplyInlineOpacity ? "0.5" : "";
            input2.style.pointerEvents = "none";
            input2.disabled = true;
            input2.tabIndex = -1;
            input2.setAttribute("aria-disabled", "true");
            startToggleContainer.style.opacity = shouldApplyInlineOpacity ? "0.5" : "";
            startToggleContainer.style.pointerEvents = "none";
            wholeToggleContainer.style.opacity = shouldApplyInlineOpacity ? "0.5" : "";
            wholeToggleContainer.style.pointerEvents = "none";
            [startToggleContainer, wholeToggleContainer].forEach((container) => {
              const toggleEls = container.querySelectorAll('input[type="checkbox"]');
              toggleEls.forEach((el) => {
                el.tabIndex = -1;
                el.setAttribute("aria-disabled", "true");
              });
            });
          }
        };
        const input1Container = rowEl.createDiv({ cls: "flit-text-column" });
        const input1 = input1Container.createEl("input", { type: "text" });
        input1.placeholder = t("settings.replaceCharacters.emptyPlaceholder");
        input1.value = replacement.searchText;
        input1.addEventListener("input", async (e) => {
          this.plugin.settings.customReplacements[index].searchText = e.target.value;
          this.plugin.debugLog(`customReplacements[${index}].searchText`, this.plugin.settings.customReplacements[index].searchText);
          await this.plugin.saveSettings();
          updateButtonState();
        });
        this.addForbiddenCharProtection(input1);
        const input2Container = rowEl.createDiv({ cls: "flit-text-column" });
        const input2 = input2Container.createEl("input", { type: "text" });
        input2.placeholder = t("settings.replaceCharacters.emptyPlaceholder");
        input2.value = replacement.replaceText;
        input2.addEventListener("input", async (e) => {
          this.plugin.settings.customReplacements[index].replaceText = e.target.value;
          this.plugin.debugLog(`customReplacements[${index}].replaceText`, this.plugin.settings.customReplacements[index].replaceText);
          await this.plugin.saveSettings();
          updateButtonState();
        });
        this.addForbiddenCharProtection(input2);
        const startToggleContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const startToggleSetting = new import_obsidian10.Setting(document.createElement("div"));
        startToggleSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledCustomReplacements ? replacement.onlyAtStart : false).onChange(async (value) => {
            this.plugin.settings.customReplacements[index].onlyAtStart = value;
            this.plugin.debugLog(`customReplacements[${index}].onlyAtStart`, value);
            if (value) {
              this.plugin.settings.customReplacements[index].onlyWholeLine = false;
            }
            await this.plugin.saveSettings();
            renderCustomReplacements();
          });
          toggle.toggleEl.style.margin = "0";
          if (replacement.onlyWholeLine) {
            toggle.setDisabled(true);
            toggle.toggleEl.style.opacity = "0.5";
            toggle.toggleEl.style.pointerEvents = "none";
          }
          startToggleContainer.appendChild(toggle.toggleEl);
        });
        const wholeToggleContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const wholeToggleSetting = new import_obsidian10.Setting(document.createElement("div"));
        wholeToggleSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledCustomReplacements ? replacement.onlyWholeLine : false).onChange(async (value) => {
            this.plugin.settings.customReplacements[index].onlyWholeLine = value;
            this.plugin.debugLog(`customReplacements[${index}].onlyWholeLine`, value);
            if (value) {
              this.plugin.settings.customReplacements[index].onlyAtStart = false;
            }
            await this.plugin.saveSettings();
            renderCustomReplacements();
          });
          toggle.toggleEl.style.margin = "0";
          if (replacement.onlyAtStart) {
            toggle.setDisabled(true);
            toggle.toggleEl.style.opacity = "0.5";
            toggle.toggleEl.style.pointerEvents = "none";
          }
          wholeToggleContainer.appendChild(toggle.toggleEl);
        });
        const buttonContainer = rowEl.createDiv({ cls: "flit-actions-column flit-button-container" });
        const upButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-nav-button",
          attr: { "aria-label": t("settings.customRules.moveUp") }
        });
        if (index === 0) {
          upButton.classList.add("disabled");
        }
        (0, import_obsidian10.setIcon)(upButton, "chevron-up");
        if (index > 0) {
          upButton.addEventListener("click", async () => {
            const temp = this.plugin.settings.customReplacements[index];
            this.plugin.settings.customReplacements[index] = this.plugin.settings.customReplacements[index - 1];
            this.plugin.settings.customReplacements[index - 1] = temp;
            await this.plugin.saveSettings();
            renderCustomReplacements();
          });
        }
        const downButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-nav-button",
          attr: { "aria-label": t("settings.customRules.moveDown") }
        });
        if (index === this.plugin.settings.customReplacements.length - 1) {
          downButton.classList.add("disabled");
        }
        (0, import_obsidian10.setIcon)(downButton, "chevron-down");
        if (index < this.plugin.settings.customReplacements.length - 1) {
          downButton.addEventListener("click", async () => {
            const temp = this.plugin.settings.customReplacements[index];
            this.plugin.settings.customReplacements[index] = this.plugin.settings.customReplacements[index + 1];
            this.plugin.settings.customReplacements[index + 1] = temp;
            await this.plugin.saveSettings();
            renderCustomReplacements();
          });
        }
        deleteButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-delete-button",
          attr: { "aria-label": t("settings.customRules.delete"), "type": "button" }
        });
        (0, import_obsidian10.setIcon)(deleteButton, "x");
        deleteButton.addEventListener("click", async () => {
          if (this.plugin.settings.customReplacements.length === 1) {
            this.plugin.settings.customReplacements[0] = {
              searchText: "",
              replaceText: "",
              enabled: true,
              onlyAtStart: false,
              onlyWholeLine: false
            };
          } else {
            this.plugin.settings.customReplacements.splice(index, 1);
          }
          await this.plugin.saveSettings();
          renderCustomReplacements();
        });
        updateButtonState = () => {
          const isLastEmptyEntry = this.plugin.settings.customReplacements.length === 1 && this.plugin.settings.customReplacements[0].searchText.trim() === "" && this.plugin.settings.customReplacements[0].replaceText.trim() === "";
          if (isLastEmptyEntry) {
            deleteButton.classList.add("disabled");
            deleteButton.removeAttribute("aria-label");
            deleteButton.title = "";
          } else {
            deleteButton.classList.remove("disabled");
            deleteButton.setAttribute("aria-label", "Remove");
            deleteButton.title = "Remove";
          }
          if (index === 0 || isLastEmptyEntry) {
            upButton.classList.add("disabled");
          } else {
            upButton.classList.remove("disabled");
          }
          if (index === this.plugin.settings.customReplacements.length - 1 || isLastEmptyEntry) {
            downButton.classList.add("disabled");
          } else {
            downButton.classList.remove("disabled");
          }
        };
        updateButtonState();
        updateRowAppearance();
      });
      const addButtonSetting = new import_obsidian10.Setting(customReplacementsContainer).addButton((button) => {
        button.setButtonText(t("settings.customRules.addReplacement")).onClick(async () => {
          const lastIndex = this.plugin.settings.customReplacements.length - 1;
          const lastEntry = this.plugin.settings.customReplacements[lastIndex];
          if (lastEntry.searchText.trim() === "" && lastEntry.replaceText.trim() === "") {
            if (!lastEntry.enabled) {
              this.plugin.settings.customReplacements[lastIndex].enabled = true;
              await this.plugin.saveSettings();
              renderCustomReplacements();
              setTimeout(() => {
                const textInputs = customReplacementsContainer.querySelectorAll('input[type="text"]:not([disabled])');
                if (textInputs.length >= 2) {
                  textInputs[textInputs.length - 2].focus();
                }
              }, 50);
            } else {
              const textInputs = customReplacementsContainer.querySelectorAll('input[type="text"]:not([disabled])');
              if (textInputs.length >= 2) {
                textInputs[textInputs.length - 2].focus();
              }
            }
            return;
          }
          this.plugin.settings.customReplacements.push({
            searchText: "",
            replaceText: "",
            onlyAtStart: false,
            onlyWholeLine: false,
            enabled: true
          });
          await this.plugin.saveSettings();
          renderCustomReplacements();
          setTimeout(() => {
            const textInputs = customReplacementsContainer.querySelectorAll('input[type="text"]:not([disabled])');
            if (textInputs.length >= 2) {
              textInputs[textInputs.length - 2].focus();
            }
          }, 50);
        });
      });
      addButtonSetting.settingEl.addClass("flit-add-replacement-button");
      addButtonSetting.settingEl.addClass("flit-master-disable-target");
      updateCustomReplacementUI();
    };
    renderCustomReplacements();
    this.containerEl.createEl("br");
    globalProcessingHeaderSetting = new import_obsidian10.Setting(this.containerEl).setName(t("settings.customRules.processingOrder.title")).setDesc("");
    globalProcessingHeaderSetting.settingEl.addClass("flit-section-header");
    processingOrderContainer = this.containerEl.createDiv({ cls: "flit-processing-order-container" });
    const applyAfterForbiddenSetting = new import_obsidian10.Setting(processingOrderContainer).setName(t("settings.customRules.processingOrder.applyAfterForbidden")).setDesc("");
    const applyAfterForbiddenDesc = applyAfterForbiddenSetting.descEl;
    applyAfterForbiddenDesc.appendText(t("settings.customRules.processingOrder.asSetInReplace.part1"));
    if (getCurrentLocale() === "ru") {
      applyAfterForbiddenDesc.appendText("\xAB" + t("settings.customRules.processingOrder.asSetInReplace.replaceCharacters") + "\xBB");
    } else {
      applyAfterForbiddenDesc.createEl("em", { text: t("settings.customRules.processingOrder.asSetInReplace.replaceCharacters") });
    }
    applyAfterForbiddenDesc.appendText(t("settings.customRules.processingOrder.asSetInReplace.part2"));
    applyAfterForbiddenSetting.addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.applyCustomRulesAfterForbiddenChars).onChange(async (value) => {
        this.plugin.settings.applyCustomRulesAfterForbiddenChars = value;
        this.plugin.debugLog("applyCustomRulesAfterForbiddenChars", value);
        await this.plugin.saveSettings();
      })
    );
    const updateMarkupToggleVisibility = () => {
      if (this.plugin.settings.enableStripMarkup) {
        markupToggleContainer.style.opacity = "";
        markupToggleContainer.style.pointerEvents = "auto";
        markupToggleSetting.setDisabled(false);
        if (markupToggle) {
          markupToggle.toggleEl.tabIndex = 0;
          markupToggle.toggleEl.removeAttribute("aria-disabled");
          markupToggle.toggleEl.style.pointerEvents = "";
        }
      } else {
        if (!processingOrderContainer.classList.contains("flit-master-disabled")) {
          markupToggleContainer.style.opacity = "0.5";
        } else {
          markupToggleContainer.style.opacity = "";
        }
        markupToggleContainer.style.pointerEvents = "none";
        markupToggleSetting.setDisabled(true);
        if (markupToggle) {
          markupToggle.toggleEl.tabIndex = -1;
          markupToggle.toggleEl.setAttribute("aria-disabled", "true");
          markupToggle.toggleEl.style.pointerEvents = "none";
        }
      }
    };
    markupToggleSetting = new import_obsidian10.Setting(processingOrderContainer).setName(t("settings.customRules.processingOrder.applyAfterMarkup")).setDesc("");
    const applyAfterMarkupDesc = markupToggleSetting.descEl;
    applyAfterMarkupDesc.appendText(t("settings.customRules.processingOrder.asSetInStrip.part1"));
    if (getCurrentLocale() === "ru") {
      applyAfterMarkupDesc.appendText("\xAB" + t("settings.customRules.processingOrder.asSetInStrip.stripMarkup") + "\xBB");
    } else {
      applyAfterMarkupDesc.createEl("em", { text: t("settings.customRules.processingOrder.asSetInStrip.stripMarkup") });
    }
    applyAfterMarkupDesc.appendText(t("settings.customRules.processingOrder.asSetInStrip.part2"));
    markupToggleSetting.addToggle((toggle) => {
      markupToggle = toggle;
      toggle.setValue(this.plugin.settings.applyCustomRulesAfterMarkupStripping).onChange(async (value) => {
        this.plugin.settings.applyCustomRulesAfterMarkupStripping = value;
        this.plugin.debugLog("applyCustomRulesAfterMarkupStripping", value);
        await this.plugin.saveSettings();
      });
      if (!this.plugin.settings.enableStripMarkup) {
        toggle.toggleEl.tabIndex = -1;
        toggle.toggleEl.setAttribute("aria-disabled", "true");
        toggle.toggleEl.style.pointerEvents = "none";
      }
    });
    markupToggleContainer = markupToggleSetting.settingEl;
    updateMarkupToggleVisibility();
    updateCustomReplacementUI();
  }
};

// src/settings/tab-safewords.ts
var import_obsidian11 = require("obsidian");
init_constants();
init_i18n();
var SafewordsTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
  }
  render() {
    const safewordsHeaderToggleSetting = new import_obsidian11.Setting(this.containerEl).setName(t("settings.safewords.enableSafewords.name")).setDesc("").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableSafewords).onChange(async (value) => {
        this.plugin.settings.enableSafewords = value;
        this.plugin.debugLog("enableSafewords", value);
        if (value && !this.plugin.settings.hasEnabledSafewords) {
          this.plugin.settings.safewords.forEach((safeword) => {
            safeword.enabled = true;
          });
          this.plugin.settings.hasEnabledSafewords = true;
        }
        await this.plugin.saveSettings();
        updateSafewordsUI();
        renderSafewords();
      });
    });
    safewordsHeaderToggleSetting.settingEl.addClass("flit-master-toggle");
    safewordsHeaderToggleSetting.settingEl.addClass("flit-no-border");
    const safewordsDescEl = this.containerEl.createEl("div", { cls: "setting-item-description" });
    const updateSafewordsDescriptionContent = () => {
      safewordsDescEl.empty();
      safewordsDescEl.createEl("span", { text: t("settings.safewords.enableSafewords.desc") });
    };
    updateSafewordsDescriptionContent();
    this.containerEl.createEl("br");
    const safewordsContainer = this.containerEl.createDiv({ cls: "flit-safewords-container" });
    const updateSafewordsUI = () => {
      this.updateInteractiveState(safewordsContainer, this.plugin.settings.enableSafewords);
      this.updateDisabledRowsAccessibility(safewordsContainer);
      const tableContainers = safewordsContainer.querySelectorAll(".flit-table-container");
      tableContainers.forEach((container) => {
        if (this.plugin.settings.enableSafewords) {
          container.classList.remove("flit-master-disabled");
        } else {
          container.classList.add("flit-master-disabled");
        }
      });
    };
    const renderSafewords = () => {
      safewordsContainer.empty();
      const existingAddButton = this.containerEl.querySelector(".flit-add-safeword-button");
      if (existingAddButton) existingAddButton.remove();
      const tableContainer = safewordsContainer.createEl("div", { cls: "flit-table-container flit-safeword-table-container" });
      const tableWrapper = tableContainer.createEl("div", { cls: "flit-table-wrapper" });
      const headerRow = tableWrapper.createEl("div", { cls: "flit-safeword-header" });
      const enableHeader = headerRow.createDiv({ cls: "flit-enable-column" });
      enableHeader.textContent = t("settings.safewords.headers.enable");
      const safewordHeader = headerRow.createDiv({ cls: "flit-text-column flit-safeword-input" });
      safewordHeader.textContent = t("settings.safewords.headers.safeword");
      const startOnlyHeader = headerRow.createDiv({ cls: "flit-toggle-column" });
      startOnlyHeader.textContent = t("settings.safewords.headers.onlyMatchStart");
      const wholeLineHeader = headerRow.createDiv({ cls: "flit-toggle-column" });
      wholeLineHeader.textContent = t("settings.safewords.headers.onlyMatchWhole");
      const caseSensitiveHeader = headerRow.createDiv({ cls: "flit-toggle-column" });
      caseSensitiveHeader.textContent = t("settings.safewords.headers.caseSensitive");
      const actionsHeader = headerRow.createDiv({ cls: "flit-actions-column" });
      actionsHeader.textContent = "";
      this.plugin.settings.safewords.forEach((safeword, index) => {
        const rowEl = tableWrapper.createEl("div", { cls: "flit-safeword-setting" });
        let deleteButton;
        let updateButtonState;
        const toggleContainer = rowEl.createDiv({ cls: "flit-enable-column" });
        const individualToggleSetting = new import_obsidian11.Setting(document.createElement("div"));
        individualToggleSetting.addToggle((toggle) => {
          toggle.setValue(safeword.enabled).onChange(async (value) => {
            this.plugin.settings.safewords[index].enabled = value;
            this.plugin.debugLog(`safewords[${index}].enabled`, value);
            await this.plugin.saveSettings();
            updateRowAppearance();
          });
          toggle.toggleEl.style.margin = "0";
          toggleContainer.appendChild(toggle.toggleEl);
        });
        const updateRowAppearance = () => {
          const isEnabled = this.plugin.settings.safewords[index].enabled;
          const masterEnabled = this.plugin.settings.enableSafewords;
          const shouldApplyInlineOpacity = masterEnabled;
          if (isEnabled) {
            rowEl.classList.remove("flit-row-disabled");
            input.style.opacity = "";
            input.style.pointerEvents = "";
            input.disabled = false;
            input.tabIndex = 0;
            input.removeAttribute("aria-disabled");
            startToggleContainer.style.opacity = "";
            startToggleContainer.style.pointerEvents = "";
            wholeToggleContainer.style.opacity = "";
            wholeToggleContainer.style.pointerEvents = "";
            caseToggleContainer.style.opacity = "";
            caseToggleContainer.style.pointerEvents = "";
            [startToggleContainer, wholeToggleContainer, caseToggleContainer].forEach((container) => {
              const toggleEls = container.querySelectorAll('input[type="checkbox"]');
              toggleEls.forEach((el) => {
                el.tabIndex = 0;
                el.removeAttribute("aria-disabled");
              });
            });
          } else {
            rowEl.classList.add("flit-row-disabled");
            input.style.opacity = shouldApplyInlineOpacity ? "0.5" : "";
            input.style.pointerEvents = "none";
            input.disabled = true;
            input.tabIndex = -1;
            input.setAttribute("aria-disabled", "true");
            startToggleContainer.style.opacity = shouldApplyInlineOpacity ? "0.5" : "";
            startToggleContainer.style.pointerEvents = "none";
            wholeToggleContainer.style.opacity = shouldApplyInlineOpacity ? "0.5" : "";
            wholeToggleContainer.style.pointerEvents = "none";
            caseToggleContainer.style.opacity = shouldApplyInlineOpacity ? "0.5" : "";
            caseToggleContainer.style.pointerEvents = "none";
            [startToggleContainer, wholeToggleContainer, caseToggleContainer].forEach((container) => {
              const toggleEls = container.querySelectorAll('input[type="checkbox"]');
              toggleEls.forEach((el) => {
                el.tabIndex = -1;
                el.setAttribute("aria-disabled", "true");
              });
            });
          }
        };
        const inputContainer = rowEl.createDiv({ cls: "flit-text-column flit-safeword-input" });
        const input = inputContainer.createEl("input", { type: "text" });
        input.placeholder = t("settings.replaceCharacters.emptyPlaceholder");
        input.value = safeword.text;
        input.addEventListener("input", async (e) => {
          const inputEl = e.target;
          let value = inputEl.value;
          const universalForbidden = UNIVERSAL_FORBIDDEN_CHARS;
          const windowsAndroidForbidden = WINDOWS_ANDROID_CHARS;
          let forbiddenChars = [...universalForbidden];
          if (this.plugin.settings.osPreset === "Windows") {
            forbiddenChars.push(...windowsAndroidForbidden);
          }
          let filteredValue = "";
          for (let i = 0; i < value.length; i++) {
            const char = value[i];
            if (char === "." && i === 0) {
              continue;
            }
            if (forbiddenChars.includes(char)) {
              continue;
            }
            filteredValue += char;
          }
          if (filteredValue !== value) {
            inputEl.value = filteredValue;
            const cursorPos = Math.min(inputEl.selectionStart || 0, filteredValue.length);
            inputEl.setSelectionRange(cursorPos, cursorPos);
          }
          this.plugin.settings.safewords[index].text = filteredValue;
          this.plugin.debugLog(`safewords[${index}].text`, this.plugin.settings.safewords[index].text);
          await this.plugin.saveSettings();
          updateButtonState();
        });
        const startToggleContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const startToggleSetting = new import_obsidian11.Setting(document.createElement("div"));
        startToggleSetting.addToggle((toggle) => {
          toggle.setValue(safeword.onlyAtStart).onChange(async (value) => {
            this.plugin.settings.safewords[index].onlyAtStart = value;
            this.plugin.debugLog(`safewords[${index}].onlyAtStart`, value);
            if (value) {
              this.plugin.settings.safewords[index].onlyWholeLine = false;
            }
            await this.plugin.saveSettings();
            renderSafewords();
          });
          toggle.toggleEl.style.margin = "0";
          if (safeword.onlyWholeLine) {
            toggle.setDisabled(true);
            toggle.toggleEl.style.opacity = "0.5";
            toggle.toggleEl.style.pointerEvents = "none";
          }
          startToggleContainer.appendChild(toggle.toggleEl);
        });
        const wholeToggleContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const wholeToggleSetting = new import_obsidian11.Setting(document.createElement("div"));
        wholeToggleSetting.addToggle((toggle) => {
          toggle.setValue(safeword.onlyWholeLine).onChange(async (value) => {
            this.plugin.settings.safewords[index].onlyWholeLine = value;
            this.plugin.debugLog(`safewords[${index}].onlyWholeLine`, value);
            if (value) {
              this.plugin.settings.safewords[index].onlyAtStart = false;
            }
            await this.plugin.saveSettings();
            renderSafewords();
          });
          toggle.toggleEl.style.margin = "0";
          if (safeword.onlyAtStart) {
            toggle.setDisabled(true);
            toggle.toggleEl.style.opacity = "0.5";
            toggle.toggleEl.style.pointerEvents = "none";
          }
          wholeToggleContainer.appendChild(toggle.toggleEl);
        });
        const caseToggleContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const caseToggleSetting = new import_obsidian11.Setting(document.createElement("div"));
        caseToggleSetting.addToggle((toggle) => {
          toggle.setValue(safeword.caseSensitive).onChange(async (value) => {
            this.plugin.settings.safewords[index].caseSensitive = value;
            this.plugin.debugLog(`safewords[${index}].caseSensitive`, value);
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          caseToggleContainer.appendChild(toggle.toggleEl);
        });
        const buttonContainer = rowEl.createDiv({ cls: "flit-actions-column flit-button-container" });
        const upButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-nav-button",
          attr: { "aria-label": t("settings.customRules.moveUp") }
        });
        if (index === 0) {
          upButton.classList.add("disabled");
        }
        (0, import_obsidian11.setIcon)(upButton, "chevron-up");
        if (index > 0) {
          upButton.addEventListener("click", async () => {
            const temp = this.plugin.settings.safewords[index];
            this.plugin.settings.safewords[index] = this.plugin.settings.safewords[index - 1];
            this.plugin.settings.safewords[index - 1] = temp;
            await this.plugin.saveSettings();
            renderSafewords();
          });
        }
        const downButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-nav-button",
          attr: { "aria-label": t("settings.customRules.moveDown") }
        });
        if (index === this.plugin.settings.safewords.length - 1) {
          downButton.classList.add("disabled");
        }
        (0, import_obsidian11.setIcon)(downButton, "chevron-down");
        if (index < this.plugin.settings.safewords.length - 1) {
          downButton.addEventListener("click", async () => {
            const temp = this.plugin.settings.safewords[index];
            this.plugin.settings.safewords[index] = this.plugin.settings.safewords[index + 1];
            this.plugin.settings.safewords[index + 1] = temp;
            await this.plugin.saveSettings();
            renderSafewords();
          });
        }
        deleteButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-delete-button",
          attr: { "aria-label": t("settings.customRules.delete"), "type": "button" }
        });
        (0, import_obsidian11.setIcon)(deleteButton, "x");
        deleteButton.addEventListener("click", async () => {
          if (this.plugin.settings.safewords.length === 1) {
            this.plugin.settings.safewords[0] = {
              text: "",
              enabled: true,
              onlyAtStart: false,
              onlyWholeLine: false,
              caseSensitive: false
            };
          } else {
            this.plugin.settings.safewords.splice(index, 1);
          }
          await this.plugin.saveSettings();
          renderSafewords();
        });
        updateButtonState = () => {
          const isLastEmptyEntry = this.plugin.settings.safewords.length === 1 && this.plugin.settings.safewords[0].text.trim() === "";
          if (isLastEmptyEntry) {
            deleteButton.classList.add("disabled");
            deleteButton.removeAttribute("aria-label");
            deleteButton.title = "";
          } else {
            deleteButton.classList.remove("disabled");
            deleteButton.setAttribute("aria-label", t("ariaLabels.remove"));
            deleteButton.title = t("ariaLabels.remove");
          }
          if (index === 0 || isLastEmptyEntry) {
            upButton.classList.add("disabled");
          } else {
            upButton.classList.remove("disabled");
          }
          if (index === this.plugin.settings.safewords.length - 1 || isLastEmptyEntry) {
            downButton.classList.add("disabled");
          } else {
            downButton.classList.remove("disabled");
          }
        };
        updateButtonState();
        updateRowAppearance();
      });
      const addButtonSetting = new import_obsidian11.Setting(safewordsContainer).addButton(
        (button) => button.setButtonText(t("settings.safewords.addButton")).onClick(async () => {
          const lastIndex = this.plugin.settings.safewords.length - 1;
          const lastEntry = this.plugin.settings.safewords[lastIndex];
          if (lastEntry.text.trim() === "") {
            if (!lastEntry.enabled) {
              this.plugin.settings.safewords[lastIndex].enabled = true;
              await this.plugin.saveSettings();
              renderSafewords();
              setTimeout(() => {
                const textInputs = safewordsContainer.querySelectorAll('input[type="text"]');
                if (textInputs.length > 0) {
                  textInputs[textInputs.length - 1].focus();
                }
              }, 0);
            } else {
              const textInputs = safewordsContainer.querySelectorAll('input[type="text"]');
              if (textInputs.length > 0) {
                textInputs[textInputs.length - 1].focus();
              }
            }
            return;
          }
          this.plugin.settings.safewords.push({
            text: "",
            onlyAtStart: false,
            onlyWholeLine: false,
            enabled: true,
            caseSensitive: false
          });
          await this.plugin.saveSettings();
          renderSafewords();
          setTimeout(() => {
            const textInputs = safewordsContainer.querySelectorAll('input[type="text"]');
            if (textInputs.length > 0) {
              textInputs[textInputs.length - 1].focus();
            }
          }, 0);
        })
      );
      addButtonSetting.settingEl.addClass("flit-add-safeword-button");
      updateSafewordsUI();
    };
    renderSafewords();
  }
};

// src/settings/tab-commands.ts
var import_obsidian12 = require("obsidian");
init_i18n();
var CommandsTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
  }
  render() {
    const ribbonHeaderSetting = new import_obsidian12.Setting(this.containerEl).setName(t("settings.commands.ribbon.title")).setDesc(t("settings.commands.ribbon.desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableRibbon).onChange(async (value) => {
        this.plugin.settings.enableRibbon = value;
        this.plugin.debugLog("enableRibbon", value);
        await this.plugin.saveSettings();
        updateRibbonUI();
      });
    });
    ribbonHeaderSetting.settingEl.addClass("flit-master-toggle");
    this.containerEl.createEl("br");
    const ribbonContainer = this.containerEl.createDiv();
    const updateRibbonUI = () => {
      if (this.plugin.settings.enableRibbon) {
        ribbonContainer.show();
      } else {
        ribbonContainer.hide();
      }
    };
    const ribbonCurrentSetting = new import_obsidian12.Setting(ribbonContainer).setName(t("commands.putFirstLineInTitle")).setDesc(t("commands.descriptions.renameActiveNoteEvenExcluded")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.ribbonVisibility.renameCurrentFile).onChange(async (value) => {
        this.plugin.settings.ribbonVisibility.renameCurrentFile = value;
        this.plugin.debugLog("ribbonVisibility.renameCurrentFile", value);
        await this.plugin.saveSettings();
      });
    });
    const ribbonCurrentIcon = ribbonCurrentSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(ribbonCurrentIcon, "file-pen");
    ribbonCurrentSetting.nameEl.insertBefore(ribbonCurrentIcon, ribbonCurrentSetting.nameEl.firstChild);
    const ribbonBulkSetting = new import_obsidian12.Setting(ribbonContainer).setName(t("commands.putFirstLineInTitleAllNotes")).setDesc(t("commands.descriptions.renameAllNotesExceptExcluded")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.ribbonVisibility.renameAllNotes).onChange(async (value) => {
        this.plugin.settings.ribbonVisibility.renameAllNotes = value;
        this.plugin.debugLog("ribbonVisibility.renameAllNotes", value);
        await this.plugin.saveSettings();
      });
    });
    const ribbonBulkIcon = ribbonBulkSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(ribbonBulkIcon, "file-stack");
    ribbonBulkSetting.nameEl.insertBefore(ribbonBulkIcon, ribbonBulkSetting.nameEl.firstChild);
    const ribbonToggleSetting = new import_obsidian12.Setting(ribbonContainer).setName(t("commands.toggleAutomaticRenaming")).setDesc("");
    const ribbonToggleDesc = ribbonToggleSetting.descEl;
    ribbonToggleDesc.appendText(t("commands.descriptions.toggleRenameSetting.part1"));
    if (getCurrentLocale() === "ru") {
      ribbonToggleDesc.appendText("\xAB" + t("commands.descriptions.toggleRenameSetting.renameNotes") + "\xBB");
    } else {
      ribbonToggleDesc.createEl("em", { text: t("commands.descriptions.toggleRenameSetting.renameNotes") });
    }
    ribbonToggleDesc.appendText(t("commands.descriptions.toggleRenameSetting.part2"));
    if (getCurrentLocale() === "ru") {
      ribbonToggleDesc.appendText("\xAB" + t("commands.descriptions.toggleRenameSetting.automatically") + "\xBB");
    } else {
      ribbonToggleDesc.createEl("em", { text: t("commands.descriptions.toggleRenameSetting.automatically") });
    }
    ribbonToggleDesc.appendText(t("commands.descriptions.toggleRenameSetting.part3"));
    if (getCurrentLocale() === "ru") {
      ribbonToggleDesc.appendText("\xAB" + t("commands.descriptions.toggleRenameSetting.manually") + "\xBB");
    } else {
      ribbonToggleDesc.createEl("em", { text: t("commands.descriptions.toggleRenameSetting.manually") });
    }
    ribbonToggleDesc.appendText(t("commands.descriptions.toggleRenameSetting.part4"));
    ribbonToggleSetting.addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.ribbonVisibility.toggleAutomaticRenaming).onChange(async (value) => {
        this.plugin.settings.ribbonVisibility.toggleAutomaticRenaming = value;
        this.plugin.debugLog("ribbonVisibility.toggleAutomaticRenaming", value);
        await this.plugin.saveSettings();
      });
    });
    const ribbonToggleIcon = ribbonToggleSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(ribbonToggleIcon, "file-cog");
    ribbonToggleSetting.nameEl.insertBefore(ribbonToggleIcon, ribbonToggleSetting.nameEl.firstChild);
    updateRibbonUI();
    const commandPaletteHeaderSetting = new import_obsidian12.Setting(this.containerEl).setName(t("settings.commands.palette.title")).setDesc(t("settings.commands.palette.desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableCommandPalette).onChange(async (value) => {
        this.plugin.settings.enableCommandPalette = value;
        this.plugin.debugLog("enableCommandPalette", value);
        await this.plugin.saveSettings();
        updateCommandPaletteUI();
      });
    });
    commandPaletteHeaderSetting.settingEl.addClass("flit-master-toggle");
    this.containerEl.createEl("br");
    const commandPaletteContainer = this.containerEl.createDiv();
    commandPaletteContainer.addClass("flit-master-disable-target");
    const updateCommandPaletteUI = () => {
      if (this.plugin.settings.enableCommandPalette) {
        commandPaletteContainer.show();
      } else {
        commandPaletteContainer.hide();
      }
    };
    const setting1 = new import_obsidian12.Setting(commandPaletteContainer).setName(t("commands.putFirstLineInTitle")).setDesc(t("commands.descriptions.renameActiveNoteEvenExcluded")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandPaletteVisibility.renameCurrentFile).onChange(async (value) => {
        this.plugin.settings.commandPaletteVisibility.renameCurrentFile = value;
        this.plugin.debugLog("commandPaletteVisibility.renameCurrentFile", value);
        await this.plugin.saveSettings();
      })
    );
    const icon1 = setting1.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(icon1, "file-pen");
    setting1.nameEl.insertBefore(icon1, setting1.nameEl.firstChild);
    const setting2 = new import_obsidian12.Setting(commandPaletteContainer).setName(t("commands.putFirstLineInTitleUnlessExcluded")).setDesc(t("commands.descriptions.renameActiveNoteUnlessExcluded")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandPaletteVisibility.renameCurrentFileUnlessExcluded).onChange(async (value) => {
        this.plugin.settings.commandPaletteVisibility.renameCurrentFileUnlessExcluded = value;
        this.plugin.debugLog("commandPaletteVisibility.renameCurrentFileUnlessExcluded", value);
        await this.plugin.saveSettings();
      })
    );
    const icon2 = setting2.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(icon2, "file-pen");
    setting2.nameEl.insertBefore(icon2, setting2.nameEl.firstChild);
    const setting3 = new import_obsidian12.Setting(commandPaletteContainer).setName(t("commands.putFirstLineInTitleAllNotes")).setDesc(t("commands.descriptions.renameAllNotesExceptExcluded")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandPaletteVisibility.renameAllFiles).onChange(async (value) => {
        this.plugin.settings.commandPaletteVisibility.renameAllFiles = value;
        this.plugin.debugLog("commandPaletteVisibility.renameAllFiles", value);
        await this.plugin.saveSettings();
      })
    );
    const icon3 = setting3.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(icon3, "file-stack");
    setting3.nameEl.insertBefore(icon3, setting3.nameEl.firstChild);
    const setting8 = new import_obsidian12.Setting(commandPaletteContainer).setName(t("commands.toggleAutomaticRenaming")).setDesc("");
    const setting8Desc = setting8.descEl;
    setting8Desc.appendText(t("commands.descriptions.toggleRenameSetting.part1"));
    if (getCurrentLocale() === "ru") {
      setting8Desc.appendText("\xAB" + t("commands.descriptions.toggleRenameSetting.renameNotes") + "\xBB");
    } else {
      setting8Desc.createEl("em", { text: t("commands.descriptions.toggleRenameSetting.renameNotes") });
    }
    setting8Desc.appendText(t("commands.descriptions.toggleRenameSetting.part2"));
    if (getCurrentLocale() === "ru") {
      setting8Desc.appendText("\xAB" + t("commands.descriptions.toggleRenameSetting.automatically") + "\xBB");
    } else {
      setting8Desc.createEl("em", { text: t("commands.descriptions.toggleRenameSetting.automatically") });
    }
    setting8Desc.appendText(t("commands.descriptions.toggleRenameSetting.part3"));
    if (getCurrentLocale() === "ru") {
      setting8Desc.appendText("\xAB" + t("commands.descriptions.toggleRenameSetting.manually") + "\xBB");
    } else {
      setting8Desc.createEl("em", { text: t("commands.descriptions.toggleRenameSetting.manually") });
    }
    setting8Desc.appendText(t("commands.descriptions.toggleRenameSetting.part4"));
    setting8.addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandPaletteVisibility.toggleAutomaticRenaming).onChange(async (value) => {
        this.plugin.settings.commandPaletteVisibility.toggleAutomaticRenaming = value;
        this.plugin.debugLog("commandPaletteVisibility.toggleAutomaticRenaming", value);
        await this.plugin.saveSettings();
      })
    );
    const icon8 = setting8.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(icon8, "file-cog");
    setting8.nameEl.insertBefore(icon8, setting8.nameEl.firstChild);
    const setting4 = new import_obsidian12.Setting(commandPaletteContainer).setName(t("commands.disableRenamingForNote")).setDesc(t("commands.descriptions.excludeActiveNote")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandPaletteVisibility.disableRenaming).onChange(async (value) => {
        this.plugin.settings.commandPaletteVisibility.disableRenaming = value;
        this.plugin.debugLog("commandPaletteVisibility.disableRenaming", value);
        await this.plugin.saveSettings();
      })
    );
    const icon4 = setting4.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(icon4, "square-x");
    setting4.nameEl.insertBefore(icon4, setting4.nameEl.firstChild);
    const setting5 = new import_obsidian12.Setting(commandPaletteContainer).setName(t("commands.enableRenamingForNote")).setDesc(t("commands.descriptions.stopExcludingActiveNote")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandPaletteVisibility.enableRenaming).onChange(async (value) => {
        this.plugin.settings.commandPaletteVisibility.enableRenaming = value;
        this.plugin.debugLog("commandPaletteVisibility.enableRenaming", value);
        await this.plugin.saveSettings();
      })
    );
    const icon5 = setting5.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(icon5, "square-check");
    setting5.nameEl.insertBefore(icon5, setting5.nameEl.firstChild);
    const setting6 = new import_obsidian12.Setting(commandPaletteContainer).setName(t("commands.addSafeInternalLink")).setDesc("");
    const setting6Desc = setting6.descEl;
    setting6Desc.appendText(t("commands.descriptions.createLinkWithForbiddenChars.part1"));
    if (getCurrentLocale() === "ru") {
      setting6Desc.appendText("\xAB" + t("commands.descriptions.createLinkWithForbiddenChars.replaceCharacters") + "\xBB");
    } else {
      setting6Desc.createEl("em", { text: t("commands.descriptions.createLinkWithForbiddenChars.replaceCharacters") });
    }
    setting6Desc.appendText(t("commands.descriptions.createLinkWithForbiddenChars.part2"));
    setting6.addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.addSafeInternalLink).onChange(async (value) => {
        this.plugin.settings.commandVisibility.addSafeInternalLink = value;
        this.plugin.debugLog("commandVisibility.addSafeInternalLink", value);
        await this.plugin.saveSettings();
      })
    );
    const icon6 = setting6.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(icon6, "link");
    setting6.nameEl.insertBefore(icon6, setting6.nameEl.firstChild);
    const setting7 = new import_obsidian12.Setting(commandPaletteContainer).setName(t("commands.addSafeInternalLinkWithCaption")).setDesc("");
    const setting7Desc = setting7.descEl;
    setting7Desc.appendText(t("commands.descriptions.createLinkWithValidPath.part1"));
    if (getCurrentLocale() === "ru") {
      setting7Desc.appendText("\xAB" + t("commands.descriptions.createLinkWithValidPath.replaceCharacters") + "\xBB");
    } else {
      setting7Desc.createEl("em", { text: t("commands.descriptions.createLinkWithValidPath.replaceCharacters") });
    }
    setting7Desc.appendText(t("commands.descriptions.createLinkWithValidPath.part2"));
    setting7.addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.addSafeInternalLinkWithCaption).onChange(async (value) => {
        this.plugin.settings.commandVisibility.addSafeInternalLinkWithCaption = value;
        this.plugin.debugLog("commandVisibility.addSafeInternalLinkWithCaption", value);
        await this.plugin.saveSettings();
      })
    );
    const icon7 = setting7.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(icon7, "link");
    setting7.nameEl.insertBefore(icon7, setting7.nameEl.firstChild);
    updateCommandPaletteUI();
    let fileCommandsExpanded = true;
    let folderCommandsExpanded = true;
    let tagCommandsExpanded = true;
    let vaultSearchCommandsExpanded = true;
    const fileHeaderSetting = new import_obsidian12.Setting(this.containerEl).setName(t("settings.commands.file.title")).setDesc(t("settings.commands.file.desc")).addToggle((toggle) => {
      toggle.setValue(fileCommandsExpanded).onChange(async (value) => {
        fileCommandsExpanded = value;
        updateFileUI();
      });
    });
    fileHeaderSetting.settingEl.addClass("flit-master-toggle");
    this.containerEl.createEl("br");
    const fileContainer = this.containerEl.createDiv();
    fileContainer.addClass("flit-master-disable-target");
    const updateFileUI = () => {
      if (fileCommandsExpanded) {
        fileContainer.show();
      } else {
        fileContainer.hide();
      }
    };
    const filePutFirstLineSetting = new import_obsidian12.Setting(fileContainer).setName(t("commands.putFirstLineInTitle")).setDesc(t("commands.descriptions.renameNoteEvenExcluded")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.filePutFirstLineInTitle).onChange(async (value) => {
        this.plugin.settings.commandVisibility.filePutFirstLineInTitle = value;
        this.plugin.debugLog("commandVisibility.filePutFirstLineInTitle", value);
        await this.plugin.saveSettings();
      })
    );
    const fileIcon = filePutFirstLineSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(fileIcon, "file-pen");
    filePutFirstLineSetting.nameEl.insertBefore(fileIcon, filePutFirstLineSetting.nameEl.firstChild);
    const fileDisableSetting = new import_obsidian12.Setting(fileContainer).setName(t("commands.disableRenamingForNote")).setDesc(t("commands.descriptions.excludeNote")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.fileExclude).onChange(async (value) => {
        this.plugin.settings.commandVisibility.fileExclude = value;
        this.plugin.debugLog("commandVisibility.fileExclude", value);
        await this.plugin.saveSettings();
      })
    );
    const fileDisableIcon = fileDisableSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(fileDisableIcon, "square-x");
    fileDisableSetting.nameEl.insertBefore(fileDisableIcon, fileDisableSetting.nameEl.firstChild);
    const fileEnableSetting = new import_obsidian12.Setting(fileContainer).setName(t("commands.enableRenamingForNote")).setDesc(t("commands.descriptions.stopExcludingNote")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.fileStopExcluding).onChange(async (value) => {
        this.plugin.settings.commandVisibility.fileStopExcluding = value;
        this.plugin.debugLog("commandVisibility.fileStopExcluding", value);
        await this.plugin.saveSettings();
      })
    );
    const fileEnableIcon = fileEnableSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(fileEnableIcon, "square-check");
    fileEnableSetting.nameEl.insertBefore(fileEnableIcon, fileEnableSetting.nameEl.firstChild);
    const folderHeaderSetting = new import_obsidian12.Setting(this.containerEl).setName(t("settings.commands.folder.title")).setDesc(t("settings.commands.folder.desc")).addToggle((toggle) => {
      toggle.setValue(folderCommandsExpanded).onChange(async (value) => {
        folderCommandsExpanded = value;
        updateFolderUI();
      });
    });
    folderHeaderSetting.settingEl.addClass("flit-master-toggle");
    this.containerEl.createEl("br");
    const folderContainer = this.containerEl.createDiv();
    folderContainer.addClass("flit-master-disable-target");
    const updateFolderUI = () => {
      if (folderCommandsExpanded) {
        folderContainer.show();
      } else {
        folderContainer.hide();
      }
    };
    const folderPutFirstLineSetting = new import_obsidian12.Setting(folderContainer).setName(t("commands.putFirstLineInTitle")).setDesc(t("commands.descriptions.renameAllNotesInFolder")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.folderPutFirstLineInTitle).onChange(async (value) => {
        this.plugin.settings.commandVisibility.folderPutFirstLineInTitle = value;
        this.plugin.debugLog("commandVisibility.folderPutFirstLineInTitle", value);
        await this.plugin.saveSettings();
      })
    );
    const folderIcon = folderPutFirstLineSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(folderIcon, "folder-pen");
    folderPutFirstLineSetting.nameEl.insertBefore(folderIcon, folderPutFirstLineSetting.nameEl.firstChild);
    const folderDisableSetting = new import_obsidian12.Setting(folderContainer).setName(t("commands.disableRenamingInFolder")).setDesc(t("commands.descriptions.excludeFolder")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.folderExclude).onChange(async (value) => {
        this.plugin.settings.commandVisibility.folderExclude = value;
        this.plugin.debugLog("commandVisibility.folderExclude", value);
        await this.plugin.saveSettings();
      })
    );
    const folderDisableIcon = folderDisableSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(folderDisableIcon, "square-x");
    folderDisableSetting.nameEl.insertBefore(folderDisableIcon, folderDisableSetting.nameEl.firstChild);
    const folderEnableSetting = new import_obsidian12.Setting(folderContainer).setName(t("commands.enableRenamingInFolder")).setDesc(t("commands.descriptions.stopExcludingFolder")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.folderStopExcluding).onChange(async (value) => {
        this.plugin.settings.commandVisibility.folderStopExcluding = value;
        this.plugin.debugLog("commandVisibility.folderStopExcluding", value);
        await this.plugin.saveSettings();
      })
    );
    const folderEnableIcon = folderEnableSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(folderEnableIcon, "square-check");
    folderEnableSetting.nameEl.insertBefore(folderEnableIcon, folderEnableSetting.nameEl.firstChild);
    const tagHeaderSetting = new import_obsidian12.Setting(this.containerEl).setName(t("settings.commands.tag.title")).setDesc(t("settings.commands.tag.desc")).addToggle((toggle) => {
      toggle.setValue(tagCommandsExpanded).onChange(async (value) => {
        tagCommandsExpanded = value;
        updateTagUI();
      });
    });
    tagHeaderSetting.settingEl.addClass("flit-master-toggle");
    this.containerEl.createEl("br");
    const tagContainer = this.containerEl.createDiv();
    tagContainer.addClass("flit-master-disable-target");
    const updateTagUI = () => {
      if (tagCommandsExpanded) {
        tagContainer.show();
      } else {
        tagContainer.hide();
      }
    };
    const tagPutFirstLineSetting = new import_obsidian12.Setting(tagContainer).setName(t("commands.putFirstLineInTitle")).setDesc(t("commands.descriptions.renameAllNotesWithTag")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.tagPutFirstLineInTitle).onChange(async (value) => {
        this.plugin.settings.commandVisibility.tagPutFirstLineInTitle = value;
        this.plugin.debugLog("commandVisibility.tagPutFirstLineInTitle", value);
        await this.plugin.saveSettings();
      })
    );
    const tagIcon = tagPutFirstLineSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(tagIcon, "file-pen");
    tagPutFirstLineSetting.nameEl.insertBefore(tagIcon, tagPutFirstLineSetting.nameEl.firstChild);
    const tagDisableSetting = new import_obsidian12.Setting(tagContainer).setName(t("commands.disableRenamingForTag")).setDesc(t("commands.descriptions.excludeTag")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.tagExclude).onChange(async (value) => {
        this.plugin.settings.commandVisibility.tagExclude = value;
        this.plugin.debugLog("commandVisibility.tagExclude", value);
        await this.plugin.saveSettings();
      })
    );
    const tagDisableIcon = tagDisableSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(tagDisableIcon, "square-x");
    tagDisableSetting.nameEl.insertBefore(tagDisableIcon, tagDisableSetting.nameEl.firstChild);
    const tagEnableSetting = new import_obsidian12.Setting(tagContainer).setName(t("commands.enableRenamingForTag")).setDesc(t("commands.descriptions.stopExcludingTag")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.tagStopExcluding).onChange(async (value) => {
        this.plugin.settings.commandVisibility.tagStopExcluding = value;
        this.plugin.debugLog("commandVisibility.tagStopExcluding", value);
        await this.plugin.saveSettings();
      })
    );
    const tagEnableIcon = tagEnableSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(tagEnableIcon, "square-check");
    tagEnableSetting.nameEl.insertBefore(tagEnableIcon, tagEnableSetting.nameEl.firstChild);
    const vaultSearchHeaderSetting = new import_obsidian12.Setting(this.containerEl).setName(t("settings.commands.search.title")).setDesc(t("settings.commands.search.desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableVaultSearchContextMenu).onChange(async (value) => {
        this.plugin.settings.enableVaultSearchContextMenu = value;
        this.plugin.debugLog("enableVaultSearchContextMenu", value);
        await this.plugin.saveSettings();
        updateVaultSearchUI();
      });
    });
    vaultSearchHeaderSetting.settingEl.addClass("flit-master-toggle");
    this.containerEl.createEl("br");
    const vaultSearchContainer = this.containerEl.createDiv({ cls: "flit-vault-search-container" });
    vaultSearchContainer.addClass("flit-master-disable-target");
    const updateVaultSearchUI = () => {
      if (this.plugin.settings.enableVaultSearchContextMenu) {
        vaultSearchContainer.show();
      } else {
        vaultSearchContainer.hide();
      }
    };
    const vaultSearchPutFirstLineSetting = new import_obsidian12.Setting(vaultSearchContainer).setName(t("commands.putFirstLineInTitle")).setDesc(t("commands.descriptions.renameAllNotesInSearchResults")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.vaultSearchContextMenuVisibility.putFirstLineInTitle).onChange(async (value) => {
        this.plugin.settings.vaultSearchContextMenuVisibility.putFirstLineInTitle = value;
        this.plugin.debugLog("vaultSearchContextMenuVisibility.putFirstLineInTitle", value);
        await this.plugin.saveSettings();
      })
    );
    const vaultSearchIcon = vaultSearchPutFirstLineSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(vaultSearchIcon, "file-pen");
    vaultSearchPutFirstLineSetting.nameEl.insertBefore(vaultSearchIcon, vaultSearchPutFirstLineSetting.nameEl.firstChild);
    const vaultSearchDisableSetting = new import_obsidian12.Setting(vaultSearchContainer).setName(t("commands.disableRenaming")).setDesc(t("commands.descriptions.excludeAllNotesInSearchResults")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.vaultSearchContextMenuVisibility.disable).onChange(async (value) => {
        this.plugin.settings.vaultSearchContextMenuVisibility.disable = value;
        this.plugin.debugLog("vaultSearchContextMenuVisibility.disable", value);
        await this.plugin.saveSettings();
      })
    );
    const vaultSearchDisableIcon = vaultSearchDisableSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(vaultSearchDisableIcon, "square-x");
    vaultSearchDisableSetting.nameEl.insertBefore(vaultSearchDisableIcon, vaultSearchDisableSetting.nameEl.firstChild);
    const vaultSearchEnableSetting = new import_obsidian12.Setting(vaultSearchContainer).setName(t("commands.enableRenaming")).setDesc(t("commands.descriptions.stopExcludingAllNotesInSearchResults")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.vaultSearchContextMenuVisibility.enable).onChange(async (value) => {
        this.plugin.settings.vaultSearchContextMenuVisibility.enable = value;
        this.plugin.debugLog("vaultSearchContextMenuVisibility.enable", value);
        await this.plugin.saveSettings();
      })
    );
    const vaultSearchEnableIcon = vaultSearchEnableSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian12.setIcon)(vaultSearchEnableIcon, "square-check");
    vaultSearchEnableSetting.nameEl.insertBefore(vaultSearchEnableIcon, vaultSearchEnableSetting.nameEl.firstChild);
    updateFileUI();
    updateFolderUI();
    updateTagUI();
    updateVaultSearchUI();
  }
};

// src/settings/tab-miscellaneous.ts
var import_obsidian13 = require("obsidian");
init_constants();
init_modals();
init_utils();
init_i18n();
var MiscellaneousTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
    this.conditionalSettings = [];
    this.plugin.updateAutomaticRenameVisibility = this.updateAutomaticRenameVisibility.bind(this);
  }
  render() {
    const charCountSetting = new import_obsidian13.Setting(this.containerEl).setName(t("settings.miscellaneous.charCount.name")).setDesc("");
    const charCountDesc = charCountSetting.descEl;
    charCountDesc.appendText(t("settings.miscellaneous.charCount.desc"));
    charCountDesc.createEl("br");
    charCountDesc.createEl("small").createEl("strong", { text: t("settings.miscellaneous.charCount.default") });
    const charCountContainer = charCountSetting.controlEl.createDiv({ cls: "flit-char-text-input-container" });
    const charCountRestoreButton = charCountContainer.createEl("button", {
      cls: "clickable-icon flit-restore-icon",
      attr: { "aria-label": t("ariaLabels.restoreDefault") }
    });
    (0, import_obsidian13.setIcon)(charCountRestoreButton, "rotate-ccw");
    const sliderDiv = charCountContainer.createDiv();
    charCountSetting.addSlider((slider) => {
      slider.setLimits(1, 255, 1).setValue(this.plugin.settings.charCount).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.charCount = value;
        this.plugin.debugLog("charCount", value);
        await this.plugin.saveSettings();
      });
      sliderDiv.appendChild(slider.sliderEl);
    });
    charCountRestoreButton.addEventListener("click", async () => {
      this.plugin.settings.charCount = DEFAULT_SETTINGS.charCount;
      this.plugin.debugLog("charCount", this.plugin.settings.charCount);
      await this.plugin.saveSettings();
      const sliderInput = sliderDiv.querySelector('input[type="range"]');
      if (sliderInput) {
        sliderInput.value = String(DEFAULT_SETTINGS.charCount);
        sliderInput.dispatchEvent(new Event("input", { bubbles: true }));
      }
    });
    const notificationSetting = new import_obsidian13.Setting(this.containerEl).setName(t("settings.miscellaneous.notificationMode.name")).setDesc(t("settings.miscellaneous.notificationMode.desc"));
    notificationSetting.addDropdown(
      (dropdown2) => dropdown2.addOption("Always", t("settings.miscellaneous.notificationMode.always")).addOption("On title change", t("settings.miscellaneous.notificationMode.onTitleChange")).addOption("Never", t("settings.miscellaneous.notificationMode.never")).setValue(this.plugin.settings.manualNotificationMode).onChange(async (value) => {
        this.plugin.settings.manualNotificationMode = value;
        this.plugin.debugLog("manualNotificationMode", value);
        await this.plugin.saveSettings();
      })
    );
    const cardLinkSetting = new import_obsidian13.Setting(this.containerEl).setName(t("settings.miscellaneous.grabCardLink.name")).setDesc("");
    const cardLinkDesc = cardLinkSetting.descEl;
    cardLinkDesc.appendText(t("settings.miscellaneous.grabCardLink.desc.part1"));
    cardLinkDesc.createEl("a", {
      text: "Auto Card Link",
      href: "obsidian://show-plugin?id=auto-card-link"
    });
    cardLinkDesc.appendText(t("settings.miscellaneous.grabCardLink.desc.part2"));
    cardLinkDesc.createEl("a", {
      text: "Link Embed",
      href: "obsidian://show-plugin?id=obsidian-link-embed"
    });
    cardLinkDesc.appendText(t("settings.miscellaneous.grabCardLink.desc.part3"));
    cardLinkSetting.addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.grabTitleFromCardLink).onChange(async (value) => {
        this.plugin.settings.grabTitleFromCardLink = value;
        this.plugin.debugLog("grabTitleFromCardLink", value);
        await this.plugin.saveSettings();
      })
    );
    const newNoteDelaySetting = new import_obsidian13.Setting(this.containerEl).setName(t("settings.miscellaneous.newNoteDelay.name")).setDesc(t("settings.miscellaneous.newNoteDelay.desc"));
    const newNoteDelayContainer = newNoteDelaySetting.controlEl.createDiv({ cls: "flit-char-text-input-container" });
    const newNoteDelayRestoreButton = newNoteDelayContainer.createEl("button", {
      cls: "clickable-icon flit-restore-icon",
      attr: { "aria-label": t("ariaLabels.restoreDefault") }
    });
    (0, import_obsidian13.setIcon)(newNoteDelayRestoreButton, "rotate-ccw");
    const newNoteDelaySliderDiv = newNoteDelayContainer.createDiv();
    newNoteDelaySetting.addSlider((slider) => {
      slider.setLimits(0, 5e3, 50).setValue(this.plugin.settings.newNoteDelay).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.newNoteDelay = value;
        this.plugin.debugLog("newNoteDelay", value);
        await this.plugin.saveSettings();
      });
      newNoteDelaySliderDiv.appendChild(slider.sliderEl);
    });
    newNoteDelayRestoreButton.addEventListener("click", async () => {
      this.plugin.settings.newNoteDelay = DEFAULT_SETTINGS.newNoteDelay;
      this.plugin.debugLog("newNoteDelay", this.plugin.settings.newNoteDelay);
      await this.plugin.saveSettings();
      const sliderInput = newNoteDelaySliderDiv.querySelector('input[type="range"]');
      if (sliderInput) {
        sliderInput.value = String(DEFAULT_SETTINGS.newNoteDelay);
        sliderInput.dispatchEvent(new Event("input", { bubbles: true }));
      }
    });
    const contentReadMethodSetting = new import_obsidian13.Setting(this.containerEl).setName(t("settings.miscellaneous.contentReadMethod.name")).setDesc(t("settings.miscellaneous.contentReadMethod.desc"));
    const contentReadContainer = contentReadMethodSetting.controlEl.createDiv({ cls: "flit-content-read-container" });
    contentReadContainer.style.display = "flex";
    contentReadContainer.style.gap = "10px";
    const contentReadRestoreButton = contentReadContainer.createEl("button", {
      attr: { "aria-label": t("ariaLabels.restoreDefaultContentRead") },
      cls: "clickable-icon flit-restore-button"
    });
    (0, import_obsidian13.setIcon)(contentReadRestoreButton, "rotate-ccw");
    const dropdown = contentReadContainer.createEl("select", { cls: "dropdown" });
    dropdown.createEl("option", { value: "Editor", text: t("settings.miscellaneous.contentReadMethod.editor") });
    dropdown.createEl("option", { value: "Cache", text: t("settings.miscellaneous.contentReadMethod.cache") });
    dropdown.createEl("option", { value: "File", text: t("settings.miscellaneous.contentReadMethod.file") });
    dropdown.value = this.plugin.settings.fileReadMethod;
    contentReadRestoreButton.addEventListener("click", async () => {
      dropdown.value = DEFAULT_SETTINGS.fileReadMethod;
      this.plugin.settings.fileReadMethod = DEFAULT_SETTINGS.fileReadMethod;
      this.plugin.debugLog("fileReadMethod", this.plugin.settings.fileReadMethod);
      await this.plugin.saveSettings();
      this.updateAutomaticRenameVisibility();
    });
    dropdown.addEventListener("change", async (e) => {
      const newMode = e.target.value;
      this.plugin.settings.fileReadMethod = newMode;
      this.plugin.debugLog("fileReadMethod", this.plugin.settings.fileReadMethod);
      await this.plugin.saveSettings();
      this.updateAutomaticRenameVisibility();
    });
    const contentReadSubSettingsContainer = this.containerEl.createDiv("flit-sub-settings");
    const checkIntervalSetting = new import_obsidian13.Setting(contentReadSubSettingsContainer).setName(t("settings.miscellaneous.checkInterval.name")).setDesc(t("settings.miscellaneous.checkInterval.desc"));
    const checkIntervalContainer = checkIntervalSetting.controlEl.createDiv({ cls: "flit-char-text-input-container" });
    const checkIntervalRestoreButton = checkIntervalContainer.createEl("button", {
      cls: "clickable-icon flit-restore-icon",
      attr: { "aria-label": t("ariaLabels.restoreDefault") }
    });
    (0, import_obsidian13.setIcon)(checkIntervalRestoreButton, "rotate-ccw");
    const checkIntervalTextInput = checkIntervalContainer.createEl("input", { type: "text", cls: "flit-char-text-input" });
    checkIntervalTextInput.placeholder = t("settings.replaceCharacters.emptyPlaceholder");
    checkIntervalTextInput.style.width = "120px";
    checkIntervalTextInput.value = String(this.plugin.settings.checkInterval);
    checkIntervalRestoreButton.addEventListener("click", async () => {
      var _a;
      this.plugin.settings.checkInterval = DEFAULT_SETTINGS.checkInterval;
      checkIntervalTextInput.value = String(DEFAULT_SETTINGS.checkInterval);
      this.plugin.debugLog("checkInterval", this.plugin.settings.checkInterval);
      await this.plugin.saveSettings();
      (_a = this.plugin.editorLifecycle) == null ? void 0 : _a.initializeCheckingSystem();
    });
    checkIntervalTextInput.addEventListener("input", async (e) => {
      var _a, _b;
      const input = e.target;
      let value = input.value;
      value = value.replace(/\D/g, "");
      if (value.length > 4) {
        value = value.slice(0, 4);
      }
      if (value === "") {
        input.value = "";
        this.plugin.settings.checkInterval = DEFAULT_SETTINGS.checkInterval;
        this.plugin.debugLog("checkInterval", this.plugin.settings.checkInterval);
        await this.plugin.saveSettings();
        (_a = this.plugin.editorLifecycle) == null ? void 0 : _a.initializeCheckingSystem();
        return;
      }
      const numValue = parseInt(value);
      input.value = String(numValue);
      this.plugin.settings.checkInterval = numValue;
      this.plugin.debugLog("checkInterval", this.plugin.settings.checkInterval);
      await this.plugin.saveSettings();
      (_b = this.plugin.editorLifecycle) == null ? void 0 : _b.initializeCheckingSystem();
    });
    this.conditionalSettings = [
      checkIntervalSetting
    ];
    let debugSubSettingsContainer;
    const updateDebugSubOptionVisibility = () => {
      if (this.plugin.settings.verboseLogging) {
        debugSubSettingsContainer.style.display = "";
      } else {
        debugSubSettingsContainer.style.display = "none";
      }
    };
    new import_obsidian13.Setting(this.containerEl).setName(t("settings.miscellaneous.debug.name")).setDesc(t("settings.miscellaneous.debug.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.verboseLogging).onChange(async (value) => {
        this.plugin.debugLog("verboseLogging", value);
        this.plugin.settings.verboseLogging = value;
        if (value) {
          this.plugin.settings.debugEnabledTimestamp = this.plugin.getCurrentTimestamp();
        }
        await this.plugin.saveSettings();
        updateDebugSubOptionVisibility();
        if (value) {
          this.plugin.outputAllSettings();
        }
      })
    );
    debugSubSettingsContainer = this.containerEl.createDiv("flit-sub-settings");
    const debugContentSetting = new import_obsidian13.Setting(debugSubSettingsContainer).setName(t("settings.miscellaneous.debugOutputContent.name")).setDesc(t("settings.miscellaneous.debugOutputContent.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.debugOutputFullContent).onChange(async (value) => {
        this.plugin.settings.debugOutputFullContent = value;
        this.plugin.debugLog("debugOutputFullContent", value);
        await this.plugin.saveSettings();
      })
    );
    updateDebugSubOptionVisibility();
    new import_obsidian13.Setting(this.containerEl).setName(t("settings.miscellaneous.clearSettings.name")).setDesc(t("settings.miscellaneous.clearSettings.desc")).addButton((button) => {
      button.setButtonText(t("modals.buttons.clearSettings")).setWarning().onClick(async () => {
        new ClearSettingsModal(this.plugin.app, this.plugin, async () => {
          this.plugin.settings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
          this.plugin.settings.scopeStrategy = "Don't rename in...";
          this.plugin.settings.hasShownFirstTimeNotice = true;
          this.plugin.settings.lastUsageDate = this.plugin.getTodayDateString();
          await this.plugin.saveSettings();
          verboseLog(this.plugin, `Showing notice: ${t("notifications.settingsCleared")}`);
          new import_obsidian13.Notice(t("notifications.settingsCleared"));
          const settingsTab = this.plugin.settingsTab;
          if (settingsTab && settingsTab.display) {
            settingsTab.display();
          } else {
            this.containerEl.empty();
            this.render();
          }
        }).open();
      });
    });
    this.updateAutomaticRenameVisibility();
  }
  updateAutomaticRenameVisibility() {
    if (this.conditionalSettings.length === 0) return;
    const shouldShow = this.plugin.settings.renameNotes === "automatically";
    const isEditorMethod = this.plugin.settings.fileReadMethod === "Editor";
    this.conditionalSettings.forEach((setting) => {
      if (shouldShow && isEditorMethod) {
        setting.settingEl.style.display = "";
      } else {
        setting.settingEl.style.display = "none";
      }
    });
  }
};

// src/settings/settings-main.ts
var FirstLineIsTitleSettings = class extends import_obsidian14.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.settingsPage = null;
    this.plugin = plugin;
  }
  get TABS() {
    return {
      GENERAL: { id: "general", name: t("settings.tabs.general"), class: GeneralTab },
      INCLUDE_EXCLUDE: { id: "include-exclude", name: t("settings.tabs.exclusions"), class: IncludeExcludeTab },
      FORBIDDEN_CHARS: { id: "forbidden-chars", name: t("settings.tabs.replaceCharacters"), class: ForbiddenCharsTab },
      CUSTOM_REPLACEMENTS: { id: "custom-replacements", name: t("settings.tabs.customRules"), class: CustomReplacementsTab },
      SAFEWORDS: { id: "safewords", name: t("settings.tabs.safewords"), class: SafewordsTab },
      STRIP_MARKUP: { id: "strip-markup", name: t("settings.tabs.stripMarkup"), class: StripMarkupTab },
      PROPERTIES: { id: "properties", name: t("settings.tabs.alias"), class: PropertiesTab },
      COMMANDS: { id: "commands", name: t("settings.tabs.commands"), class: CommandsTab },
      MISCELLANEOUS: { id: "miscellaneous", name: t("settings.tabs.miscellaneous"), class: MiscellaneousTab }
    };
  }
  display() {
    this.containerEl.empty();
    const tabBar = this.containerEl.createEl("nav", { cls: "flit-settings-tab-bar" });
    tabBar.setAttribute("role", "tablist");
    const locale = getCurrentLocale();
    const tabMinWidth = locale === "ru" ? "152px" : "140px";
    tabBar.style.setProperty("--flit-tab-min-width", tabMinWidth);
    const tabElements = [];
    const activateTab = (tabEl, tabInfo) => {
      for (const child of tabBar.children) {
        child.removeClass("flit-settings-tab-active");
        child.setAttribute("aria-selected", "false");
        child.setAttribute("tabindex", "-1");
      }
      tabEl.addClass("flit-settings-tab-active");
      tabEl.setAttribute("aria-selected", "true");
      tabEl.setAttribute("tabindex", "0");
      this.plugin.settings.currentSettingsTab = tabInfo.id;
      this.plugin.saveSettings();
      this.renderTab(tabInfo.id);
    };
    for (const [tabKey, tabInfo] of Object.entries(this.TABS)) {
      const tabEl = tabBar.createEl("div", { cls: "flit-settings-tab" });
      tabEl.setAttribute("data-tab-id", tabInfo.id);
      tabEl.setAttribute("role", "tab");
      const isActive = this.plugin.settings.currentSettingsTab === tabInfo.id;
      tabEl.setAttribute("tabindex", isActive ? "0" : "-1");
      tabEl.setAttribute("aria-selected", isActive ? "true" : "false");
      const tabNameEl = tabEl.createEl("div", { cls: "flit-settings-tab-name", text: tabInfo.name });
      if (isActive) {
        tabEl.addClass("flit-settings-tab-active");
      }
      tabEl.addEventListener("click", () => {
        activateTab(tabEl, tabInfo);
      });
      tabEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          activateTab(tabEl, tabInfo);
        } else if (e.key === "ArrowRight" || e.key === "ArrowLeft" || e.key === "ArrowUp" || e.key === "ArrowDown") {
          e.preventDefault();
          const currentIndex = tabElements.indexOf(tabEl);
          const rows = [];
          let currentRow = [];
          let lastTop = -1;
          tabElements.forEach((tab) => {
            const rect = tab.getBoundingClientRect();
            if (lastTop === -1 || Math.abs(rect.top - lastTop) < 5) {
              currentRow.push(tab);
              lastTop = rect.top;
            } else {
              if (currentRow.length > 0) {
                rows.push(currentRow);
              }
              currentRow = [tab];
              lastTop = rect.top;
            }
          });
          if (currentRow.length > 0) {
            rows.push(currentRow);
          }
          let currentRowIndex = 0;
          let currentColIndex = 0;
          for (let r = 0; r < rows.length; r++) {
            const colIndex = rows[r].indexOf(tabEl);
            if (colIndex !== -1) {
              currentRowIndex = r;
              currentColIndex = colIndex;
              break;
            }
          }
          let nextTab = null;
          if (e.key === "ArrowRight") {
            const nextCol = currentColIndex + 1;
            if (nextCol < rows[currentRowIndex].length) {
              nextTab = rows[currentRowIndex][nextCol];
            } else {
              const nextRow = (currentRowIndex + 1) % rows.length;
              nextTab = rows[nextRow][0];
            }
          } else if (e.key === "ArrowLeft") {
            const prevCol = currentColIndex - 1;
            if (prevCol >= 0) {
              nextTab = rows[currentRowIndex][prevCol];
            } else {
              const prevRow = (currentRowIndex - 1 + rows.length) % rows.length;
              nextTab = rows[prevRow][rows[prevRow].length - 1];
            }
          } else if (e.key === "ArrowDown") {
            const nextRow = currentRowIndex + 1;
            if (nextRow < rows.length) {
              const targetCol = Math.min(currentColIndex, rows[nextRow].length - 1);
              nextTab = rows[nextRow][targetCol];
            } else {
              const targetCol = Math.min(currentColIndex, rows[0].length - 1);
              nextTab = rows[0][targetCol];
            }
          } else if (e.key === "ArrowUp") {
            const prevRow = currentRowIndex - 1;
            if (prevRow >= 0) {
              const targetCol = Math.min(currentColIndex, rows[prevRow].length - 1);
              nextTab = rows[prevRow][targetCol];
            } else {
              const lastRow = rows.length - 1;
              const targetCol = Math.min(currentColIndex, rows[lastRow].length - 1);
              nextTab = rows[lastRow][targetCol];
            }
          }
          if (nextTab) {
            nextTab.focus();
          }
        } else if (e.key === "Home") {
          e.preventDefault();
          tabElements[0].focus();
        } else if (e.key === "End") {
          e.preventDefault();
          tabElements[tabElements.length - 1].focus();
        }
      });
      tabElements.push(tabEl);
    }
    this.settingsPage = this.containerEl.createDiv({ cls: "flit-settings-page" });
    this.renderTab(this.plugin.settings.currentSettingsTab);
    setTimeout(() => {
      if (document.activeElement instanceof HTMLElement) {
        document.activeElement.blur();
      }
    }, 0);
    let hasHandledFirstTab = false;
    const handleFirstTab = (e) => {
      if (e.key === "Tab" && !hasHandledFirstTab) {
        const focusedElement = document.activeElement;
        const isOnTab = focusedElement && focusedElement.classList.contains("flit-settings-tab");
        if (!isOnTab) {
          hasHandledFirstTab = true;
          const activeTab = tabBar.querySelector(".flit-settings-tab-active");
          if (activeTab) {
            e.preventDefault();
            activeTab.focus();
          }
        }
      }
    };
    this.containerEl.addEventListener("keydown", handleFirstTab);
  }
  async renderTab(tabId) {
    if (!this.settingsPage) return;
    this.settingsPage.empty();
    const tabConfig = Object.values(this.TABS).find((tab) => tab.id === tabId);
    if (tabConfig) {
      const tabInstance = new tabConfig.class(this.plugin, this.settingsPage);
      await tabInstance.render();
    } else {
      const generalTab = new GeneralTab(this.plugin, this.settingsPage);
      await generalTab.render();
    }
  }
};

// src/core/rename-engine.ts
var import_obsidian15 = require("obsidian");
init_constants();
init_utils();
init_i18n();
var RenameEngine = class {
  constructor(plugin) {
    this.lastEditorContent = /* @__PURE__ */ new Map();
    this.titleRegionCache = /* @__PURE__ */ new Map();
    this.fileTimeTracker = /* @__PURE__ */ new Map();
    this.globalOperationTracker = { timestamp: Date.now(), count: 0 };
    this.lastSelfRefNotice = /* @__PURE__ */ new Map();
    this.filesBeingProcessed = /* @__PURE__ */ new Set();
    this.plugin = plugin;
  }
  checkFileTimeLimit(file) {
    const now = Date.now();
    const windowMs = 500;
    const maxOpsPerFile = 15;
    const key = file.path;
    const tracker = this.fileTimeTracker.get(key);
    if (!tracker || now - tracker.timestamp > windowMs) {
      this.fileTimeTracker.set(key, { timestamp: now, count: 1 });
      return true;
    }
    if (tracker.count >= maxOpsPerFile) {
      console.log(`Per-file rate limit hit for ${file.path} - ${tracker.count} operations in ${now - tracker.timestamp}ms`);
      return false;
    }
    tracker.count++;
    return true;
  }
  checkGlobalRateLimit() {
    const now = Date.now();
    const windowMs = 500;
    const maxGlobalOps = 30;
    if (now - this.globalOperationTracker.timestamp > windowMs) {
      this.globalOperationTracker = { timestamp: now, count: 1 };
      return true;
    }
    if (this.globalOperationTracker.count >= maxGlobalOps) {
      console.log(`Global rate limit hit - ${this.globalOperationTracker.count} operations in ${now - this.globalOperationTracker.timestamp}ms`);
      return false;
    }
    this.globalOperationTracker.count++;
    return true;
  }
  async processEditorChangeOptimal(editor, file) {
    this.plugin.trackUsage();
    const startTime = Date.now();
    try {
      if (this.plugin.aliasManager.isAliasUpdateInProgress(file.path)) {
        verboseLog(this.plugin, `Editor change ignored - alias update in progress: ${file.path}`);
        return;
      }
      const currentContent = editor.getValue();
      const previousContent = this.lastEditorContent.get(file.path);
      if (previousContent) {
        const currentFrontmatterInfo = (0, import_obsidian15.getFrontMatterInfo)(currentContent);
        const previousFrontmatterInfo = (0, import_obsidian15.getFrontMatterInfo)(previousContent);
        const currentContentAfterFrontmatter = currentContent.substring(currentFrontmatterInfo.contentStart);
        const previousContentAfterFrontmatter = previousContent.substring(previousFrontmatterInfo.contentStart);
        if (currentContentAfterFrontmatter === previousContentAfterFrontmatter) {
          verboseLog(this.plugin, `Skipping - only frontmatter edited: ${file.path}`);
          this.lastEditorContent.set(file.path, currentContent);
          return;
        }
      }
      this.lastEditorContent.set(file.path, currentContent);
      const currentTitleRegion = this.extractTitleRegion(editor, file);
      const cachedTitleRegion = this.titleRegionCache.get(file.path);
      if (cachedTitleRegion && currentTitleRegion.firstNonEmptyLine === cachedTitleRegion.firstNonEmptyLine && currentTitleRegion.titleSourceLine === cachedTitleRegion.titleSourceLine) {
        verboseLog(this.plugin, `Title region unchanged - skipping processing: ${file.path}`);
        return;
      }
      this.titleRegionCache.set(file.path, currentTitleRegion);
      verboseLog(this.plugin, `Title region changed - processing: ${file.path}`, {
        previous: cachedTitleRegion,
        current: currentTitleRegion
      });
      const metadata = this.plugin.app.metadataCache.getFileCache(file);
      const timeSinceStart = Date.now() - startTime;
      verboseLog(this.plugin, `[TIMING] Content changed in ${timeSinceStart}ms: ${file.path}`);
      await this.processFileImmediate(file, currentContent, metadata);
    } catch (error) {
      console.error(`Error in optimal editor-change processing for ${file.path}:`, error);
    }
  }
  /**
   * Extract title region (first non-empty line and title source line) from editor content
   * Returns TitleRegionCache with extracted strings
   */
  extractTitleRegion(editor, file) {
    const content = editor.getValue();
    const metadata = this.plugin.app.metadataCache.getFileCache(file);
    let startLine = 0;
    if (metadata == null ? void 0 : metadata.frontmatterPosition) {
      startLine = metadata.frontmatterPosition.end.line + 1;
    }
    const lines = content.split("\n");
    let firstNonEmptyLine = "";
    for (let i = startLine; i < lines.length; i++) {
      if (lines[i].trim() !== "") {
        firstNonEmptyLine = lines[i];
        break;
      }
    }
    if (firstNonEmptyLine === "") {
      return { firstNonEmptyLine: "", titleSourceLine: "", lastUpdated: Date.now() };
    }
    const contentLines = lines.slice(startLine);
    const titleSourceLine = findTitleSourceLine(
      firstNonEmptyLine,
      contentLines,
      this.plugin.settings,
      this.plugin
    );
    return {
      firstNonEmptyLine,
      titleSourceLine,
      lastUpdated: Date.now()
    };
  }
  async processFileImmediate(file, content, metadata) {
    if (file.extension !== "md") {
      return;
    }
    if (!shouldProcessFile(file, this.plugin.settings, this.plugin.app, content)) {
      return;
    }
    verboseLog(this.plugin, `PROCESS: Starting immediate processFile for ${file.path}`);
    try {
      await this.processFile(file, true, false, content);
    } catch (error) {
      console.error(`Error in immediate process for ${file.path}:`, error);
    }
  }
  stripFrontmatterFromContent(content, file) {
    if (!content) return "";
    const lines = content.split("\n");
    if (lines.length > 0 && lines[0].trim() === "---") {
      for (let i = 1; i < lines.length; i++) {
        if (lines[i].trim() === "---") {
          const strippedContent = lines.slice(i + 1).join("\n");
          verboseLog(this.plugin, `Stripped frontmatter from ${file.path} (lines 0-${i} removed)`);
          return strippedContent;
        }
      }
    }
    return content;
  }
  async processFile(file, noDelay = false, showNotices = false, providedContent, isBatchOperation = false, exclusionOverrides) {
    this.plugin.trackUsage();
    verboseLog(this.plugin, `Processing file: ${file.path}`, { noDelay });
    const currentFile = this.plugin.app.vault.getAbstractFileByPath(file.path);
    if (!currentFile || !(currentFile instanceof import_obsidian15.TFile)) {
      verboseLog(this.plugin, `Skipping processing - file no longer exists or is not a TFile: ${file.path}`);
      return { success: false, reason: "file-not-found" };
    }
    file = currentFile;
    if (file.extension !== "md") {
      verboseLog(this.plugin, `Skipping non-markdown file: ${file.path}`);
      return { success: false, reason: "not-markdown" };
    }
    const originalPath = file.path;
    if (this.filesBeingProcessed.has(originalPath)) {
      verboseLog(this.plugin, `Skipping - file already being processed: ${originalPath}`);
      return { success: false, reason: "already-processing" };
    }
    this.filesBeingProcessed.add(originalPath);
    try {
      return await this.processFileInternal(file, noDelay, showNotices, providedContent, isBatchOperation, exclusionOverrides);
    } finally {
      this.filesBeingProcessed.delete(originalPath);
    }
  }
  async processFileInternal(file, noDelay, showNotices, providedContent, isBatchOperation = false, exclusionOverrides) {
    var _a, _b, _c;
    if (await hasDisablePropertyInFile(file, this.plugin.app, this.plugin.settings.disableRenamingKey, this.plugin.settings.disableRenamingValue)) {
      verboseLog(this.plugin, `ABSOLUTE BLOCK: Skipping file with disable property: ${file.path}`);
      return { success: false, reason: "property-disabled" };
    }
    let contentForRateLimit;
    if (providedContent) {
      contentForRateLimit = providedContent;
    } else {
      try {
        contentForRateLimit = await this.plugin.app.vault.read(file);
      } catch (error) {
        console.error(`Error reading file for rate limit check: ${file.path}`, error);
        return { success: false, reason: "read-error" };
      }
    }
    if (!this.checkFileTimeLimit(file)) {
      return { success: false, reason: "time-rate-limited" };
    }
    if (!isBatchOperation) {
      if (!this.checkGlobalRateLimit()) {
        return { success: false, reason: "global-rate-limited" };
      }
    }
    let initialContent;
    try {
      initialContent = await this.plugin.app.vault.read(file);
    } catch (error) {
    }
    if (!shouldProcessFile(file, this.plugin.settings, this.plugin.app, initialContent, exclusionOverrides)) {
      verboseLog(this.plugin, `Skipping file based on include/exclude strategy: ${file.path}`);
      return { success: false, reason: "excluded" };
    }
    const startTime = Date.now();
    verboseLog(this.plugin, `RENAME: Starting renameFile for ${file.name}`);
    const cacheManager = this.plugin.cacheManager;
    const previousFileContent = cacheManager == null ? void 0 : cacheManager.getContent(file.path);
    this.cleanupStaleCache();
    let content;
    try {
      if (this.plugin.settings.fileReadMethod === "Editor") {
        if (typeof providedContent === "string" && providedContent !== "") {
          content = providedContent;
          verboseLog(this.plugin, `Using provided editor content for ${file.path} (${content.length} chars)`);
        } else {
          content = await this.plugin.app.vault.cachedRead(file);
          verboseLog(this.plugin, `Editor method fallback to cached read for ${file.path} (${content.length} chars)`);
        }
      } else if (this.plugin.settings.fileReadMethod === "Cache") {
        content = await this.plugin.app.vault.cachedRead(file);
        verboseLog(this.plugin, `Cached read content from ${file.path} (${content.length} chars)`);
      } else if (this.plugin.settings.fileReadMethod === "File") {
        content = await this.plugin.app.vault.read(file);
        verboseLog(this.plugin, `Direct read content from ${file.path} (${content.length} chars)`);
      } else {
        content = await this.plugin.app.vault.cachedRead(file);
        verboseLog(this.plugin, `Unknown method, fallback to cached read for ${file.path} (${content.length} chars)`);
      }
    } catch (error) {
      console.error(`Failed to read file ${file.path}:`, error);
      throw new Error(`Failed to read file: ${error.message}`);
    }
    if (containsSafeword(file.name, this.plugin.settings)) {
      verboseLog(this.plugin, `Skipping file with safeword: ${file.path}`);
      return { success: false, reason: "safeword" };
    }
    const currentName = file.basename;
    const contentWithoutFrontmatter = this.stripFrontmatterFromContent(content, file);
    const lines = contentWithoutFrontmatter.split("\n");
    let firstNonEmptyLine = "";
    for (const line of lines) {
      if (line.trim() !== "") {
        firstNonEmptyLine = line;
        break;
      }
    }
    if (firstNonEmptyLine === "") {
      const previousContentWithoutFrontmatter = previousFileContent ? this.stripFrontmatterFromContent(previousFileContent, file) : "";
      const hadPreviousContent = previousContentWithoutFrontmatter.trim() !== "";
      if (hadPreviousContent) {
        verboseLog(this.plugin, `Content became empty - renaming to ${t("untitled")}: ${file.path}`);
        firstNonEmptyLine = t("untitled");
      } else {
        cacheManager == null ? void 0 : cacheManager.setContent(file.path, content);
        verboseLog(this.plugin, `Skipping rename for empty file - retaining current filename: ${file.path}`);
        return { success: false, reason: "empty-content-retained" };
      }
    }
    if (this.plugin.settings.whatToPutInTitle === "headings_only") {
      if (!isValidHeading(firstNonEmptyLine)) {
        verboseLog(this.plugin, `Skipping file - first line is not a valid heading: ${file.path}`);
        return { success: false, reason: "not-heading" };
      }
    }
    const titleSourceLine = findTitleSourceLine(firstNonEmptyLine, lines, this.plugin.settings, this.plugin);
    const contentBecameEmpty = contentWithoutFrontmatter.trim() === "" && firstNonEmptyLine === t("untitled");
    if (!contentBecameEmpty) {
      cacheManager == null ? void 0 : cacheManager.setContent(file.path, content);
    }
    const originalContentWithFrontmatter = content;
    content = contentWithoutFrontmatter;
    const escapedName = currentName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const pathWithoutExt = file.path.replace(/\.md$/, "");
    const escapedPath = pathWithoutExt.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const wikiLinkRegex = new RegExp(`\\[\\[(${escapedName}|${escapedPath})(#[^\\]|]*?)?(\\|.*?)?\\]\\]`);
    const markdownLinkRegex = /\[([^\]]*)\]\(([^)]+)\)/g;
    let isSelfReferencing = false;
    if (wikiLinkRegex.test(titleSourceLine)) {
      isSelfReferencing = true;
      verboseLog(this.plugin, `Found self-referencing wikilink in ${file.path} before custom replacements`);
    }
    let match;
    while ((match = markdownLinkRegex.exec(titleSourceLine)) !== null) {
      const url = match[2];
      let decodedUrl = url;
      try {
        decodedUrl = decodeURIComponent(url);
      } catch (e) {
      }
      if (url.startsWith("#") && url.includes(currentName)) {
        isSelfReferencing = true;
        verboseLog(this.plugin, `Found self-referencing markdown link (fragment) in ${file.path} before custom replacements`);
        break;
      }
      const urlWithoutFragment = decodedUrl.split("#")[0];
      if (urlWithoutFragment && (urlWithoutFragment === `${currentName}.md` || urlWithoutFragment === currentName || urlWithoutFragment === `${pathWithoutExt}.md` || urlWithoutFragment === pathWithoutExt)) {
        isSelfReferencing = true;
        verboseLog(this.plugin, `Found self-referencing markdown link (percent-encoded) in ${file.path} before custom replacements`);
        break;
      }
    }
    let newTitle = titleSourceLine;
    verboseLog(this.plugin, `Custom replacements enabled: ${this.plugin.settings.enableCustomReplacements}, count: ${((_a = this.plugin.settings.customReplacements) == null ? void 0 : _a.length) || 0}`);
    if (this.plugin.settings.enableCustomReplacements) {
      for (const replacement of this.plugin.settings.customReplacements) {
        if (replacement.searchText === "" || !replacement.enabled) continue;
        verboseLog(this.plugin, `Checking custom replacement:`, {
          searchText: replacement.searchText,
          replaceText: replacement.replaceText,
          onlyWholeLine: replacement.onlyWholeLine,
          onlyAtStart: replacement.onlyAtStart,
          enabled: replacement.enabled,
          currentLine: newTitle
        });
        let tempLine = newTitle;
        if (replacement.onlyWholeLine) {
          if (newTitle.trim() === replacement.searchText.trim()) {
            tempLine = replacement.replaceText;
            verboseLog(this.plugin, `Applied whole line replacement:`, { from: newTitle, to: tempLine });
          }
        } else if (replacement.onlyAtStart) {
          if (tempLine.startsWith(replacement.searchText)) {
            tempLine = replacement.replaceText + tempLine.slice(replacement.searchText.length);
            verboseLog(this.plugin, `Applied start replacement:`, { from: newTitle, to: tempLine });
          }
        } else {
          const beforeReplace = tempLine;
          tempLine = tempLine.replaceAll(replacement.searchText, replacement.replaceText);
          if (beforeReplace !== tempLine) {
            verboseLog(this.plugin, `Applied general replacement:`, { from: beforeReplace, to: tempLine });
          }
        }
        newTitle = tempLine;
      }
    }
    if (newTitle.trim() === "") {
      newTitle = t("untitled");
    }
    verboseLog(this.plugin, isSelfReferencing ? `Self-reference found in ${file.path}` : `No self-reference found in ${file.path}`);
    newTitle = extractTitle(newTitle, this.plugin.settings);
    verboseLog(this.plugin, `Extracted title from ${file.path}`, {
      firstNonEmptyLine,
      titleSourceLine,
      extracted: newTitle
    });
    const charMap = {
      "/": this.plugin.settings.charReplacements.slash,
      ":": this.plugin.settings.charReplacements.colon,
      "|": this.plugin.settings.charReplacements.pipe,
      "#": this.plugin.settings.charReplacements.hash,
      "[": this.plugin.settings.charReplacements.leftBracket,
      "]": this.plugin.settings.charReplacements.rightBracket,
      "^": this.plugin.settings.charReplacements.caret,
      "*": this.plugin.settings.charReplacements.asterisk,
      "?": this.plugin.settings.charReplacements.question,
      "<": this.plugin.settings.charReplacements.lessThan,
      ">": this.plugin.settings.charReplacements.greaterThan,
      '"': this.plugin.settings.charReplacements.quote,
      [String.fromCharCode(92)]: this.plugin.settings.charReplacements.backslash,
      ".": this.plugin.settings.charReplacements.dot
    };
    const universalForbiddenChars = UNIVERSAL_FORBIDDEN_CHARS;
    const windowsAndroidChars = WINDOWS_ANDROID_CHARS;
    const allForbiddenChars = [...universalForbiddenChars];
    const currentOS = detectOS();
    if (currentOS === "Windows" || this.plugin.settings.windowsAndroidEnabled) {
      allForbiddenChars.push(...windowsAndroidChars);
    }
    const forbiddenChars = [...new Set(allForbiddenChars)].join("");
    const forbiddenNames = [
      "CON",
      "PRN",
      "AUX",
      "NUL",
      "COM1",
      "COM2",
      "COM3",
      "COM4",
      "COM5",
      "COM6",
      "COM7",
      "COM8",
      "COM9",
      "COM0",
      "LPT1",
      "LPT2",
      "LPT3",
      "LPT4",
      "LPT5",
      "LPT6",
      "LPT7",
      "LPT8",
      "LPT9",
      "LPT0"
    ];
    const titleBeforeForbiddenCharProcessing = newTitle;
    newTitle = "";
    for (let i = 0; i < titleBeforeForbiddenCharProcessing.length; i++) {
      if (newTitle.length >= this.plugin.settings.charCount - 1) {
        newTitle = newTitle.trimEnd();
        newTitle += "\u2026";
        break;
      }
      let char = titleBeforeForbiddenCharProcessing[i];
      if (char === ".") {
        if (newTitle === "") {
          if (this.plugin.settings.enableForbiddenCharReplacements && this.plugin.settings.charReplacementEnabled.dot) {
            const replacement = charMap["."] || "";
            if (replacement !== "") {
              if (this.plugin.settings.charReplacementTrimRight.dot) {
                while (i + 1 < titleBeforeForbiddenCharProcessing.length && /\s/.test(titleBeforeForbiddenCharProcessing[i + 1])) {
                  i++;
                }
              }
              newTitle += replacement;
              verboseLog(this.plugin, `Replaced leading dot with \`${replacement}\` in ${file.path}`);
            }
          }
        } else {
          newTitle += ".";
        }
      } else if (forbiddenChars.includes(char)) {
        let shouldReplace = false;
        let replacement = "";
        if (this.plugin.settings.enableForbiddenCharReplacements) {
          let settingKey = null;
          switch (char) {
            case "/":
              settingKey = "slash";
              break;
            case String.fromCharCode(92):
              settingKey = "backslash";
              break;
            case ":":
              settingKey = "colon";
              break;
            case "|":
              settingKey = "pipe";
              break;
            case "#":
              settingKey = "hash";
              break;
            case "[":
              settingKey = "leftBracket";
              break;
            case "]":
              settingKey = "rightBracket";
              break;
            case "^":
              settingKey = "caret";
              break;
            case "*":
              settingKey = "asterisk";
              break;
            case "?":
              settingKey = "question";
              break;
            case "<":
              settingKey = "lessThan";
              break;
            case ">":
              settingKey = "greaterThan";
              break;
            case '"':
              settingKey = "quote";
              break;
          }
          const isWindowsAndroidChar = WINDOWS_ANDROID_CHARS.includes(char);
          const canReplace = isWindowsAndroidChar ? this.plugin.settings.windowsAndroidEnabled && settingKey && this.plugin.settings.charReplacementEnabled[settingKey] : settingKey && this.plugin.settings.charReplacementEnabled[settingKey];
          if (canReplace && settingKey) {
            shouldReplace = true;
            replacement = charMap[char] || "";
            if (replacement !== "") {
              if (this.plugin.settings.charReplacementTrimLeft[settingKey]) {
                newTitle = newTitle.trimEnd();
              }
              if (this.plugin.settings.charReplacementTrimRight[settingKey]) {
                while (i + 1 < titleBeforeForbiddenCharProcessing.length && /\s/.test(titleBeforeForbiddenCharProcessing[i + 1])) {
                  i++;
                }
              }
            }
          }
        }
        if (shouldReplace && replacement !== "") {
          newTitle += replacement;
          verboseLog(this.plugin, `Replaced forbidden char \`${char}\` with \`${replacement}\` in ${file.path}`);
        }
      } else {
        newTitle += char;
      }
    }
    newTitle = newTitle.trim().replace(/\s+/g, " ");
    const isForbiddenName = newTitle === "" || forbiddenNames.includes(newTitle.toUpperCase());
    if (isForbiddenName) {
      newTitle = t("untitled");
      verboseLog(this.plugin, `Using fallback name \`${t("untitled")}\` for ${file.path}`);
    }
    const parentPath = ((_b = file.parent) == null ? void 0 : _b.path) === "/" ? "" : ((_c = file.parent) == null ? void 0 : _c.path) + "/";
    let newPath = `${parentPath}${newTitle}.md`;
    verboseLog(this.plugin, `Initial target path: ${newPath} for file: ${file.path}`);
    if (file.path == newPath) {
      verboseLog(this.plugin, `No rename needed for ${file.path} - already has correct name`);
      if (this.plugin.settings.enableAliases) {
        await this.plugin.aliasManager.updateAliasIfNeeded(file, originalContentWithFrontmatter);
      }
      return { success: false, reason: "no-rename-needed" };
    }
    let counter = 0;
    let fileExists = this.checkFileExistsCaseInsensitive(newPath);
    const tempPathConflict = false;
    verboseLog(this.plugin, `Conflict check for ${newPath}: fileExists=${fileExists}, tempPathConflict=${tempPathConflict} (tempNewPaths eliminated)`);
    if (fileExists || tempPathConflict) {
      verboseLog(this.plugin, `Found conflicts for ${newPath}, starting counter loop`);
      while (fileExists) {
        if (file.path == newPath) {
          verboseLog(this.plugin, `No rename needed for ${file.path} - already has correct name with counter`);
          if (this.plugin.settings.enableAliases) {
            await this.plugin.aliasManager.updateAliasIfNeeded(file, originalContentWithFrontmatter, newTitle);
          }
          if (showNotices && !isBatchOperation) {
            const finalFileName = newPath.replace(/\.md$/, "").split("/").pop() || newTitle;
            const titleChanged = currentName !== finalFileName;
            const shouldShowNotice = this.plugin.settings.manualNotificationMode === "Always" || this.plugin.settings.manualNotificationMode === "On title change" && titleChanged;
            if (shouldShowNotice) {
              verboseLog(this.plugin, `Showing notice: Updated title: ${currentName} \u2192 ${finalFileName}`);
              new import_obsidian15.Notice(t("notifications.renamedTo").replace("{{filename}}", finalFileName));
            }
          }
          return { success: false, reason: "no-rename-needed" };
        }
        counter += 1;
        newPath = `${parentPath}${newTitle} ${counter}.md`;
        fileExists = this.checkFileExistsCaseInsensitive(newPath);
      }
      verboseLog(this.plugin, `Found available filename with counter ${counter}: ${newPath}`);
    } else {
      verboseLog(this.plugin, `No conflicts found for ${newPath}, proceeding without counter`);
    }
    if (isSelfReferencing) {
      if (!isBatchOperation) {
        const now = Date.now();
        const lastNoticeTime = this.lastSelfRefNotice.get(file.path) || 0;
        if (now - lastNoticeTime >= 2e3) {
          verboseLog(this.plugin, `Showing notice: File not renamed due to self-referential link in first line: ${file.basename}`);
          new import_obsidian15.Notice(t("notifications.notRenamedSelfReference").replace("{{filename}}", file.basename));
          this.lastSelfRefNotice.set(file.path, now);
        }
      }
      verboseLog(this.plugin, `Skipping self-referencing file: ${file.path}`);
      return { success: false, reason: "self-referential" };
    }
    if (noDelay) {
      cacheManager == null ? void 0 : cacheManager.reservePath(newPath);
    }
    if (this.plugin.settings.enableAliases) {
      await this.plugin.aliasManager.updateAliasIfNeeded(file, originalContentWithFrontmatter, newTitle);
    }
    try {
      if (isBatchOperation) {
        this.plugin.markBatchOperationStart(file.path);
      }
      this.plugin.markFlitModificationStart(file.path);
      const oldPath = file.path;
      await this.plugin.app.fileManager.renameFile(file, newPath);
      const processingTime = Date.now() - startTime;
      verboseLog(this.plugin, `Successfully renamed ${oldPath} to ${newPath} (${processingTime}ms)`);
      this.plugin.markFlitModificationEnd(newPath);
      if (isBatchOperation) {
        this.plugin.markBatchOperationEnd(newPath);
      }
      const lastContent = this.lastEditorContent.get(oldPath);
      if (lastContent !== void 0) {
        this.lastEditorContent.delete(oldPath);
        this.lastEditorContent.set(newPath, lastContent);
      }
      this.updateTitleRegionCacheKey(oldPath, newPath);
      cacheManager == null ? void 0 : cacheManager.notifyFileRenamed(oldPath, newPath);
      if (showNotices && !isBatchOperation) {
        const finalFileName = newPath.replace(/\.md$/, "").split("/").pop() || newTitle;
        const titleChanged = currentName !== finalFileName;
        const shouldShowNotice = this.plugin.settings.manualNotificationMode === "Always" || this.plugin.settings.manualNotificationMode === "On title change" && titleChanged;
        if (shouldShowNotice) {
          verboseLog(this.plugin, `Showing notice: Updated title: ${currentName} \u2192 ${finalFileName}`);
          new import_obsidian15.Notice(t("notifications.renamedTo").replace("{{filename}}", finalFileName));
        }
      }
      return { success: true };
    } catch (error) {
      console.error(`Failed to rename file ${file.path} to ${newPath}:`, error);
      return { success: false, reason: "error" };
    }
  }
  checkFileExistsCaseInsensitive(path) {
    const exactMatch = this.plugin.app.vault.getAbstractFileByPath(path);
    if (exactMatch !== null) {
      verboseLog(this.plugin, `Exact file conflict found: ${path} (existing file: ${exactMatch.path})`);
      return true;
    }
    const lowerPath = path.toLowerCase();
    const allFiles = this.plugin.app.vault.getAllLoadedFiles();
    for (const file of allFiles) {
      if (file.path.toLowerCase() === lowerPath) {
        verboseLog(this.plugin, `Case-insensitive file conflict found: ${path} (existing file: ${file.path})`);
        return true;
      }
    }
    return false;
  }
  cleanupStaleCache() {
    verboseLog(this.plugin, "Cache cleanup completed");
  }
  // Getter for lastEditorContent (for use in main.ts)
  getLastEditorContent(path) {
    return this.lastEditorContent.get(path);
  }
  // Setter for lastEditorContent (for use in main.ts)
  setLastEditorContent(path, content) {
    this.lastEditorContent.set(path, content);
  }
  // Delete method for lastEditorContent (for use in main.ts)
  deleteLastEditorContent(path) {
    this.lastEditorContent.delete(path);
  }
  // ==================== TITLE REGION CACHE MANAGEMENT ====================
  /**
   * Clear all title region cache entries (used when settings change)
   */
  clearTitleRegionCache() {
    this.titleRegionCache.clear();
    verboseLog(this.plugin, "Cleared title region cache");
  }
  /**
   * Delete title region cache entry for a specific file
   */
  deleteTitleRegionCache(path) {
    this.titleRegionCache.delete(path);
    verboseLog(this.plugin, `Deleted title region cache for: ${path}`);
  }
  /**
   * Update title region cache key when file is renamed
   */
  updateTitleRegionCacheKey(oldPath, newPath) {
    const cached = this.titleRegionCache.get(oldPath);
    if (cached) {
      this.titleRegionCache.delete(oldPath);
      this.titleRegionCache.set(newPath, cached);
      verboseLog(this.plugin, `Updated title region cache key: ${oldPath} \u2192 ${newPath}`);
    }
  }
};

// src/ui/context-menus.ts
var import_obsidian16 = require("obsidian");
init_utils();
init_modals();
init_i18n();
var ContextMenuManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Creates or retrieves a context menu for the given mouse event.
   * Uses Tag Wrangler's menuForEvent pattern.
   */
  menuForEvent(evt) {
    let menu = evt.obsidian_contextmenu;
    if (!menu) {
      menu = evt.obsidian_contextmenu = new import_obsidian16.Menu();
      setTimeout(() => menu.showAtPosition({ x: evt.pageX, y: evt.pageY }), 0);
    }
    return menu;
  }
  /**
   * Determines whether to show disable menu option for a folder based on scope strategy.
   */
  shouldShowDisableMenuForFolder(folderPath) {
    const isInList = this.plugin.settings.excludedFolders.includes(folderPath);
    let result;
    if (this.plugin.settings.folderScopeStrategy === "Only exclude...") {
      result = !isInList;
    } else {
      result = isInList;
    }
    verboseLog(this.plugin, `shouldShowDisableMenuForFolder(${folderPath})`, {
      folderScopeStrategy: this.plugin.settings.folderScopeStrategy,
      isInList,
      result,
      willShow: result ? "DISABLE menu" : "ENABLE menu"
    });
    return result;
  }
  /**
   * Determines whether to show disable menu option for a tag based on scope strategy.
   */
  shouldShowDisableMenuForTag(tagName) {
    const tagToFind = tagName.startsWith("#") ? tagName : `#${tagName}`;
    const isInList = this.plugin.settings.excludedTags.includes(tagToFind);
    let result;
    if (this.plugin.settings.tagScopeStrategy === "Only exclude...") {
      result = !isInList;
    } else {
      result = isInList;
    }
    verboseLog(this.plugin, `shouldShowDisableMenuForTag(${tagName})`, {
      folderScopeStrategy: this.plugin.settings.folderScopeStrategy,
      tagToFind,
      isInList,
      result,
      willShow: result ? "DISABLE menu" : "ENABLE menu"
    });
    return result;
  }
  /**
   * Gets the appropriate menu text for folder operations based on scope strategy.
   */
  getFolderMenuText(folderPath) {
    if (this.plugin.settings.folderScopeStrategy === "Only exclude...") {
      return {
        disable: t("commands.disableRenamingInFolder"),
        enable: t("commands.enableRenamingInFolder")
      };
    } else {
      return {
        disable: t("commands.disableRenamingInFolder"),
        enable: t("commands.enableRenamingInFolder")
      };
    }
  }
  /**
   * Gets the appropriate menu text for tag operations based on scope strategy.
   */
  getTagMenuText(tagName) {
    if (this.plugin.settings.tagScopeStrategy === "Only exclude...") {
      return {
        disable: t("commands.disableRenamingForTag"),
        enable: t("commands.enableRenamingForTag")
      };
    } else {
      return {
        disable: t("commands.disableRenamingForTag"),
        enable: t("commands.enableRenamingForTag")
      };
    }
  }
  /**
   * Adds tag-related menu items to a context menu.
   */
  addTagMenuItems(menu, tagName) {
    const tagToFind = tagName.startsWith("#") ? tagName : `#${tagName}`;
    const shouldShowDisable = this.shouldShowDisableMenuForTag(tagName);
    const menuText = this.getTagMenuText(tagName);
    let visibleItemCount = 0;
    if (this.plugin.settings.commandVisibility.tagPutFirstLineInTitle) visibleItemCount++;
    if (shouldShowDisable && this.plugin.settings.commandVisibility.tagExclude) visibleItemCount++;
    if (!shouldShowDisable && this.plugin.settings.commandVisibility.tagStopExcluding) visibleItemCount++;
    if (visibleItemCount > 0) {
      menu.addSeparator();
    }
    if (this.plugin.settings.commandVisibility.tagPutFirstLineInTitle) {
      menu.addItem((item) => {
        item.setTitle(t("commands.putFirstLineInTitle")).setIcon("file-pen").onClick(() => {
          new ProcessTagModal(this.plugin.app, this.plugin, tagName).open();
        });
      });
    }
    if (shouldShowDisable && this.plugin.settings.commandVisibility.tagExclude) {
      menu.addItem((item) => {
        item.setTitle(menuText.disable).setIcon("square-x").onClick(async () => {
          await this.plugin.toggleTagExclusion(tagName);
        });
      });
    }
    if (!shouldShowDisable && this.plugin.settings.commandVisibility.tagStopExcluding) {
      menu.addItem((item) => {
        item.setTitle(menuText.enable).setIcon("square-check").onClick(async () => {
          await this.plugin.toggleTagExclusion(tagName);
        });
      });
    }
  }
  /**
   * Adds tag-related menu items directly to a DOM element.
   * Used for custom menu implementations.
   */
  addTagMenuItemsToDOM(menuEl, tagName) {
    const tagToFind = tagName.startsWith("#") ? tagName : `#${tagName}`;
    const shouldShowDisable = this.shouldShowDisableMenuForTag(tagName);
    const menuText = this.getTagMenuText(tagName);
    if (this.plugin.settings.commandVisibility.tagPutFirstLineInTitle) {
      const menuItem = menuEl.createEl("div", { cls: "menu-item" });
      const iconEl = menuItem.createEl("div", { cls: "menu-item-icon" });
      (0, import_obsidian16.setIcon)(iconEl, "file-pen");
      menuItem.createEl("div", { cls: "menu-item-title", text: t("commands.putFirstLineInTitle") });
      menuItem.addEventListener("click", () => {
        new ProcessTagModal(this.plugin.app, this.plugin, tagName).open();
        menuEl.remove();
      });
    }
    if (shouldShowDisable && this.plugin.settings.commandVisibility.tagExclude) {
      const menuItem = menuEl.createEl("div", { cls: "menu-item" });
      const iconEl = menuItem.createEl("div", { cls: "menu-item-icon" });
      (0, import_obsidian16.setIcon)(iconEl, "square-x");
      menuItem.createEl("div", { cls: "menu-item-title", text: menuText.disable });
      menuItem.addEventListener("click", async () => {
        await this.plugin.toggleTagExclusion(tagName);
        menuEl.remove();
      });
    }
    if (!shouldShowDisable && this.plugin.settings.commandVisibility.tagStopExcluding) {
      const menuItem = menuEl.createEl("div", { cls: "menu-item" });
      const iconEl = menuItem.createEl("div", { cls: "menu-item-icon" });
      (0, import_obsidian16.setIcon)(iconEl, "square-check");
      menuItem.createEl("div", { cls: "menu-item-title", text: menuText.enable });
      menuItem.addEventListener("click", async () => {
        await this.plugin.toggleTagExclusion(tagName);
        menuEl.remove();
      });
    }
  }
  /**
   * Adds menu items for bulk operations on multiple folders.
   */
  addMultiFolderMenuItems(menu, folders) {
    let totalFiles = 0;
    folders.forEach((folder) => {
      const files = this.plugin.getAllMarkdownFilesInFolder(folder);
      totalFiles += files.length;
    });
    const hasRenameCommand = this.plugin.settings.commandVisibility.folderPutFirstLineInTitle && totalFiles > 0;
    const hasDisableCommand = this.plugin.settings.commandVisibility.folderExclude;
    const hasEnableCommand = this.plugin.settings.commandVisibility.folderStopExcluding;
    if (!hasRenameCommand && !hasDisableCommand && !hasEnableCommand) return;
    menu.addSeparator();
    if (hasRenameCommand) {
      menu.addItem((item) => {
        item.setTitle(tp("commands.putFirstLineInTitleNFolders", folders.length)).setIcon("folder-pen").onClick(() => {
          new RenameMultipleFoldersModal(this.plugin.app, this.plugin, folders).open();
        });
      });
    }
    if (hasDisableCommand) {
      menu.addItem((item) => {
        item.setTitle(tp("commands.disableRenamingNFolders", folders.length)).setIcon("square-x").onClick(async () => {
          await this.plugin.processMultipleFolders(folders, "disable");
        });
      });
    }
    if (hasEnableCommand) {
      menu.addItem((item) => {
        item.setTitle(tp("commands.enableRenamingNFolders", folders.length)).setIcon("square-check").onClick(async () => {
          await this.plugin.processMultipleFolders(folders, "enable");
        });
      });
    }
  }
};

// src/operations/folder-operations.ts
var import_obsidian17 = require("obsidian");
init_utils();
init_i18n();
var FolderOperations = class {
  constructor(app, settings, renameEngine, saveSettings, debugLog, processMultipleFiles) {
    this.app = app;
    this.settings = settings;
    this.renameEngine = renameEngine;
    this.saveSettings = saveSettings;
    this.debugLog = debugLog;
    this.processMultipleFiles = processMultipleFiles;
  }
  async putFirstLineInTitleForFolder(folder) {
    const files = this.app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian17.TFile && file.extension === "md").filter((file) => {
      var _a;
      return file.path.startsWith(folder.path + "/") || ((_a = file.parent) == null ? void 0 : _a.path) === folder.path;
    });
    if (files.length === 0) {
      verboseLog(this, `Showing notice: No markdown files found in this folder.`);
      new import_obsidian17.Notice(t("notifications.noNotesFoundInFolder").replace("{{folder}}", folder.name));
      return;
    }
    verboseLog(this, `Showing notice: Renaming ${files.length} files in "${folder.path}"...`);
    new import_obsidian17.Notice(t("notifications.renamingNNotes").replace("{{count}}", String(files.length)));
    let processedCount = 0;
    let errorCount = 0;
    const exclusionOverrides = { ignoreFolder: true, ignoreTag: true, ignoreProperty: true };
    for (const file of files) {
      try {
        await this.renameEngine.processFile(file, true, false, void 0, true, exclusionOverrides);
        processedCount++;
      } catch (error) {
        console.error(`Error processing file ${file.path}:`, error);
        errorCount++;
      }
    }
    if (errorCount > 0) {
      verboseLog(this, `Showing notice: Renamed ${processedCount}/${files.length} notes with ${errorCount} errors. Check console for details.`);
      new import_obsidian17.Notice(t("notifications.renamedNotesWithErrors").replace("{{renamed}}", String(processedCount)).replace("{{total}}", String(files.length)).replace("{{errors}}", String(errorCount)), 0);
    } else {
      verboseLog(this, `Showing notice: Successfully processed ${processedCount} files.`);
      new import_obsidian17.Notice(t("notifications.renamedNotes").replace("{{renamed}}", String(processedCount)).replace("{{total}}", String(files.length)), 0);
    }
  }
  async toggleFolderExclusion(folderPath, suppressNotice = false) {
    folderPath = (0, import_obsidian17.normalizePath)(folderPath);
    const isInList = this.settings.excludedFolders.includes(folderPath);
    const isInverted = this.settings.folderScopeStrategy === "Exclude all except...";
    if (isInList) {
      this.settings.excludedFolders = this.settings.excludedFolders.filter((path) => path !== folderPath);
      if (this.settings.excludedFolders.length === 0) {
        this.settings.excludedFolders.push("");
      }
      if (!suppressNotice) {
        if (isInverted) {
          verboseLog(this, `Showing notice: Renaming disabled for folder: ${folderPath}`);
          new import_obsidian17.Notice(t("notifications.disabledRenamingInFolder").replace("{{folder}}", folderPath));
        } else {
          verboseLog(this, `Showing notice: Renaming enabled for folder: ${folderPath}`);
          new import_obsidian17.Notice(t("notifications.enabledRenamingInFolder").replace("{{folder}}", folderPath));
        }
      }
    } else {
      if (this.settings.excludedFolders.length === 1 && this.settings.excludedFolders[0] === "") {
        this.settings.excludedFolders[0] = folderPath;
      } else {
        this.settings.excludedFolders.push(folderPath);
      }
      if (!suppressNotice) {
        if (isInverted) {
          verboseLog(this, `Showing notice: Renaming enabled for folder: ${folderPath}`);
          new import_obsidian17.Notice(t("notifications.enabledRenamingInFolder").replace("{{folder}}", folderPath));
        } else {
          verboseLog(this, `Showing notice: Renaming disabled for folder: ${folderPath}`);
          new import_obsidian17.Notice(t("notifications.disabledRenamingInFolder").replace("{{folder}}", folderPath));
        }
      }
    }
    this.debugLog("excludedFolders", this.settings.excludedFolders);
    await this.saveSettings();
    verboseLog(this, `Folder exclusion toggled for: ${folderPath}`, { isNowInList: !isInList });
  }
  getSelectedFolders() {
    const selectedFolders = [];
    const selectors = [
      ".nav-folder.is-selected",
      ".nav-folder.is-active",
      ".nav-folder-title.is-selected",
      ".nav-folder-title.is-active",
      ".tree-item.is-selected .nav-folder-title",
      ".tree-item.is-active .nav-folder-title"
    ];
    selectors.forEach((selector) => {
      const elements = document.querySelectorAll(selector);
      elements.forEach((element) => {
        let folderPath = element.getAttribute("data-path");
        if (!folderPath) {
          const parent = element.closest(".nav-folder, .tree-item");
          if (parent) {
            folderPath = parent.getAttribute("data-path");
          }
        }
        if (folderPath) {
          const folder = this.app.vault.getAbstractFileByPath(folderPath);
          if (folder instanceof import_obsidian17.TFolder && !selectedFolders.includes(folder)) {
            selectedFolders.push(folder);
          }
        }
      });
    });
    return selectedFolders;
  }
  getSelectedFiles() {
    const selectedFiles = [];
    const selectors = [
      ".nav-file.is-selected",
      ".nav-file.is-active",
      ".nav-file-title.is-selected",
      ".nav-file-title.is-active",
      ".tree-item.is-selected .nav-file-title",
      ".tree-item.is-active .nav-file-title"
    ];
    selectors.forEach((selector) => {
      const elements = document.querySelectorAll(selector);
      elements.forEach((element) => {
        let filePath = element.getAttribute("data-path");
        if (!filePath) {
          const parent = element.closest(".nav-file, .tree-item");
          if (parent) {
            filePath = parent.getAttribute("data-path");
          }
        }
        if (filePath) {
          const file = this.app.vault.getAbstractFileByPath(filePath);
          if (file instanceof import_obsidian17.TFile && file.extension === "md" && !selectedFiles.includes(file)) {
            selectedFiles.push(file);
          }
        }
      });
    });
    return selectedFiles;
  }
  getAllMarkdownFilesInFolder(folder) {
    const files = [];
    const processFolder = (currentFolder) => {
      currentFolder.children.forEach((child) => {
        if (child instanceof import_obsidian17.TFile && child.extension === "md") {
          files.push(child);
        } else if (child instanceof import_obsidian17.TFolder && this.settings.includeSubfolders) {
          processFolder(child);
        }
      });
    };
    processFolder(folder);
    return files;
  }
  async processMultipleFolders(folders, action) {
    if (folders.length === 0) return;
    let processed = 0;
    let skipped = 0;
    let errors = 0;
    if (action === "rename") {
      const allFiles = [];
      folders.forEach((folder) => {
        const folderFiles = this.getAllMarkdownFilesInFolder(folder);
        allFiles.push(...folderFiles);
      });
      if (allFiles.length === 0) {
        verboseLog(this, `Showing notice: No markdown files found in selected folders.`);
        new import_obsidian17.Notice(t("notifications.noNotesFoundInFolders"));
        return;
      }
      verboseLog(this, `Showing notice: Renaming ${allFiles.length} files from ${folders.length} folders...`);
      new import_obsidian17.Notice(t("notifications.renamingNNotes").replace("{{count}}", String(allFiles.length)));
      await this.processMultipleFiles(allFiles, "rename");
    } else {
      for (const folder of folders) {
        try {
          const normalizedFolderPath = (0, import_obsidian17.normalizePath)(folder.path);
          const isCurrentlyExcluded = this.settings.excludedFolders.includes(normalizedFolderPath);
          if (action === "disable" && !isCurrentlyExcluded) {
            await this.toggleFolderExclusion(folder.path, true);
            processed++;
          } else if (action === "enable" && isCurrentlyExcluded) {
            await this.toggleFolderExclusion(folder.path, true);
            processed++;
          } else {
            skipped++;
          }
        } catch (error) {
          console.error(`Error processing folder ${folder.path}:`, error);
          errors++;
        }
      }
      verboseLog(this, `${action === "disable" ? "Disabled" : "Enabled"} renaming for ${folders.length} folders.`);
      new import_obsidian17.Notice((action === "enable" ? t("notifications.enabledRenamingInNFolders") : t("notifications.disabledRenamingInNFolders")).replace("{{count}}", String(folders.length)));
    }
  }
};

// src/operations/tag-operations.ts
var import_obsidian18 = require("obsidian");
init_utils();
init_i18n();
var TagOperations = class {
  constructor(app, settings, renameEngine, saveSettings, debugLog) {
    this.app = app;
    this.settings = settings;
    this.renameEngine = renameEngine;
    this.saveSettings = saveSettings;
    this.debugLog = debugLog;
  }
  async putFirstLineInTitleForTag(tagName, omitBodyTags = false, omitNestedTags = false) {
    var _a;
    const tagToFind = tagName.startsWith("#") ? tagName : `#${tagName}`;
    const files = this.app.vault.getMarkdownFiles();
    const matchingFiles = [];
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      let hasTag = false;
      let tagFoundInBody = false;
      if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.tags) {
        const frontmatterTags = Array.isArray(cache.frontmatter.tags) ? cache.frontmatter.tags : [cache.frontmatter.tags];
        hasTag = frontmatterTags.some((tag) => {
          if (omitNestedTags) {
            return tag === tagName || tag === tagToFind;
          } else {
            return tag === tagName || tag === tagToFind || tag.startsWith(tagName + "/") || tag.startsWith(tagToFind + "/");
          }
        });
      }
      if (!hasTag && (cache == null ? void 0 : cache.tags)) {
        cache.tags.forEach((tagCache) => {
          const cacheTag = tagCache.tag;
          let tagMatches = false;
          if (omitNestedTags) {
            tagMatches = cacheTag === tagToFind || cacheTag === `#${tagName}`;
          } else {
            tagMatches = cacheTag === tagToFind || cacheTag === `#${tagName}` || cacheTag.startsWith(tagToFind + "/") || cacheTag.startsWith(`#${tagName}/`);
          }
          if (tagMatches) {
            hasTag = true;
            if (tagCache.position.start.line > 0) {
              if (cache.frontmatterPosition) {
                if (tagCache.position.start.line > cache.frontmatterPosition.end.line) {
                  tagFoundInBody = true;
                }
              } else {
                tagFoundInBody = true;
              }
            }
          }
        });
      }
      if (hasTag && omitBodyTags && tagFoundInBody) {
        continue;
      }
      if (hasTag) {
        matchingFiles.push(file);
      }
    }
    if (matchingFiles.length === 0) {
      verboseLog(this, `Showing notice: No files found with tag ${tagToFind}.`);
      new import_obsidian18.Notice(t("notifications.noNotesFoundWithTag").replace("{{tag}}", tagToFind));
      return;
    }
    verboseLog(this, `Showing notice: Renaming ${matchingFiles.length} files with tag ${tagToFind}...`);
    new import_obsidian18.Notice(t("notifications.renamingNNotes").replace("{{count}}", String(matchingFiles.length)));
    let processedCount = 0;
    let errorCount = 0;
    const exclusionOverrides = { ignoreFolder: true, ignoreTag: true, ignoreProperty: true };
    for (const file of matchingFiles) {
      try {
        await this.renameEngine.processFile(file, true, false, void 0, true, exclusionOverrides);
        processedCount++;
      } catch (error) {
        console.error(`Error processing file ${file.path}:`, error);
        errorCount++;
      }
    }
    if (errorCount > 0) {
      verboseLog(this, `Showing notice: Renamed ${processedCount}/${matchingFiles.length} notes with ${errorCount} errors. Check console for details.`);
      new import_obsidian18.Notice(t("notifications.renamedNotesWithErrors").replace("{{renamed}}", String(processedCount)).replace("{{total}}", String(matchingFiles.length)).replace("{{errors}}", String(errorCount)), 0);
    } else {
      verboseLog(this, `Showing notice: Successfully processed ${processedCount} files with tag ${tagToFind}.`);
      new import_obsidian18.Notice(t("notifications.renamedNotes").replace("{{renamed}}", String(processedCount)).replace("{{total}}", String(matchingFiles.length)), 0);
    }
  }
  async toggleTagExclusion(tagName) {
    const tagToFind = tagName.startsWith("#") ? tagName : `#${tagName}`;
    const isInList = this.settings.excludedTags.includes(tagToFind);
    const isInverted = this.settings.tagScopeStrategy === "Exclude all except...";
    if (isInList) {
      this.settings.excludedTags = this.settings.excludedTags.filter((tag) => tag !== tagToFind);
      if (this.settings.excludedTags.length === 0) {
        this.settings.excludedTags.push("");
      }
      if (isInverted) {
        verboseLog(this, `Showing notice: Renaming disabled for ${tagToFind}`);
        new import_obsidian18.Notice(t("notifications.disabledRenamingFor", { filename: tagToFind }));
      } else {
        verboseLog(this, `Showing notice: Renaming enabled for ${tagToFind}`);
        new import_obsidian18.Notice(t("notifications.enabledRenamingFor", { filename: tagToFind }));
      }
    } else {
      if (this.settings.excludedTags.length === 1 && this.settings.excludedTags[0] === "") {
        this.settings.excludedTags[0] = tagToFind;
      } else {
        this.settings.excludedTags.push(tagToFind);
      }
      if (isInverted) {
        verboseLog(this, `Showing notice: Renaming enabled for ${tagToFind}`);
        new import_obsidian18.Notice(t("notifications.enabledRenamingFor", { filename: tagToFind }));
      } else {
        verboseLog(this, `Showing notice: Renaming disabled for ${tagToFind}`);
        new import_obsidian18.Notice(t("notifications.disabledRenamingFor", { filename: tagToFind }));
      }
    }
    this.debugLog("excludedTags", this.settings.excludedTags);
    await this.saveSettings();
    verboseLog(this, `Tag exclusion toggled for: ${tagToFind}`, { isNowInList: !isInList });
  }
};

// src/core/alias-manager.ts
var import_obsidian19 = require("obsidian");
init_utils();
init_i18n();
var AliasManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.aliasUpdateInProgress = /* @__PURE__ */ new Set();
  }
  get app() {
    return this.plugin.app;
  }
  get settings() {
    return this.plugin.settings;
  }
  isAliasUpdateInProgress(filePath) {
    return this.aliasUpdateInProgress.has(filePath);
  }
  getAliasPropertyKeys() {
    const aliasPropertyKey = this.settings.aliasPropertyKey || "aliases";
    return aliasPropertyKey.split(",").map((key) => key.trim()).filter((key) => key.length > 0);
  }
  async updateAliasIfNeeded(file, providedContent, targetTitle) {
    this.plugin.trackUsage();
    try {
      const currentFile = this.app.vault.getAbstractFileByPath(file.path);
      if (!currentFile || !(currentFile instanceof import_obsidian19.TFile)) {
        verboseLog(this.plugin, `Skipping alias update - file no longer exists: ${file.path}`);
        return;
      }
      file = currentFile;
      const fileKey = file.path;
      if (this.aliasUpdateInProgress.has(fileKey)) {
        verboseLog(this.plugin, `Skipping alias update for ${file.path} - update already in progress`);
        return;
      }
      if (await hasDisablePropertyInFile(file, this.app, this.settings.disableRenamingKey, this.settings.disableRenamingValue)) {
        verboseLog(this.plugin, `Skipping alias update - file has disable property: ${file.path}`);
        return;
      }
      if (!shouldProcessFile(file, this.settings, this.app)) {
        return;
      }
      let content;
      if (providedContent !== void 0) {
        content = providedContent;
        verboseLog(this.plugin, `Using provided content for alias update in ${file.path} (${content.length} chars)`);
      } else if (this.settings.fileReadMethod === "File") {
        content = await this.app.vault.read(file);
      } else {
        content = await this.app.vault.cachedRead(file);
      }
      if (!content || content.trim() === "") {
        return;
      }
      const contentWithoutFrontmatter = this.plugin.renameEngine.stripFrontmatterFromContent(content, file);
      const lines = contentWithoutFrontmatter.split("\n");
      let firstNonEmptyLine = "";
      for (const line of lines) {
        if (line.trim() !== "") {
          firstNonEmptyLine = line;
          break;
        }
      }
      if (!firstNonEmptyLine || firstNonEmptyLine.trim() === "") {
        if (this.settings.enableAliases) {
          await this.removePluginAliasesFromFile(file);
        }
        return;
      }
      const titleSourceLine = findTitleSourceLine(firstNonEmptyLine, lines, this.settings, this.plugin);
      if (!this.settings.enableAliases) {
        return;
      }
      const frontmatterInfo = (0, import_obsidian19.getFrontMatterInfo)(content);
      const frontmatter = frontmatterInfo.exists ? (0, import_obsidian19.parseYaml)(frontmatterInfo.frontmatter) : null;
      const processedFirstLine = extractTitle(firstNonEmptyLine, this.settings);
      const titleToCompare = targetTitle !== void 0 ? targetTitle.trim() : file.basename.trim();
      const processedLineMatchesFilename = processedFirstLine.trim() === titleToCompare;
      const shouldHaveAlias = !this.settings.addAliasOnlyIfFirstLineDiffers || !processedLineMatchesFilename;
      if (!shouldHaveAlias) {
        await this.removePluginAliasesFromFile(file);
        return;
      }
      const aliasPropertyKeys = this.getAliasPropertyKeys();
      const zwspMarker = "\u200B";
      const expectedAlias = this.settings.stripMarkupInAlias ? extractTitle(titleSourceLine, this.settings) : titleSourceLine;
      const expectedAliasWithMarker = zwspMarker + expectedAlias + zwspMarker;
      let allPropertiesHaveCorrectAlias = true;
      for (const aliasPropertyKey of aliasPropertyKeys) {
        let existingAliases = [];
        if (frontmatter && frontmatter[aliasPropertyKey]) {
          if (Array.isArray(frontmatter[aliasPropertyKey])) {
            existingAliases = frontmatter[aliasPropertyKey];
          } else {
            existingAliases = [frontmatter[aliasPropertyKey]];
          }
        }
        const hasCorrectAlias = existingAliases.some(
          (alias) => alias === expectedAliasWithMarker || alias === expectedAlias
        );
        if (!hasCorrectAlias) {
          allPropertiesHaveCorrectAlias = false;
          break;
        }
      }
      if (allPropertiesHaveCorrectAlias) {
        verboseLog(this.plugin, `File ${file.path} already has correct alias in all properties`);
        return;
      }
      this.aliasUpdateInProgress.add(fileKey);
      try {
        verboseLog(this.plugin, `Adding alias to ${file.path} - no correct alias found`);
        await this.addAliasToFile(file, titleSourceLine, titleToCompare, content);
      } finally {
        this.aliasUpdateInProgress.delete(fileKey);
      }
    } catch (error) {
      console.error("Error updating alias:", error);
      this.aliasUpdateInProgress.delete(file.path);
    }
  }
  async addAliasToFile(file, originalFirstNonEmptyLine, newTitle, content) {
    try {
      const currentFile = this.app.vault.getAbstractFileByPath(file.path);
      if (!currentFile || !(currentFile instanceof import_obsidian19.TFile)) {
        verboseLog(this.plugin, `Skipping alias addition - file no longer exists: ${file.path}`);
        return;
      }
      file = currentFile;
      const firstNonEmptyLine = originalFirstNonEmptyLine;
      let aliasProcessedLine = firstNonEmptyLine;
      if (this.settings.enableCustomReplacements && this.settings.applyCustomRulesInAlias) {
        for (const replacement of this.settings.customReplacements) {
          if (replacement.searchText === "" || !replacement.enabled) continue;
          let tempLine = aliasProcessedLine;
          if (replacement.onlyWholeLine) {
            if (aliasProcessedLine.trim() === replacement.searchText.trim()) {
              tempLine = replacement.replaceText;
            }
          } else if (replacement.onlyAtStart) {
            if (tempLine.startsWith(replacement.searchText)) {
              tempLine = replacement.replaceText + tempLine.slice(replacement.searchText.length);
            }
          } else {
            tempLine = tempLine.replaceAll(replacement.searchText, replacement.replaceText);
          }
          aliasProcessedLine = tempLine;
        }
      }
      const originalCharReplacementSetting = this.settings.enableForbiddenCharReplacements;
      const originalStripMarkupSetting = this.settings.enableStripMarkup;
      this.settings.enableForbiddenCharReplacements = false;
      if (!this.settings.stripMarkupInAlias) {
        this.settings.enableStripMarkup = false;
      }
      let aliasToAdd = extractTitle(aliasProcessedLine, this.settings);
      this.settings.enableForbiddenCharReplacements = originalCharReplacementSetting;
      this.settings.enableStripMarkup = originalStripMarkupSetting;
      const targetTitle = newTitle.trim();
      const aliasMatchesFilename = aliasToAdd.trim() === targetTitle;
      const shouldAddAlias = !this.settings.addAliasOnlyIfFirstLineDiffers || !aliasMatchesFilename;
      if (!shouldAddAlias) {
        verboseLog(this.plugin, `Removing plugin aliases and skipping add - alias matches filename: \`${aliasToAdd}\` = \`${targetTitle}\``);
        await this.removePluginAliasesFromFile(file);
        return;
      }
      if (this.settings.truncateAlias) {
        if (aliasToAdd.length > this.settings.charCount - 1) {
          aliasToAdd = aliasToAdd.slice(0, this.settings.charCount - 1).trimEnd() + "\u2026";
        }
      }
      if (!aliasToAdd || aliasToAdd.trim() === "") {
        verboseLog(this.plugin, `Removing plugin alias - no non-empty content found`);
        await this.removePluginAliasesFromFile(file);
        return;
      }
      const untitledWord = t("untitled").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      const untitledPattern = new RegExp(`^${untitledWord}(\\s+[1-9]\\d*)?$`);
      if (untitledPattern.test(aliasToAdd.trim())) {
        const originalFirstLineTrimmed = firstNonEmptyLine.trim();
        if (!untitledPattern.test(originalFirstLineTrimmed)) {
          verboseLog(this.plugin, `Removing plugin alias - extracted title is "${aliasToAdd}" but first line is not literally ${t("untitled")}`);
          await this.removePluginAliasesFromFile(file);
          return;
        }
      }
      const markedAlias = "\u200B" + aliasToAdd + "\u200B";
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian19.MarkdownView);
      if (activeView && activeView.file === file) {
        await activeView.save();
      }
      const lines = content.split("\n");
      const hasFrontmatter = lines.length > 0 && lines[0].trim() === "---";
      if (!hasFrontmatter) {
        const currentFileForFrontmatter = this.app.vault.getAbstractFileByPath(file.path);
        if (!currentFileForFrontmatter || !(currentFileForFrontmatter instanceof import_obsidian19.TFile)) {
          verboseLog(this.plugin, `Skipping frontmatter creation - file no longer exists: ${file.path}`);
          return;
        }
        const aliasPropertyKeys2 = this.getAliasPropertyKeys();
        this.plugin.markFlitModificationStart(currentFileForFrontmatter.path);
        await this.app.fileManager.processFrontMatter(currentFileForFrontmatter, (frontmatter) => {
          for (const aliasPropertyKey of aliasPropertyKeys2) {
            if (aliasPropertyKey === "aliases") {
              frontmatter[aliasPropertyKey] = [markedAlias];
            } else {
              frontmatter[aliasPropertyKey] = markedAlias;
            }
          }
        });
        this.plugin.markFlitModificationEnd(currentFileForFrontmatter.path);
        this.plugin.pendingMetadataUpdates.add(currentFileForFrontmatter.path);
        verboseLog(this.plugin, `Created frontmatter and added alias \`${aliasToAdd}\` to ${currentFileForFrontmatter.path}`);
        return;
      }
      const currentFileForUpdate = this.app.vault.getAbstractFileByPath(file.path);
      if (!currentFileForUpdate || !(currentFileForUpdate instanceof import_obsidian19.TFile)) {
        verboseLog(this.plugin, `Skipping frontmatter update - file no longer exists: ${file.path}`);
        return;
      }
      const aliasPropertyKeys = this.getAliasPropertyKeys();
      this.plugin.markFlitModificationStart(currentFileForUpdate.path);
      await this.app.fileManager.processFrontMatter(currentFileForUpdate, (frontmatter) => {
        for (const aliasPropertyKey of aliasPropertyKeys) {
          if (aliasPropertyKey === "aliases") {
            let existingAliases = [];
            if (frontmatter[aliasPropertyKey]) {
              if (Array.isArray(frontmatter[aliasPropertyKey])) {
                existingAliases = [...frontmatter[aliasPropertyKey]];
              } else {
                existingAliases = [frontmatter[aliasPropertyKey]];
              }
            }
            existingAliases = existingAliases.filter(
              (alias) => !(typeof alias === "string" && alias.startsWith("\u200B") && alias.endsWith("\u200B")) && alias !== ""
            );
            if (!existingAliases.includes(aliasToAdd)) {
              existingAliases.push(markedAlias);
              frontmatter[aliasPropertyKey] = existingAliases;
            } else {
              if (existingAliases.length === 0) {
                if (this.settings.keepEmptyAliasProperty) {
                  frontmatter[aliasPropertyKey] = null;
                } else {
                  delete frontmatter[aliasPropertyKey];
                }
              } else {
                frontmatter[aliasPropertyKey] = existingAliases;
              }
            }
          } else {
            const propertyExists = frontmatter.hasOwnProperty(aliasPropertyKey);
            if (!propertyExists || frontmatter[aliasPropertyKey] === null || frontmatter[aliasPropertyKey] === void 0 || frontmatter[aliasPropertyKey] === "") {
              frontmatter[aliasPropertyKey] = markedAlias;
            } else {
              let existingValues = [];
              if (Array.isArray(frontmatter[aliasPropertyKey])) {
                existingValues = [...frontmatter[aliasPropertyKey]];
              } else {
                existingValues = [frontmatter[aliasPropertyKey]];
              }
              const userValues = existingValues.filter(
                (value) => !(typeof value === "string" && value.startsWith("\u200B") && value.endsWith("\u200B")) && value !== ""
              );
              if (!userValues.includes(aliasToAdd)) {
                if (userValues.length === 0) {
                  frontmatter[aliasPropertyKey] = markedAlias;
                } else {
                  userValues.push(markedAlias);
                  frontmatter[aliasPropertyKey] = userValues;
                }
              } else {
                if (userValues.length === 0) {
                  if (this.settings.keepEmptyAliasProperty) {
                    frontmatter[aliasPropertyKey] = null;
                  } else {
                    delete frontmatter[aliasPropertyKey];
                  }
                } else if (userValues.length === 1) {
                  frontmatter[aliasPropertyKey] = userValues[0];
                } else {
                  frontmatter[aliasPropertyKey] = userValues;
                }
              }
            }
          }
        }
      });
      this.plugin.markFlitModificationEnd(currentFileForUpdate.path);
      this.plugin.pendingMetadataUpdates.add(currentFileForUpdate.path);
      verboseLog(this.plugin, `Updated alias \`${aliasToAdd}\` in ${currentFileForUpdate.path}`);
    } catch (error) {
      if (error.code === "ENOENT") {
        verboseLog(this.plugin, `Skipping alias addition - file was renamed during operation: ${file.path}`);
      } else {
        console.error(`Failed to add alias to file ${file.path}:`, error);
      }
    }
  }
  async removePluginAliasesFromFile(file, forceCompleteRemoval = false) {
    try {
      const currentFile = this.app.vault.getAbstractFileByPath(file.path);
      if (!currentFile || !(currentFile instanceof import_obsidian19.TFile)) {
        verboseLog(this.plugin, `Skipping alias removal - file no longer exists: ${file.path}`);
        return;
      }
      file = currentFile;
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian19.MarkdownView);
      if (activeView && activeView.file === file) {
        await activeView.save();
      }
      const currentFileForRemoval = this.app.vault.getAbstractFileByPath(file.path);
      if (!currentFileForRemoval || !(currentFileForRemoval instanceof import_obsidian19.TFile)) {
        verboseLog(this.plugin, `Skipping alias removal - file no longer exists: ${file.path}`);
        return;
      }
      this.plugin.markFlitModificationStart(currentFileForRemoval.path);
      await this.app.fileManager.processFrontMatter(currentFileForRemoval, (frontmatter) => {
        const aliasPropertyKeys = this.getAliasPropertyKeys();
        for (const aliasPropertyKey of aliasPropertyKeys) {
          if (frontmatter[aliasPropertyKey]) {
            let existingValues = [];
            if (Array.isArray(frontmatter[aliasPropertyKey])) {
              existingValues = [...frontmatter[aliasPropertyKey]];
            } else {
              existingValues = [frontmatter[aliasPropertyKey]];
            }
            const filteredValues = existingValues.filter(
              (value) => !(typeof value === "string" && value.startsWith("\u200B") && value.endsWith("\u200B")) && value !== ""
            );
            if (filteredValues.length === 0) {
              if (forceCompleteRemoval || !this.settings.keepEmptyAliasProperty) {
                delete frontmatter[aliasPropertyKey];
              } else {
                frontmatter[aliasPropertyKey] = null;
              }
            } else if (filteredValues.length === 1 && aliasPropertyKey !== "aliases") {
              frontmatter[aliasPropertyKey] = filteredValues[0];
            } else {
              frontmatter[aliasPropertyKey] = filteredValues;
            }
          }
        }
      });
      this.plugin.markFlitModificationEnd(currentFileForRemoval.path);
      this.plugin.pendingMetadataUpdates.add(currentFileForRemoval.path);
      verboseLog(this.plugin, `Removed plugin aliases from ${currentFileForRemoval.path}`);
    } catch (error) {
      if (error.code === "ENOENT") {
        verboseLog(this.plugin, `Skipping alias removal - file was renamed during operation: ${file.path}`);
      } else {
        console.error(`Failed to remove plugin aliases from ${file.path}:`, error);
      }
    }
  }
  async removeAliasFromFile(file, aliasToRemove) {
    try {
      const trimmedAlias = aliasToRemove.trim();
      if (!trimmedAlias) {
        return;
      }
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian19.MarkdownView);
      if (activeView && activeView.file === file) {
        await activeView.save();
      }
      this.plugin.markFlitModificationStart(file.path);
      await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
        const aliasPropertyKeys = this.getAliasPropertyKeys();
        for (const aliasPropertyKey of aliasPropertyKeys) {
          if (frontmatter[aliasPropertyKey]) {
            let existingAliases = [];
            if (Array.isArray(frontmatter[aliasPropertyKey])) {
              existingAliases = [...frontmatter[aliasPropertyKey]];
            } else {
              existingAliases = [frontmatter[aliasPropertyKey]];
            }
            const filteredAliases = existingAliases.filter((alias) => alias !== trimmedAlias && alias !== "");
            if (filteredAliases.length === 0) {
              if (this.settings.keepEmptyAliasProperty) {
                frontmatter[aliasPropertyKey] = null;
              } else {
                delete frontmatter[aliasPropertyKey];
              }
            } else {
              frontmatter[aliasPropertyKey] = filteredAliases;
            }
          }
        }
      });
      this.plugin.markFlitModificationEnd(file.path);
      verboseLog(this.plugin, `Removed alias "${trimmedAlias}" from ${file.path}`);
    } catch (error) {
      console.error(`Failed to remove alias from ${file.path}:`, error);
    }
  }
};

// src/operations/file-operations.ts
var import_obsidian20 = require("obsidian");
init_utils();
init_i18n();
init_constants();
var FileOperations = class {
  constructor(plugin) {
    this.plugin = plugin;
    // Track files waiting for YAML with their resolve callbacks and timeout timers
    this.yamlWaiters = /* @__PURE__ */ new Map();
  }
  get app() {
    return this.plugin.app;
  }
  get settings() {
    return this.plugin.settings;
  }
  /**
   * Cleans up stale entries from caches (deprecated - now handled by cache manager)
   */
  cleanupStaleCache() {
    verboseLog(this.plugin, "Cache cleanup delegated to CacheManager");
  }
  /**
   * Inserts the filename as the first line of a newly created file
   * @param initialContent - Optional initial content captured at file creation time
   * @param templateContent - Optional template content captured after template wait (skips internal wait)
   * @returns true if title was inserted, false if skipped
   */
  async insertTitleOnCreation(file, initialContent, templateContent) {
    var _a, _b, _c;
    try {
      const untitledWord = t("untitled").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      const untitledPattern = new RegExp(`^${untitledWord}(\\s[1-9]\\d*)?$`);
      if (untitledPattern.test(file.basename)) {
        verboseLog(this.plugin, `Skipping title insertion for untitled file: ${file.path}`);
        return false;
      }
      let cleanTitle = file.basename;
      const replacementCharToKey = {
        "\u2215": "slash",
        "\u0589": "colon",
        "\u2217": "asterisk",
        "\uFE56": "question",
        "\u2039": "lessThan",
        "\u203A": "greaterThan",
        "\uFF02": "quote",
        "\u2758": "pipe",
        "\uFF03": "hash",
        "\uFF3B": "leftBracket",
        "\uFF3D": "rightBracket",
        "\u02C6": "caret",
        "\u29F5": "backslash",
        "\u2024": "dot"
      };
      const punctuation = `,.?;:!"'""''\xBB\xAB\xA1\xBF\u203D`;
      for (const [replacementChar, originalChar] of Object.entries(TITLE_CHAR_REVERSAL_MAP)) {
        if (!cleanTitle.includes(replacementChar)) continue;
        const settingKey = replacementCharToKey[replacementChar];
        if (!settingKey) continue;
        const replacementEnabled = this.settings.charReplacementEnabled[settingKey];
        const trimLeft = this.settings.charReplacementTrimLeft[settingKey];
        const trimRight = this.settings.charReplacementTrimRight[settingKey];
        if (!replacementEnabled) {
          cleanTitle = cleanTitle.replaceAll(replacementChar, originalChar);
          continue;
        }
        let result = "";
        let remaining = cleanTitle;
        while (remaining.includes(replacementChar)) {
          const index = remaining.indexOf(replacementChar);
          result += remaining.substring(0, index);
          let replacement = originalChar;
          if (trimLeft) {
            replacement = " " + replacement;
          }
          if (trimRight) {
            const charToRight = remaining.length > index + 1 ? remaining[index + 1] : "";
            if (!punctuation.includes(charToRight)) {
              replacement = replacement + " ";
            }
          }
          result += replacement;
          remaining = remaining.substring(index + 1);
        }
        result += remaining;
        cleanTitle = result;
      }
      if (this.settings.addHeadingToTitle) {
        cleanTitle = "# " + cleanTitle;
      }
      verboseLog(this.plugin, `Inserting title "${cleanTitle}" in new file: ${file.path}`);
      let currentContent;
      if (templateContent !== void 0) {
        currentContent = templateContent;
        verboseLog(this.plugin, `[TITLE-INSERT] Using provided template content. Length: ${currentContent.length} chars`);
      } else if (this.settings.waitForTemplate) {
        verboseLog(this.plugin, `[TITLE-INSERT] Template wait enabled, checking delays`);
        const templateWaitTime = this.settings.fileReadMethod === "Cache" || this.settings.fileReadMethod === "File" ? 2500 : 600;
        const remainingWait = templateWaitTime - this.settings.newNoteDelay;
        verboseLog(this.plugin, `[TITLE-INSERT] Template wait calculation: templateWaitTime=${templateWaitTime}ms, newNoteDelay=${this.settings.newNoteDelay}ms, remainingWait=${remainingWait}ms`);
        if (remainingWait > 0) {
          if (this.settings.fileReadMethod === "Cache" || this.settings.fileReadMethod === "File") {
            verboseLog(this.plugin, `[TITLE-INSERT] Waiting full ${remainingWait}ms for template (${this.settings.fileReadMethod} read method, total: ${templateWaitTime}ms)`);
            await new Promise((resolve) => setTimeout(resolve, remainingWait));
          } else {
            verboseLog(this.plugin, `[TITLE-INSERT] Starting YAML wait for ${remainingWait}ms (Editor mode)`);
            await this.waitForYamlOrTimeout(file, remainingWait);
            verboseLog(this.plugin, `[TITLE-INSERT] YAML wait completed`);
          }
        } else {
          verboseLog(this.plugin, `Skipping template wait - newNoteDelay (${this.settings.newNoteDelay}ms) already >= ${templateWaitTime}ms`);
        }
        verboseLog(this.plugin, `[TITLE-INSERT] Re-reading content after template wait`);
        const leaves2 = this.app.workspace.getLeavesOfType("markdown");
        let foundEditor = false;
        for (const leaf of leaves2) {
          const view = leaf.view;
          if (view && ((_a = view.file) == null ? void 0 : _a.path) === file.path && view.editor) {
            currentContent = view.editor.getValue();
            verboseLog(this.plugin, `[TITLE-INSERT] Read fresh content from editor after template wait. Length: ${currentContent.length} chars`);
            foundEditor = true;
            break;
          }
        }
        if (!foundEditor) {
          currentContent = await this.app.vault.read(file);
          verboseLog(this.plugin, `[TITLE-INSERT] Read fresh content from vault after template wait. Length: ${currentContent.length} chars`);
        }
      } else if (initialContent !== void 0) {
        currentContent = initialContent;
        verboseLog(this.plugin, `[TITLE-INSERT] No template wait, using initial content. Length: ${currentContent.length} chars`);
      } else {
        verboseLog(this.plugin, `[TITLE-INSERT] No template wait, reading immediately from editor`);
        const leaves2 = this.app.workspace.getLeavesOfType("markdown");
        let foundEditor = false;
        for (const leaf of leaves2) {
          const view = leaf.view;
          if (view && ((_b = view.file) == null ? void 0 : _b.path) === file.path && view.editor) {
            currentContent = view.editor.getValue();
            verboseLog(this.plugin, `[TITLE-INSERT] Read content immediately from editor. Length: ${currentContent.length} chars`);
            foundEditor = true;
            break;
          }
        }
        if (!foundEditor) {
          try {
            currentContent = await this.app.vault.read(file);
            verboseLog(this.plugin, `[TITLE-INSERT] Read content immediately from vault. Length: ${currentContent.length} chars`);
          } catch (error) {
            console.error(`Failed to read file ${file.path} for title insertion:`, error);
            return false;
          }
        }
      }
      const lines = currentContent.split("\n");
      let yamlEndLine = -1;
      if (lines[0] === "---") {
        for (let i = 1; i < lines.length; i++) {
          if (lines[i] === "---") {
            yamlEndLine = i;
            break;
          }
        }
      }
      const contentAfterYaml = yamlEndLine !== -1 ? lines.slice(yamlEndLine + 1).join("\n").trim() : currentContent.trim();
      if (contentAfterYaml !== "") {
        verboseLog(this.plugin, `File has content (excluding YAML), skipping title insertion for ${file.path}`);
        return false;
      }
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      let insertedViaEditor = false;
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view && ((_c = view.file) == null ? void 0 : _c.path) === file.path && view.editor) {
          if (yamlEndLine !== -1) {
            const insertLine = yamlEndLine + 1;
            view.editor.replaceRange(cleanTitle + "\n", { line: insertLine, ch: 0 });
            verboseLog(this.plugin, `[TITLE-INSERT] Inserted title after frontmatter at line ${insertLine} via editor`);
          } else {
            view.editor.replaceRange(cleanTitle + "\n", { line: 0, ch: 0 });
            verboseLog(this.plugin, `[TITLE-INSERT] Inserted title at beginning via editor`);
          }
          insertedViaEditor = true;
          break;
        }
      }
      if (!insertedViaEditor) {
        if (yamlEndLine !== -1) {
          const lines2 = currentContent.split("\n");
          const insertLine = yamlEndLine + 1;
          lines2.splice(insertLine, 0, cleanTitle);
          const newContent = lines2.join("\n");
          verboseLog(this.plugin, `[TITLE-INSERT] Inserting title after frontmatter at line ${insertLine} via vault`);
          await this.app.vault.modify(file, newContent);
        } else {
          verboseLog(this.plugin, `[TITLE-INSERT] Inserting title at beginning via vault`);
          await this.app.vault.modify(file, cleanTitle + "\n");
        }
      }
      verboseLog(this.plugin, `Successfully inserted title in ${file.path}`);
      return true;
    } catch (error) {
      console.error(`Error inserting title on creation for ${file.path}:`, error);
      return false;
    }
  }
  /**
   * Wait for YAML to appear or timeout
   * Public method for use by workspace-integration
   */
  async waitForYamlOrTimeout(file, timeoutMs) {
    return new Promise((resolve) => {
      const startTime = Date.now();
      const timeoutTimer = setTimeout(() => {
        const waiter = this.yamlWaiters.get(file.path);
        if (waiter) {
          this.yamlWaiters.delete(file.path);
          verboseLog(this.plugin, `Template wait timeout (${timeoutMs}ms) reached for ${file.path}`);
          resolve();
        }
      }, timeoutMs);
      this.yamlWaiters.set(file.path, { resolve, startTime, timeoutTimer });
    });
  }
  /**
   * Check if file has YAML and resolve waiting promise if found
   * Called from editor-change event
   */
  checkYamlAndResolve(file, content) {
    const waiter = this.yamlWaiters.get(file.path);
    if (!waiter) return;
    if (content.startsWith("---")) {
      const lines = content.split("\n");
      for (let i = 1; i < lines.length; i++) {
        if (lines[i] === "---") {
          const elapsed = Date.now() - waiter.startTime;
          verboseLog(this.plugin, `YAML detected after ${elapsed}ms for ${file.path}`);
          clearTimeout(waiter.timeoutTimer);
          this.yamlWaiters.delete(file.path);
          waiter.resolve();
          return;
        }
      }
    }
  }
  /**
   * Handles cursor positioning after title insertion
   * @param file - The file to position cursor in
   * @param usePlaceCursorAtLineEndSetting - Whether to respect placeCursorAtLineEnd setting (true when title insertion is OFF)
   */
  async handleCursorPositioning(file, usePlaceCursorAtLineEndSetting = true) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    try {
      verboseLog(this.plugin, `handleCursorPositioning called for ${file.path}, usePlaceCursorAtLineEndSetting: ${usePlaceCursorAtLineEndSetting}`);
      let targetView = null;
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view && ((_a = view.file) == null ? void 0 : _a.path) === file.path) {
          targetView = view;
          break;
        }
      }
      verboseLog(this.plugin, `Target view found: ${!!targetView}, file matches: ${((_b = targetView == null ? void 0 : targetView.file) == null ? void 0 : _b.path) === file.path}`);
      if (targetView && ((_c = targetView.file) == null ? void 0 : _c.path) === file.path) {
        await targetView.leaf.setViewState({
          type: "markdown",
          state: {
            mode: "source",
            source: false
          }
        });
        await ((_d = targetView.editor) == null ? void 0 : _d.focus());
        let titleLineNumber = 0;
        let titleLineLength = 0;
        const content = ((_e = targetView.editor) == null ? void 0 : _e.getValue()) || "";
        const lines = content.split("\n");
        let yamlEndLine = -1;
        if (lines[0] === "---") {
          for (let i = 1; i < lines.length; i++) {
            if (lines[i] === "---") {
              yamlEndLine = i;
              break;
            }
          }
        }
        if (yamlEndLine !== -1) {
          titleLineNumber = yamlEndLine + 1;
          verboseLog(this.plugin, `Found frontmatter ending at line ${yamlEndLine}, title on line ${titleLineNumber}`);
        } else {
          titleLineNumber = 0;
          verboseLog(this.plugin, `No frontmatter found, title on line ${titleLineNumber}`);
        }
        titleLineLength = ((_g = (_f = targetView.editor) == null ? void 0 : _f.getLine(titleLineNumber)) == null ? void 0 : _g.length) || 0;
        const shouldPlaceAtEnd = usePlaceCursorAtLineEndSetting && this.settings.moveCursorToFirstLine && this.settings.placeCursorAtLineEnd;
        if (shouldPlaceAtEnd) {
          (_h = targetView.editor) == null ? void 0 : _h.setCursor({ line: titleLineNumber, ch: titleLineLength });
          verboseLog(this.plugin, `Moved cursor to end of title line ${titleLineNumber} (${titleLineLength} chars) via handleCursorPositioning for ${file.path}`);
        } else {
          (_i = targetView.editor) == null ? void 0 : _i.setCursor({ line: titleLineNumber, ch: 0 });
          verboseLog(this.plugin, `Moved cursor to start of title line ${titleLineNumber} via handleCursorPositioning for ${file.path}`);
        }
      } else {
        verboseLog(this.plugin, `Skipping cursor positioning - no matching active view for ${file.path}`);
      }
    } catch (error) {
      console.error(`Error positioning cursor for ${file.path}:`, error);
    }
  }
  /**
   * Checks if a file is currently open in an editor
   */
  isFileOpenInEditor(file) {
    let isOpen = false;
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a;
      if (leaf.view instanceof import_obsidian20.MarkdownView && ((_a = leaf.view.file) == null ? void 0 : _a.path) === file.path) {
        isOpen = true;
      }
    });
    return isOpen;
  }
  /**
   * Check if file is excluded from processing (folder/tag/property exclusions + disable property)
   * Uses real-time content checking for tags if content provided
   * @param skipFolderCheck - If true, ignore folder exclusions (only check tags/properties)
   */
  async isFileExcludedForCursorPositioning(file, content, skipFolderCheck = false) {
    const exclusionOverrides = skipFolderCheck ? { ignoreFolder: true } : void 0;
    if (!shouldProcessFile(file, this.settings, this.app, content, exclusionOverrides)) {
      return true;
    }
    if (content) {
      const hasDisableProperty = this.checkDisablePropertyInContent(content);
      if (hasDisableProperty) {
        return true;
      }
    } else {
      if (await hasDisablePropertyInFile(file, this.app, this.settings.disableRenamingKey, this.settings.disableRenamingValue)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Check for disable property and excluded properties by parsing YAML directly from content
   */
  checkDisablePropertyInContent(content) {
    const lines = content.split("\n");
    if (lines[0] !== "---") return false;
    let yamlEndLine = -1;
    for (let i = 1; i < lines.length; i++) {
      if (lines[i] === "---") {
        yamlEndLine = i;
        break;
      }
    }
    if (yamlEndLine === -1) return false;
    const yamlLines = lines.slice(1, yamlEndLine);
    const disableKey = this.settings.disableRenamingKey;
    const disableValue = this.settings.disableRenamingValue.toLowerCase();
    const nonEmptyExcludedProps = this.settings.excludedProperties.filter(
      (prop) => prop.key.trim() !== ""
    );
    let currentKey = "";
    let inArray = false;
    for (const line of yamlLines) {
      const trimmed = line.trim();
      if (trimmed === "" || trimmed.startsWith("#")) continue;
      if (trimmed.startsWith("- ")) {
        if (inArray && currentKey) {
          let arrayValue = trimmed.substring(2).trim();
          if (arrayValue.startsWith('"') && arrayValue.endsWith('"') || arrayValue.startsWith("'") && arrayValue.endsWith("'")) {
            arrayValue = arrayValue.substring(1, arrayValue.length - 1);
          }
          const normalizedArrayValue = arrayValue.startsWith("#") ? arrayValue.substring(1) : arrayValue;
          if (currentKey === disableKey && arrayValue.toLowerCase() === disableValue) {
            verboseLog(this.plugin, `Found disable property in array: ${currentKey}: [${arrayValue}]`);
            return true;
          }
          for (const excludedProp of nonEmptyExcludedProps) {
            const propKey = excludedProp.key.trim();
            const propValue = excludedProp.value.trim();
            if (currentKey === propKey) {
              if (propKey === "tags") {
                const normalizedPropValue = propValue.startsWith("#") ? propValue.substring(1) : propValue;
                if (propValue === "" || normalizedArrayValue === normalizedPropValue) {
                  verboseLog(this.plugin, `Found excluded tag in array: ${propKey}: [${arrayValue}]`);
                  return true;
                }
              } else {
                if (propValue === "" || arrayValue === propValue) {
                  verboseLog(this.plugin, `Found excluded property in array: ${propKey}: [${arrayValue}]`);
                  return true;
                }
              }
            }
          }
        }
        continue;
      }
      if (trimmed.includes(":")) {
        const colonIndex = trimmed.indexOf(":");
        const key = trimmed.substring(0, colonIndex).trim();
        const value = trimmed.substring(colonIndex + 1).trim();
        currentKey = key;
        if (value === "" || value === "[") {
          inArray = true;
          continue;
        } else {
          inArray = false;
        }
        if (key === disableKey && value.toLowerCase() === disableValue) {
          verboseLog(this.plugin, `Found disable property: ${key}: ${value}`);
          return true;
        }
        for (const excludedProp of nonEmptyExcludedProps) {
          const propKey = excludedProp.key.trim();
          const propValue = excludedProp.value.trim();
          if (key === propKey) {
            if (propValue === "" || value === propValue) {
              verboseLog(this.plugin, `Found excluded property: ${propKey}: ${value}`);
              return true;
            }
          }
        }
      }
    }
    return false;
  }
};

// src/ui/property-visibility.ts
var PropertyVisibility = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  get settings() {
    return this.plugin.settings;
  }
  /**
   * Parse comma-separated property keys from settings
   * @returns Array of property keys, defaults to ['aliases'] if empty
   */
  getAliasPropertyKeys() {
    const aliasPropertyKey = this.settings.aliasPropertyKey || "aliases";
    return aliasPropertyKey.split(",").map((key) => key.trim()).filter((key) => key.length > 0);
  }
  /**
   * Sets up property hiding for specified property keys using DOM observation
   */
  setupPropertyHiding(propertyKeys) {
    this.cleanupPropertyObserver();
    this.propertyObserver = new MutationObserver((mutations) => {
      mutations.forEach(() => {
        propertyKeys.forEach((propertyKey) => {
          this.hideProperties(propertyKey);
        });
      });
    });
    this.propertyObserver.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ["data-property-key"]
    });
    propertyKeys.forEach((propertyKey) => {
      this.hideProperties(propertyKey);
    });
  }
  /**
   * Hides properties based on current settings and context
   */
  hideProperties(propertyKey) {
    const properties = document.querySelectorAll(`[data-property-key="${propertyKey}"]`);
    properties.forEach((property) => {
      var _a;
      const isInSourceView = property.closest(".cm-editor") && !property.closest(".metadata-container");
      if (isInSourceView) {
        return;
      }
      const isInSidebar = property.closest(".workspace-leaf-content") && !property.closest('.workspace-leaf-content[data-type="markdown"]') && !property.closest(".markdown-source-view") && !property.closest(".markdown-preview-view");
      let shouldHide = false;
      if (this.settings.hideAliasProperty === "always") {
        if (isInSidebar && !this.settings.hideAliasInSidebar) {
          shouldHide = false;
        } else {
          shouldHide = true;
        }
      } else if (this.settings.hideAliasProperty === "when_empty") {
        const valueContainer = property.querySelector(".metadata-property-value");
        const isEmpty = !valueContainer || ((_a = valueContainer.textContent) == null ? void 0 : _a.trim()) === "" || valueContainer.children.length === 0;
        if (isEmpty) {
          if (isInSidebar && !this.settings.hideAliasInSidebar) {
            shouldHide = false;
          } else {
            shouldHide = true;
          }
        } else {
          shouldHide = false;
        }
      }
      const metadataContainer = property.closest(".metadata-container");
      const metadataProperties = property.closest(".metadata-properties");
      if (shouldHide) {
        if (metadataProperties) {
          const allProperties = metadataProperties.querySelectorAll(".metadata-property[data-property-key]");
          if (allProperties.length === 1 && allProperties[0] === property) {
            if (isInSidebar) {
              metadataProperties.addClass("flit-container-hidden");
              metadataProperties.removeClass("flit-container-visible");
            } else {
              if (metadataContainer) {
                metadataContainer.addClass("flit-container-hidden");
                metadataContainer.removeClass("flit-container-visible");
              } else {
                metadataProperties.addClass("flit-container-hidden");
                metadataProperties.removeClass("flit-container-visible");
              }
            }
          } else {
            property.addClass("flit-property-hidden");
            property.removeClass("flit-property-visible");
            metadataProperties.removeClass("flit-container-hidden");
            metadataProperties.addClass("flit-container-visible");
            if (metadataContainer) {
              metadataContainer.removeClass("flit-container-hidden");
              metadataContainer.addClass("flit-container-visible");
            }
          }
        } else {
          property.addClass("flit-property-hidden");
          property.removeClass("flit-property-visible");
        }
      } else {
        property.removeClass("flit-property-hidden");
        property.addClass("flit-property-visible");
        if (metadataProperties) {
          metadataProperties.removeClass("flit-container-hidden");
          metadataProperties.addClass("flit-container-visible");
        }
        if (metadataContainer) {
          metadataContainer.removeClass("flit-container-hidden");
          metadataContainer.addClass("flit-container-visible");
        }
      }
    });
  }
  /**
   * Cleans up the property observer and restores any hidden elements
   */
  cleanupPropertyObserver() {
    if (this.propertyObserver) {
      this.propertyObserver.disconnect();
      this.propertyObserver = void 0;
    }
    const hiddenProperties = document.querySelectorAll(".flit-property-hidden");
    hiddenProperties.forEach((property) => {
      property.removeClass("flit-property-hidden");
      property.addClass("flit-property-visible");
    });
    const hiddenContainers = document.querySelectorAll(".flit-container-hidden");
    hiddenContainers.forEach((container) => {
      container.removeClass("flit-container-hidden");
      container.addClass("flit-container-visible");
    });
  }
  /**
   * Updates property visibility based on current settings
   */
  updatePropertyVisibility() {
    var _a;
    (_a = document.head.querySelector("#flit-hide-property-style")) == null ? void 0 : _a.remove();
    this.cleanupPropertyObserver();
    if (this.settings.hideAliasProperty === "never") {
      return;
    }
    const propertyKeys = this.getAliasPropertyKeys();
    if (this.settings.hideAliasProperty === "always" || this.settings.hideAliasProperty === "when_empty") {
      this.setupPropertyHiding(propertyKeys);
    }
  }
  /**
   * Cleans up all property visibility related observers and styles
   */
  cleanup() {
    this.cleanupPropertyObserver();
  }
};

// node_modules/monkey-around/dist/index.mjs
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const inherited = obj[method], hadOwn = obj.hasOwnProperty(method), original = hadOwn ? inherited : function() {
    return Object.getPrototypeOf(obj)[method].apply(this, arguments);
  };
  let current = createWrapper(original);
  if (inherited)
    Object.setPrototypeOf(current, inherited);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, inherited || Function);
  }
}

// src/core/cache-manager.ts
var DEFAULT_CACHE_CONFIG = {
  maxContentEntries: 1e3,
  maxOperationEntries: 500,
  maintenanceIntervalMs: 3e5,
  // 5 minutes - safety net for edge case cleanup
  staleThresholdMs: 10 * 60 * 1e3
};
var LRUCache = class {
  constructor(maxSize) {
    this.maxSize = maxSize;
    this.cache = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }
  get(key) {
    const value = this.cache.get(key);
    if (value !== void 0) {
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }
  has(key) {
    return this.cache.has(key);
  }
  delete(key) {
    return this.cache.delete(key);
  }
  clear() {
    this.cache.clear();
  }
  size() {
    return this.cache.size;
  }
  keys() {
    return this.cache.keys();
  }
};
var FileExistenceCache = class {
  constructor(plugin) {
    this.pathCache = /* @__PURE__ */ new Set();
    this.lastUpdate = 0;
    this.cacheTTL = 5e3;
    this.plugin = plugin;
  }
  exists(path) {
    const now = Date.now();
    if (now - this.lastUpdate > this.cacheTTL) {
      this.rebuildCache();
      this.lastUpdate = now;
    }
    return this.pathCache.has(path.toLowerCase()) || this.plugin.app.vault.getAbstractFileByPath(path) !== null;
  }
  rebuildCache() {
    this.pathCache.clear();
    const files = this.plugin.app.vault.getAllLoadedFiles();
    for (const file of files) {
      this.pathCache.add(file.path.toLowerCase());
    }
  }
  addPath(path) {
    this.pathCache.add(path.toLowerCase());
  }
  removePath(path) {
    this.pathCache.delete(path.toLowerCase());
  }
  clear() {
    this.pathCache.clear();
    this.lastUpdate = 0;
  }
};
var CacheManager = class {
  constructor(plugin, config = DEFAULT_CACHE_CONFIG) {
    // Maintenance
    this.maintenanceTimer = null;
    this.isDisposed = false;
    this.config = config;
    this.contentCache = new LRUCache(config.maxContentEntries);
    this.tempPaths = /* @__PURE__ */ new Set();
    this.fileExistence = new FileExistenceCache(plugin);
    this.operationTracker = /* @__PURE__ */ new Map();
    this.aliasTimers = /* @__PURE__ */ new Map();
    this.aliasInProgress = /* @__PURE__ */ new Set();
    this.firstRenames = /* @__PURE__ */ new Set();
    if (config.maintenanceIntervalMs > 0) {
      this.startMaintenance();
    }
  }
  // ==================== CONTENT CACHE ====================
  /**
   * Get cached content for a file - O(1) operation
   */
  getContent(filePath) {
    return this.contentCache.get(filePath);
  }
  /**
   * Store content in cache - O(1) operation with LRU eviction
   */
  setContent(filePath, content) {
    this.contentCache.set(filePath, content);
  }
  /**
   * Check if content has changed - O(1) operation
   */
  hasContentChanged(filePath, currentContent) {
    const cachedContent = this.contentCache.get(filePath);
    return cachedContent !== currentContent;
  }
  // ==================== TEMP PATHS (CONFLICT PREVENTION) ====================
  /**
   * Reserve a path to prevent conflicts - O(1) operation (vs O(n) with array)
   */
  reservePath(path) {
    this.tempPaths.add(path.toLowerCase());
  }
  /**
   * Release a reserved path - O(1) operation
   */
  releasePath(path) {
    this.tempPaths.delete(path.toLowerCase());
  }
  /**
   * Release multiple paths at once (for batch operations)
   */
  releasePathsBatch(paths) {
    for (const path of paths) {
      this.tempPaths.delete(path.toLowerCase());
    }
  }
  /**
   * Clear all reserved paths (for immediate cleanup after batch operations)
   */
  clearReservedPaths() {
    this.tempPaths.clear();
  }
  /**
   * Check if path is reserved - O(1) operation (vs O(n) with array.some())
   */
  isPathReserved(path) {
    return this.tempPaths.has(path.toLowerCase());
  }
  /**
   * Check for path conflicts - O(1) operation combining existence + reservation
   */
  hasPathConflict(path) {
    return this.fileExistence.exists(path) || this.isPathReserved(path);
  }
  // ==================== FILE EXISTENCE CACHE ====================
  /**
   * Check if file exists - O(1) with TTL cache
   */
  fileExists(path) {
    return this.fileExistence.exists(path);
  }
  /**
   * Notify cache of new file creation
   */
  notifyFileCreated(path) {
    this.fileExistence.addPath(path);
  }
  /**
   * Notify cache of file deletion
   */
  notifyFileDeleted(path) {
    this.fileExistence.removePath(path);
    this.contentCache.delete(path);
    this.releasePath(path);
    this.operationTracker.delete(path);
    this.firstRenames.delete(path);
  }
  /**
   * Update cache when file is renamed
   */
  notifyFileRenamed(oldPath, newPath) {
    const content = this.contentCache.get(oldPath);
    if (content !== void 0) {
      this.contentCache.delete(oldPath);
      this.contentCache.set(newPath, content);
    }
    this.fileExistence.removePath(oldPath);
    this.fileExistence.addPath(newPath);
    const operation = this.operationTracker.get(oldPath);
    if (operation) {
      this.operationTracker.delete(oldPath);
      this.operationTracker.set(newPath, operation);
    }
    if (this.firstRenames.has(oldPath)) {
      this.firstRenames.delete(oldPath);
      this.firstRenames.add(newPath);
    }
    this.releasePath(oldPath);
    this.reservePath(newPath);
  }
  // ==================== OPERATION TRACKING ====================
  /**
   * Track operation for rate limiting and conflict prevention
   */
  trackOperation(filePath, content) {
    const existing = this.operationTracker.get(filePath);
    if (existing) {
      existing.count++;
      existing.lastContent = content;
      existing.lastUpdate = Date.now();
    } else {
      this.operationTracker.set(filePath, {
        count: 1,
        lastContent: content,
        lastUpdate: Date.now()
      });
    }
  }
  /**
   * Get operation data for a file
   */
  getOperationData(filePath) {
    return this.operationTracker.get(filePath);
  }
  // ==================== ALIAS MANAGEMENT ====================
  /**
   * Set alias update timer
   */
  setAliasTimer(filePath, timer) {
    const existing = this.aliasTimers.get(filePath);
    if (existing) {
      clearTimeout(existing);
    }
    this.aliasTimers.set(filePath, timer);
  }
  /**
   * Clear alias timer
   */
  clearAliasTimer(filePath) {
    const timer = this.aliasTimers.get(filePath);
    if (timer) {
      clearTimeout(timer);
      this.aliasTimers.delete(filePath);
    }
  }
  /**
   * Mark alias operation as in progress
   */
  markAliasInProgress(filePath) {
    this.aliasInProgress.add(filePath);
  }
  /**
   * Mark alias operation as completed
   */
  markAliasCompleted(filePath) {
    this.aliasInProgress.delete(filePath);
    this.clearAliasTimer(filePath);
  }
  /**
   * Check if alias operation is in progress
   */
  isAliasInProgress(filePath) {
    return this.aliasInProgress.has(filePath);
  }
  /**
   * Clear all alias timers (used during plugin unload)
   */
  clearAllAliasTimers() {
    for (const timer of this.aliasTimers.values()) {
      clearTimeout(timer);
    }
    this.aliasTimers.clear();
    this.aliasInProgress.clear();
  }
  // ==================== FIRST RENAME TRACKING ====================
  /**
   * Check if this is the first rename for a file
   */
  isFirstRename(filePath) {
    return !this.firstRenames.has(filePath);
  }
  /**
   * Mark file as having been renamed
   */
  markFileRenamed(filePath) {
    this.firstRenames.add(filePath);
  }
  /**
   * Clear first rename tracking for a file
   */
  clearFirstRenameTracking(filePath) {
    this.firstRenames.delete(filePath);
  }
  // ==================== MAINTENANCE & CLEANUP ====================
  /**
   * Start automatic maintenance cycle (only if configured)
   * Note: Most cleanup is now done immediately after operations complete
   */
  startMaintenance() {
    if (this.maintenanceTimer) return;
    this.maintenanceTimer = setInterval(() => {
      if (!this.isDisposed) {
        this.performMaintenance();
      }
    }, this.config.maintenanceIntervalMs);
  }
  /**
   * Perform maintenance - clean up stale entries (legacy fallback only)
   * Most cleanup is now done immediately after operations complete
   */
  performMaintenance() {
    const now = Date.now();
    const cutoff = now - this.config.staleThresholdMs;
    for (const [path, data] of this.operationTracker.entries()) {
      if (data.lastUpdate < cutoff) {
        this.operationTracker.delete(path);
      }
    }
    const validPaths = /* @__PURE__ */ new Set();
    for (const path of this.tempPaths) {
      if (this.fileExistence.exists(path)) {
        validPaths.add(path);
      }
    }
    this.tempPaths = validPaths;
    for (const path of this.aliasInProgress) {
      if (!this.fileExistence.exists(path)) {
        this.aliasInProgress.delete(path);
        this.clearAliasTimer(path);
      }
    }
  }
  /**
   * Get cache statistics for monitoring
   */
  getStats() {
    return {
      contentCacheSize: this.contentCache.size(),
      tempPathsCount: this.tempPaths.size,
      operationsTracked: this.operationTracker.size,
      aliasTimersActive: this.aliasTimers.size,
      aliasInProgressCount: this.aliasInProgress.size
    };
  }
  /**
   * Force immediate cleanup
   */
  forceCleanup() {
    this.performMaintenance();
  }
  /**
   * Dispose of cache manager and clean up all resources
   */
  dispose() {
    this.isDisposed = true;
    if (this.maintenanceTimer) {
      clearInterval(this.maintenanceTimer);
      this.maintenanceTimer = null;
    }
    for (const timer of this.aliasTimers.values()) {
      clearTimeout(timer);
    }
    this.contentCache.clear();
    this.tempPaths.clear();
    this.fileExistence.clear();
    this.operationTracker.clear();
    this.aliasTimers.clear();
    this.aliasInProgress.clear();
    this.firstRenames.clear();
  }
};

// src/core/editor-lifecycle.ts
var import_obsidian21 = require("obsidian");
init_utils();
var EditorLifecycleManager = class {
  constructor(plugin) {
    // Track files currently open in editors (with last-seen timestamp)
    this.openEditorFiles = /* @__PURE__ */ new Map();
    // Interval-based checking system
    this.pendingChecks = /* @__PURE__ */ new Map();
    this.checkTimer = null;
    // Track active editors for tab close detection
    this.activeEditorFiles = /* @__PURE__ */ new Map();
    // Throttle timer system for checkInterval > 0
    this.throttleTimers = /* @__PURE__ */ new Map();
    // Track files in creation delay period with their timer references
    this.creationDelayTimers = /* @__PURE__ */ new Map();
    // Track view readiness check timers (for CREATE event)
    this.viewReadinessTimers = /* @__PURE__ */ new Map();
    // Track files that were just processed on tab close to prevent duplicate processing
    this.recentlyProcessedCloses = /* @__PURE__ */ new Set();
    // Track last focused file for rename-on-focus detection
    this.lastFocusedFile = null;
    this.plugin = plugin;
  }
  get app() {
    return this.plugin.app;
  }
  get settings() {
    return this.plugin.settings;
  }
  get isFullyLoaded() {
    return this.plugin.isFullyLoaded;
  }
  get renameEngine() {
    return this.plugin.renameEngine;
  }
  /**
   * Set creation delay timer for a file
   */
  setCreationDelayTimer(filePath, timer) {
    this.creationDelayTimers.set(filePath, timer);
    verboseLog(this.plugin, `Set creation delay timer for: ${filePath}`);
  }
  /**
   * Clear creation delay timer for a file
   */
  clearCreationDelayTimer(filePath) {
    const timer = this.creationDelayTimers.get(filePath);
    if (timer) {
      clearTimeout(timer);
      this.creationDelayTimers.delete(filePath);
      verboseLog(this.plugin, `Cleared creation delay timer for: ${filePath}`);
    }
  }
  /**
   * Check if a file is in creation delay period
   */
  isFileInCreationDelay(filePath) {
    return this.creationDelayTimers.has(filePath);
  }
  /**
   * Set view readiness timer for a file
   */
  setViewReadinessTimer(filePath, timer) {
    this.viewReadinessTimers.set(filePath, timer);
    verboseLog(this.plugin, `Set view readiness timer for: ${filePath}`);
  }
  /**
   * Clear view readiness timer for a file
   */
  clearViewReadinessTimer(filePath) {
    const timer = this.viewReadinessTimers.get(filePath);
    if (timer) {
      clearTimeout(timer);
      this.viewReadinessTimers.delete(filePath);
      verboseLog(this.plugin, `Cleared view readiness timer for: ${filePath}`);
    }
  }
  /**
   * Initialize the checking system based on settings
   */
  initializeCheckingSystem() {
    this.clearCheckingSystems();
    this.trackActiveEditors();
    if (this.settings.checkInterval === 0) {
      this.setupEventBasedChecking();
    } else {
      this.setupThrottleBasedChecking();
    }
  }
  /**
   * Setup event-based checking (immediate processing)
   */
  setupEventBasedChecking() {
    verboseLog(this.plugin, "Setting up event-based checking (immediate)");
  }
  /**
   * Setup throttle-based checking (process N ms after editor change)
   */
  setupThrottleBasedChecking() {
    verboseLog(this.plugin, `Setting up throttle-based checking (${this.settings.checkInterval}ms delay)`);
  }
  /**
   * Register workspace events to track open editors
   */
  trackActiveEditors() {
    this.plugin.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.updateActiveEditorTracking();
      })
    );
    this.plugin.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.updateActiveEditorTracking();
      })
    );
    this.updateActiveEditorTracking();
  }
  /**
   * Update tracking of active editors
   */
  async updateActiveEditorTracking() {
    var _a;
    const markdownViews = this.app.workspace.getLeavesOfType("markdown");
    const newActiveFiles = /* @__PURE__ */ new Map();
    const activeLeafIds = /* @__PURE__ */ new Set();
    for (const leaf of markdownViews) {
      const view = leaf.view;
      if (view && view.file && view.editor) {
        try {
          const leafId = leaf.id;
          activeLeafIds.add(leafId);
          newActiveFiles.set(view.file.path, {
            file: view.file,
            editor: view.editor,
            leafId
          });
        } catch (error) {
          console.error(`Error tracking editor for ${view.file.path}:`, error);
        }
      }
    }
    if (this.isFullyLoaded && this.settings.renameNotes === "automatically") {
      for (const [filePath, oldData] of this.activeEditorFiles) {
        if (!newActiveFiles.has(filePath)) {
          let stillOpen = false;
          for (const newData of newActiveFiles.values()) {
            if (newData.file === oldData.file) {
              stillOpen = true;
              verboseLog(this.plugin, `File ${filePath} was renamed, not closed - skipping tab close processing`);
              break;
            }
          }
          if (stillOpen) {
            continue;
          }
          if (activeLeafIds.has(oldData.leafId)) {
            verboseLog(this.plugin, `File ${filePath} switched in same tab (leaf ${oldData.leafId} still active) - skipping tab close processing`);
            continue;
          }
          if (this.recentlyProcessedCloses.has(filePath)) {
            verboseLog(this.plugin, `File ${filePath} already processed on tab close - skipping duplicate`);
            continue;
          }
          verboseLog(this.plugin, `Tab closed for: ${filePath}`);
          (_a = this.plugin.cacheManager) == null ? void 0 : _a.clearFirstRenameTracking(filePath);
          this.recentlyProcessedCloses.add(filePath);
          setTimeout(() => {
            this.recentlyProcessedCloses.delete(filePath);
          }, 100);
          const hasThrottleTimer = this.throttleTimers.has(filePath);
          if (hasThrottleTimer) {
            verboseLog(this.plugin, `Tab close overriding throttle timer for: ${filePath}`);
            this.clearThrottleTimer(filePath);
            verboseLog(this.plugin, `Processing immediately due to pending throttle: ${filePath}`);
            try {
              await this.renameEngine.processFile(oldData.file, true);
            } catch (error) {
              console.error(`Error processing closed file ${filePath}:`, error);
            }
          } else {
            verboseLog(this.plugin, `Tab closed with no pending throttle: ${filePath} - no action needed`);
          }
        }
      }
    }
    this.activeEditorFiles = newActiveFiles;
    verboseLog(this.plugin, `Tracking ${this.activeEditorFiles.size} active editor files for tab close detection`);
    if (this.settings.renameOnFocus && this.isFullyLoaded) {
      const currentActiveFile = this.app.workspace.getActiveFile();
      if (currentActiveFile && currentActiveFile.extension === "md") {
        const currentPath = currentActiveFile.path;
        if (currentPath !== this.lastFocusedFile) {
          this.lastFocusedFile = currentPath;
          verboseLog(this.plugin, `File focused: ${currentPath}`);
          this.renameEngine.processFile(currentActiveFile, true).catch((error) => {
            console.error(`Error processing rename-on-focus for ${currentPath}:`, error);
          });
        }
      }
    }
  }
  /**
   * Handle editor change with throttle for checkInterval > 0
   * Policy: Process on ANY content change, not just first line changes
   */
  handleEditorChangeWithThrottle(editor, file) {
    const filePath = file.path;
    if (this.isFileInCreationDelay(filePath)) {
      verboseLog(this.plugin, `File in creation delay, skipping throttle: ${filePath}`);
      return;
    }
    if (this.throttleTimers.has(filePath)) {
      verboseLog(this.plugin, `Throttle timer already running for: ${filePath}, not starting new one`);
      return;
    }
    verboseLog(this.plugin, `Starting throttle timer (${this.settings.checkInterval}ms) for: ${filePath}`);
    const timer = setTimeout(async () => {
      verboseLog(this.plugin, `Throttle timer expired, processing: ${filePath}`);
      this.throttleTimers.delete(filePath);
      try {
        await this.renameEngine.processEditorChangeOptimal(editor, file);
      } catch (error) {
        console.error(`Error processing throttled change for ${filePath}:`, error);
      }
    }, this.settings.checkInterval);
    this.throttleTimers.set(filePath, timer);
  }
  /**
   * Clear throttle timer for a specific file
   */
  clearThrottleTimer(filePath) {
    const timer = this.throttleTimers.get(filePath);
    if (timer) {
      clearTimeout(timer);
      this.throttleTimers.delete(filePath);
      verboseLog(this.plugin, `Cleared throttle timer for: ${filePath}`);
    }
  }
  /**
   * Clear all checking systems and state
   * Note: Does NOT clear creation delay timers or view readiness timers
   * as those need to persist across initialization
   */
  clearCheckingSystems() {
    if (this.checkTimer) {
      clearTimeout(this.checkTimer);
      this.checkTimer = null;
    }
    for (const timer of this.throttleTimers.values()) {
      clearTimeout(timer);
    }
    this.throttleTimers.clear();
    this.activeEditorFiles.clear();
    this.pendingChecks.clear();
  }
  /**
   * Extract first line from editor content
   */
  extractFirstLineFromEditor(editor, file) {
    try {
      const content = editor.getValue();
      const lines = content.split("\n");
      const metadata = this.app.metadataCache.getFileCache(file);
      let firstLineIndex = 0;
      if (metadata == null ? void 0 : metadata.frontmatterPosition) {
        firstLineIndex = metadata.frontmatterPosition.end.line + 1;
      }
      for (let i = firstLineIndex; i < lines.length; i++) {
        const line = lines[i];
        if (line.trim() !== "") {
          return line;
        }
      }
      return "";
    } catch (error) {
      console.error(`Error extracting first line from ${file.path}:`, error);
      return "";
    }
  }
  /**
   * Extract first line from file content string
   */
  extractFirstLineFromContent(content, file) {
    try {
      const lines = content.split("\n");
      const metadata = this.app.metadataCache.getFileCache(file);
      let firstLineIndex = 0;
      if (metadata == null ? void 0 : metadata.frontmatterPosition) {
        firstLineIndex = metadata.frontmatterPosition.end.line + 1;
      }
      for (let i = firstLineIndex; i < lines.length; i++) {
        const line = lines[i];
        if (line.trim() !== "") {
          return line;
        }
      }
      return "";
    } catch (error) {
      console.error(`Error extracting first line from content for ${file.path}:`, error);
      return "";
    }
  }
  /**
   * Check if a file is currently open in an editor
   */
  isFileOpenInEditor(file) {
    let isOpen = false;
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a;
      if (leaf.view instanceof import_obsidian21.MarkdownView && ((_a = leaf.view.file) == null ? void 0 : _a.path) === file.path) {
        isOpen = true;
        return false;
      }
    });
    return isOpen;
  }
  /**
   * Process pending editor changes (kept for backward compatibility)
   */
  processPendingEditorChanges() {
    verboseLog(this.plugin, `processPendingEditorChanges called - no action needed with immediate processing`);
  }
  /**
   * Get open editor files map (for external access)
   */
  getOpenEditorFiles() {
    return this.openEditorFiles;
  }
  /**
   * Get active editor files map (for external access)
   */
  getActiveEditorFiles() {
    return this.activeEditorFiles;
  }
};

// src/core/workspace-integration.ts
var import_obsidian22 = require("obsidian");
init_utils();
init_i18n();
var WorkspaceIntegration = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  get app() {
    return this.plugin.app;
  }
  get settings() {
    return this.plugin.settings;
  }
  get isFullyLoaded() {
    return this.plugin.isFullyLoaded;
  }
  get renameEngine() {
    return this.plugin.renameEngine;
  }
  /**
   * Setup custom icons in command palette
   */
  setupCommandPaletteIcons() {
    const commandIcons = /* @__PURE__ */ new Map([
      ["Put first line in title", "file-pen"],
      ["Put first line in title (unless excluded)", "file-pen"],
      ["Put first line in title in all notes", "file-stack"],
      ["Disable renaming for note", "square-x"],
      ["Enable renaming for note", "square-check"]
    ]);
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node instanceof HTMLElement) {
            const suggestionItems = node.querySelectorAll('.suggestion-item, [class*="suggestion"]');
            suggestionItems.forEach((item) => {
              var _a;
              if (item instanceof HTMLElement) {
                const titleElement = item.querySelector('.suggestion-title, [class*="title"]');
                if (titleElement) {
                  const commandName = (_a = titleElement.textContent) == null ? void 0 : _a.trim();
                  if (commandName && commandIcons.has(commandName)) {
                    if (!item.querySelector(".flit-command-icon")) {
                      const iconName = commandIcons.get(commandName);
                      const iconElement = document.createElement("div");
                      iconElement.classList.add("flit-command-icon");
                      (0, import_obsidian22.setIcon)(iconElement, iconName);
                      item.insertBefore(iconElement, item.firstChild);
                    }
                  }
                }
              }
            });
          }
        });
      });
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    this.commandPaletteObserver = observer;
  }
  /**
   * Register ribbon icons according to settings
   */
  registerRibbonIcons() {
    const ribbonActions = [
      {
        condition: this.settings.ribbonVisibility.renameCurrentFile,
        icon: "file-pen",
        title: t("commands.putFirstLineInTitle"),
        callback: () => this.plugin.commandRegistrar.executeRenameCurrentFile()
      },
      {
        condition: this.settings.ribbonVisibility.renameAllNotes,
        icon: "file-stack",
        title: t("commands.putFirstLineInTitleAllNotes"),
        callback: () => {
          const { RenameAllFilesModal: RenameAllFilesModal3 } = (init_modals(), __toCommonJS(modals_exports));
          new RenameAllFilesModal3(this.app, this.plugin).open();
        }
      },
      {
        condition: this.settings.ribbonVisibility.toggleAutomaticRenaming,
        icon: "file-cog",
        title: t("commands.toggleAutomaticRenaming"),
        callback: () => this.plugin.commandRegistrar.executeToggleAutomaticRenaming()
      }
    ];
    ribbonActions.forEach((action) => {
      if (action.condition) {
        this.plugin.addRibbonIcon(action.icon, action.title, action.callback);
      }
    });
  }
  /**
   * Setup save event hook for rename on save
   */
  setupSaveEventHook() {
    var _a, _b;
    const saveCommand = (_b = (_a = this.app.commands) == null ? void 0 : _a.commands) == null ? void 0 : _b["editor:save-file"];
    if (saveCommand) {
      this.originalSaveCallback = saveCommand.checkCallback;
      saveCommand.checkCallback = (checking) => {
        const result = this.originalSaveCallback ? this.originalSaveCallback(checking) : true;
        if (!checking && this.settings.renameOnSave) {
          const activeFile = this.app.workspace.getActiveFile();
          if (activeFile && activeFile.extension === "md") {
            setTimeout(() => {
              this.plugin.commandRegistrar.executeRenameUnlessExcluded();
            }, 100);
          }
        }
        return result;
      };
      verboseLog(this.plugin, "Save event hook installed for rename on save");
    }
  }
  /**
   * Setup processing for new files - sequential execution after single delay
   */
  setupCursorPositioning() {
    this.plugin.registerEvent(
      this.app.vault.on("create", async (file) => {
        if (!(file instanceof import_obsidian22.TFile) || file.extension !== "md") return;
        if (file.stat.ctime < this.plugin.pluginLoadTime - 1e3) {
          return;
        }
        const plugin = this.plugin;
        const app = this.app;
        const settings = this.settings;
        if (!(plugin == null ? void 0 : plugin.fileOperations)) {
          verboseLog(plugin, `CREATE: Plugin not fully initialized, skipping ${file.name}`);
          return;
        }
        const processFileCreation = async () => {
          var _a, _b;
          let initialContent = "";
          try {
            const leaves = app.workspace.getLeavesOfType("markdown");
            for (const leaf of leaves) {
              const view = leaf.view;
              if (view && ((_a = view.file) == null ? void 0 : _a.path) === file.path && view.editor) {
                initialContent = view.editor.getValue();
                verboseLog(plugin, `CREATE: Captured initial editor content for ${file.path}: ${initialContent.length} chars`);
                break;
              }
            }
          } catch (error) {
            verboseLog(plugin, `CREATE: Could not read initial editor content`);
          }
          verboseLog(plugin, `CREATE: New file created, processing in ${settings.newNoteDelay}ms: ${file.name}`);
          const untitledWord = t("untitled").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          const untitledPattern = new RegExp(`^${untitledWord}(\\s[1-9]\\d*)?$`);
          const isUntitled = untitledPattern.test(file.basename);
          if (settings.moveCursorToFirstLine) {
            if (!settings.waitForCursorTemplate) {
              const isExcluded = await plugin.fileOperations.isFileExcludedForCursorPositioning(file, initialContent, !settings.disableCursorInExcludedFolders);
              if (!isExcluded) {
                const activeView = app.workspace.getActiveViewOfType(import_obsidian22.MarkdownView);
                const inCanvas = !activeView;
                if (!inCanvas) {
                  requestAnimationFrame(() => {
                    setTimeout(() => {
                      const hasContent = initialContent.trim() !== "";
                      const willSkipTitleInsertion = !settings.insertTitleOnCreation || isUntitled || hasContent;
                      plugin.fileOperations.handleCursorPositioning(file, willSkipTitleInsertion);
                    }, 200);
                  });
                }
              } else {
                verboseLog(plugin, `Skipping cursor positioning - file is excluded: ${file.path}`);
              }
            } else {
              verboseLog(plugin, `Waiting for template before cursor positioning: ${file.path}`);
              const templateWaitTime = 600;
              await plugin.fileOperations.waitForYamlOrTimeout(file, templateWaitTime);
              const leaves = app.workspace.getLeavesOfType("markdown");
              let currentContent;
              for (const leaf of leaves) {
                const view = leaf.view;
                if (view && ((_b = view.file) == null ? void 0 : _b.path) === file.path && view.editor) {
                  currentContent = view.editor.getValue();
                  break;
                }
              }
              file._flitTemplateContent = currentContent;
              const isExcluded = await plugin.fileOperations.isFileExcludedForCursorPositioning(file, currentContent, !settings.disableCursorInExcludedFolders);
              if (!isExcluded) {
                const activeView = app.workspace.getActiveViewOfType(import_obsidian22.MarkdownView);
                const inCanvas = !activeView;
                if (!inCanvas) {
                  requestAnimationFrame(() => {
                    setTimeout(() => {
                      const hasContent = currentContent && currentContent.trim() !== "";
                      const willSkipTitleInsertion = !settings.insertTitleOnCreation || isUntitled || hasContent;
                      plugin.fileOperations.handleCursorPositioning(file, willSkipTitleInsertion);
                    }, 200);
                  });
                }
              } else {
                verboseLog(plugin, `Skipping cursor positioning after template - file is excluded: ${file.path}`);
              }
            }
          }
          const timer = setTimeout(async () => {
            var _a2;
            verboseLog(plugin, `CREATE: Processing new file after delay: ${file.name}`);
            let titleWasInserted = false;
            try {
              if (settings.insertTitleOnCreation) {
                const templateContent = file._flitTemplateContent;
                let skipTitleDueToExclusion = false;
                if (settings.waitForTemplate && templateContent) {
                  const isExcluded = await plugin.fileOperations.isFileExcludedForCursorPositioning(file, templateContent, !settings.disableCursorInExcludedFolders);
                  if (isExcluded) {
                    verboseLog(plugin, `Skipping title insertion - file is excluded: ${file.path}`);
                    skipTitleDueToExclusion = true;
                  }
                }
                if (!skipTitleDueToExclusion) {
                  titleWasInserted = await plugin.fileOperations.insertTitleOnCreation(file, initialContent, templateContent);
                  verboseLog(plugin, `CREATE: insertTitleOnCreation returned ${titleWasInserted}`);
                }
              }
              if (settings.moveCursorToFirstLine) {
                if (titleWasInserted && settings.placeCursorAtLineEnd) {
                  const leaves = app.workspace.getLeavesOfType("markdown");
                  let currentContent;
                  for (const leaf of leaves) {
                    const view = leaf.view;
                    if (view && ((_a2 = view.file) == null ? void 0 : _a2.path) === file.path && view.editor) {
                      currentContent = view.editor.getValue();
                      break;
                    }
                  }
                  const isExcluded = await plugin.fileOperations.isFileExcludedForCursorPositioning(file, currentContent, !settings.disableCursorInExcludedFolders);
                  if (!isExcluded) {
                    const activeView = app.workspace.getActiveViewOfType(import_obsidian22.MarkdownView);
                    const inCanvas = !activeView;
                    if (!inCanvas) {
                      requestAnimationFrame(() => {
                        setTimeout(() => {
                          plugin.fileOperations.handleCursorPositioning(file);
                        }, 200);
                      });
                    }
                  } else {
                    verboseLog(plugin, `Skipping post-title cursor repositioning - file is excluded: ${file.path}`);
                  }
                }
              }
              if (settings.renameNotes === "automatically" && plugin.isFullyLoaded) {
                let editorContent;
                const leaves = app.workspace.getLeavesOfType("markdown");
                for (const leaf of leaves) {
                  const view = leaf.view;
                  if (view && view.file && view.file.path === file.path && view.editor) {
                    const value = view.editor.getValue();
                    if (typeof value === "string") {
                      editorContent = value;
                    }
                    break;
                  }
                }
                await plugin.renameEngine.processFile(file, true, false, editorContent);
              }
              verboseLog(plugin, `CREATE: Completed processing new file: ${file.name}`);
            } catch (error) {
              console.error(`CREATE: Failed to process new file ${file.path}:`, error);
            } finally {
              delete file._flitTemplateContent;
              plugin.editorLifecycle.clearCreationDelayTimer(file.path);
            }
          }, settings.newNoteDelay);
          plugin.editorLifecycle.setCreationDelayTimer(file.path, timer);
        };
        const checkViewReady = async () => {
          var _a;
          const leaves = app.workspace.getLeavesOfType("markdown");
          for (const leaf of leaves) {
            const view = leaf.view;
            if (view && ((_a = view.file) == null ? void 0 : _a.path) === file.path) {
              verboseLog(plugin, `CREATE: Markdown view ready for ${file.name}`);
              return true;
            }
          }
          return false;
        };
        const immediateCheck = await checkViewReady();
        if (immediateCheck) {
          verboseLog(plugin, `CREATE: File created ${file.name}, markdown view ready`);
          await processFileCreation();
        } else {
          const timer = setTimeout(async () => {
            const delayedCheck = await checkViewReady();
            if (delayedCheck) {
              await processFileCreation();
            } else {
              verboseLog(plugin, `CREATE: No markdown view found for ${file.name} after delay, skipping`);
            }
            plugin.editorLifecycle.clearViewReadinessTimer(file.path);
          }, 100);
          plugin.editorLifecycle.setViewReadinessTimer(file.path, timer);
        }
      })
    );
  }
  /**
   * Cleanup all workspace integrations
   */
  cleanup() {
    var _a, _b;
    if (this.originalSaveCallback) {
      const saveCommand = (_b = (_a = this.app.commands) == null ? void 0 : _a.commands) == null ? void 0 : _b["editor:save-file"];
      if (saveCommand) {
        saveCommand.checkCallback = this.originalSaveCallback;
      }
    }
    if (this.commandPaletteObserver) {
      this.commandPaletteObserver.disconnect();
      this.commandPaletteObserver = void 0;
    }
  }
  /**
   * Get command palette observer (for external access)
   */
  getCommandPaletteObserver() {
    return this.commandPaletteObserver;
  }
};

// src/core/property-manager.ts
var import_obsidian23 = require("obsidian");
init_utils();
var PropertyManager = class {
  constructor(plugin) {
    this.propertyTypeCache = /* @__PURE__ */ new Map();
    this.plugin = plugin;
  }
  get app() {
    return this.plugin.app;
  }
  get settings() {
    return this.plugin.settings;
  }
  /**
   * Setup notification suppression for external modification notices
   */
  setupNotificationSuppression() {
    this.notificationObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node instanceof HTMLElement) {
            const notices = node.classList.contains("notice") ? [node] : node.querySelectorAll(".notice");
            notices.forEach((notice) => {
              if (notice instanceof HTMLElement) {
                const noticeText = notice.textContent || "";
                const conditions = {
                  hasExternal: noticeText.includes("has been modified externally, merging changes automatically"),
                  hasMd: noticeText.includes(".md"),
                  noUpdated: !noticeText.includes("Updated"),
                  startsQuote: noticeText.trim().charCodeAt(0) === 8220,
                  // Left double quotation mark
                  shortEnough: noticeText.length < 200
                };
                if (this.settings.suppressMergeNotifications && conditions.hasExternal && conditions.hasMd && conditions.noUpdated && conditions.startsQuote && conditions.shortEnough) {
                  notice.style.display = "none";
                  verboseLog(this.plugin, `Suppressed external modification notice: ${noticeText.substring(0, 50)}...`);
                }
              }
            });
          }
        });
      });
    });
    this.notificationObserver.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  /**
   * Cleanup notification suppression observer
   */
  cleanupNotificationSuppression() {
    if (this.notificationObserver) {
      this.notificationObserver.disconnect();
      this.notificationObserver = void 0;
    }
  }
  /**
   * Get notification observer (for external access if needed)
   */
  getNotificationObserver() {
    return this.notificationObserver;
  }
  /**
   * Get path to types.json in vault's .obsidian folder
   */
  getTypesJsonPath() {
    return (0, import_obsidian23.normalizePath)(`${this.app.vault.configDir}/types.json`);
  }
  /**
   * Read types.json file
   */
  async readTypesJson() {
    const path = this.getTypesJsonPath();
    try {
      const content = await this.app.vault.adapter.read(path);
      return JSON.parse(content);
    } catch (error) {
      verboseLog(this.plugin, `types.json not found or invalid, creating new structure`);
      return { types: {} };
    }
  }
  /**
   * Write types.json file
   */
  async writeTypesJson(data) {
    const path = this.getTypesJsonPath();
    try {
      const content = JSON.stringify(data, null, 2);
      await this.app.vault.adapter.write(path, content);
      verboseLog(this.plugin, `Updated types.json`);
    } catch (error) {
      console.error("Failed to write types.json:", error);
    }
  }
  /**
   * Check if value is boolean (true or false)
   */
  isBooleanValue(value) {
    return value === true || value === false || value === "true" || value === "false";
  }
  /**
   * Normalize boolean values to actual boolean type
   */
  normalizeBooleanValue(value) {
    if (value === "true") return true;
    if (value === "false") return false;
    return value;
  }
  /**
   * Ensure property type is set to checkbox in types.json
   * Call this when "Disable renaming" commands are executed
   *
   * This ensures the property type is always checkbox when the property value is boolean,
   * regardless of what type it was before or if it existed at all.
   */
  async ensurePropertyTypeIsCheckbox() {
    const propertyKey = this.settings.disableRenamingKey;
    const propertyValue = this.settings.disableRenamingValue;
    if (!propertyKey) return;
    const normalizedValue = this.normalizeBooleanValue(propertyValue);
    const isBoolean = this.isBooleanValue(normalizedValue);
    if (!isBoolean) {
      verboseLog(this.plugin, `Property "${propertyKey}" value is not boolean (${propertyValue}), skipping type update`);
      return;
    }
    const typesData = await this.readTypesJson();
    const currentType = typesData.types[propertyKey];
    if (currentType !== "checkbox") {
      typesData.types[propertyKey] = "checkbox";
      await this.writeTypesJson(typesData);
      verboseLog(this.plugin, `Property "${propertyKey}" set to checkbox for disable renaming command`);
    }
    this.propertyTypeCache.set(propertyKey, "checkbox");
  }
};

// src/core/plugin-initializer.ts
init_utils();
var PluginInitializer = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  get settings() {
    return this.plugin.settings;
  }
  /**
   * Initialize first-enable logic for sections
   * Ensures that when features are enabled for the first time, their items are enabled
   */
  async initializeFirstEnableLogic() {
    let settingsChanged = false;
    if (this.settings.enableCustomReplacements && !this.settings.hasEnabledCustomReplacements) {
      this.settings.customReplacements.forEach((replacement) => {
        replacement.enabled = true;
      });
      this.settings.hasEnabledCustomReplacements = true;
      settingsChanged = true;
      verboseLog(this.plugin, "Initialized custom replacements on first enable");
    }
    if (this.settings.enableSafewords && !this.settings.hasEnabledSafewords) {
      this.settings.safewords.forEach((safeword) => {
        safeword.enabled = true;
      });
      this.settings.hasEnabledSafewords = true;
      settingsChanged = true;
      verboseLog(this.plugin, "Initialized safewords on first enable");
    }
    if (this.settings.enableForbiddenCharReplacements && !this.settings.hasEnabledForbiddenChars) {
      const allOSesKeys = ["leftBracket", "rightBracket", "hash", "caret", "pipe", "backslash", "slash", "colon", "dot"];
      allOSesKeys.forEach((key) => {
        this.settings.charReplacementEnabled[key] = true;
      });
      this.settings.hasEnabledForbiddenChars = true;
      settingsChanged = true;
      verboseLog(this.plugin, "Initialized forbidden char replacements on first enable");
    }
    if (settingsChanged) {
      await this.plugin.saveSettings();
    }
  }
  /**
   * Load external CSS styles
   */
  async loadStyles() {
    try {
      const css = await this.plugin.app.vault.adapter.read(`${this.plugin.manifest.dir}/styles.css`);
      const styleEl = document.createElement("style");
      styleEl.textContent = css;
      document.head.appendChild(styleEl);
    } catch (error) {
    }
  }
};

// src/core/command-registrar.ts
var import_obsidian24 = require("obsidian");
init_utils();
init_modals();
init_i18n();
var CommandRegistrar = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  get app() {
    return this.plugin.app;
  }
  get settings() {
    return this.plugin.settings;
  }
  /**
   * Register all command palette commands based on settings
   */
  registerCommands() {
    if (!this.settings.enableCommandPalette) {
      return;
    }
    this.registerRenameCurrentFileCommand();
    this.registerRenameCurrentFileUnlessExcludedCommand();
    this.registerRenameAllFilesCommand();
    this.registerSafeInternalLinkCommand();
    this.registerSafeInternalLinkWithCaptionCommand();
    this.registerToggleAutomaticRenamingCommand();
    this.plugin.registerDynamicCommands();
  }
  /**
   * Register command: Put first line in title
   * Note: This command ignores folder/tag/property exclusions but ALWAYS respects disable property
   */
  registerRenameCurrentFileCommand() {
    if (!this.settings.commandPaletteVisibility.renameCurrentFile) {
      return;
    }
    this.plugin.addCommand({
      id: "rename-current-file",
      name: t("commands.putFirstLineInTitle"),
      icon: "file-pen",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile || activeFile.extension !== "md") {
          verboseLog(this.plugin, `Showing notice: Error: no active note.`);
          new import_obsidian24.Notice(t("notifications.errorNoActiveNote"));
          return;
        }
        verboseLog(this.plugin, `Manual rename command triggered for ${activeFile.path} (ignoring folder/tag/property exclusions, respecting disable property)`);
        const exclusionOverrides = { ignoreFolder: true, ignoreTag: true, ignoreProperty: true };
        await this.plugin.renameEngine.processFile(activeFile, true, true, void 0, false, exclusionOverrides);
      }
    });
  }
  /**
   * Register command: Put first line in title (unless excluded)
   */
  registerRenameCurrentFileUnlessExcludedCommand() {
    if (!this.settings.commandPaletteVisibility.renameCurrentFileUnlessExcluded) {
      return;
    }
    this.plugin.addCommand({
      id: "rename-current-file-unless-excluded",
      name: t("commands.putFirstLineInTitleUnlessExcluded"),
      icon: "file-pen",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile || activeFile.extension !== "md") {
          verboseLog(this.plugin, `Showing notice: Error: no active note.`);
          new import_obsidian24.Notice(t("notifications.errorNoActiveNote"));
          return;
        }
        verboseLog(this.plugin, `Manual rename command triggered for ${activeFile.path} (unless excluded)`);
        await this.plugin.renameEngine.processFile(activeFile, true, true);
      }
    });
  }
  /**
   * Register command: Put first line in title in all notes
   */
  registerRenameAllFilesCommand() {
    if (!this.settings.commandPaletteVisibility.renameAllFiles) {
      return;
    }
    this.plugin.addCommand({
      id: "rename-all-files",
      name: t("commands.putFirstLineInTitleAllNotes"),
      icon: "file-stack",
      callback: () => {
        verboseLog(this.plugin, "Bulk rename command triggered");
        new RenameAllFilesModal(this.app, this.plugin).open();
      }
    });
  }
  /**
   * Register command: Add safe internal link
   */
  registerSafeInternalLinkCommand() {
    if (!this.settings.commandVisibility.addSafeInternalLink) {
      return;
    }
    this.plugin.addCommand({
      id: "add-safe-internal-link",
      name: t("commands.addSafeInternalLink"),
      icon: "link",
      callback: async () => {
        await this.plugin.addSafeInternalLink();
      }
    });
  }
  /**
   * Register command: Add safe internal link with selection as caption
   */
  registerSafeInternalLinkWithCaptionCommand() {
    if (!this.settings.commandVisibility.addSafeInternalLinkWithCaption) {
      return;
    }
    this.plugin.addCommand({
      id: "add-safe-internal-link-with-caption",
      name: t("commands.addSafeInternalLinkWithCaption"),
      icon: "link",
      callback: async () => {
        await this.plugin.addSafeInternalLinkWithCaption();
      }
    });
  }
  /**
   * Register command: Toggle automatic renaming
   */
  registerToggleAutomaticRenamingCommand() {
    if (!this.settings.commandPaletteVisibility.toggleAutomaticRenaming) {
      return;
    }
    this.plugin.addCommand({
      id: "toggle-automatic-renaming",
      name: t("commands.toggleAutomaticRenaming"),
      icon: "file-cog",
      callback: async () => {
        const newValue = this.settings.renameNotes === "automatically" ? "manually" : "automatically";
        this.settings.renameNotes = newValue;
        await this.plugin.saveSettings();
        const notificationKey = newValue === "automatically" ? "notifications.automaticRenamingEnabled" : "notifications.automaticRenamingDisabled";
        new import_obsidian24.Notice(t(notificationKey));
      }
    });
  }
  /**
   * Execute rename current file command (public method for ribbon/external use)
   */
  async executeRenameCurrentFile() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "md") {
      verboseLog(this.plugin, `Showing notice: ${t("notifications.errorNoActiveNote")}`);
      new import_obsidian24.Notice(t("notifications.errorNoActiveNote"));
      return;
    }
    verboseLog(this.plugin, `Manual rename command triggered for ${activeFile.path} (ignoring folder/tag/property exclusions, respecting disable property)`);
    const exclusionOverrides = { ignoreFolder: true, ignoreTag: true, ignoreProperty: true };
    await this.plugin.renameEngine.processFile(activeFile, true, true, void 0, false, exclusionOverrides);
  }
  /**
   * Execute rename unless excluded command (public method for ribbon/external use)
   */
  async executeRenameUnlessExcluded() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "md") {
      verboseLog(this.plugin, `Showing notice: ${t("notifications.errorNoActiveNote")}`);
      new import_obsidian24.Notice(t("notifications.errorNoActiveNote"));
      return;
    }
    verboseLog(this.plugin, `Manual rename command triggered for ${activeFile.path} (unless excluded)`);
    await this.plugin.renameEngine.processFile(activeFile, true, true);
  }
  /**
   * Execute toggle automatic renaming command (public method for ribbon/external use)
   */
  async executeToggleAutomaticRenaming() {
    const newValue = this.settings.renameNotes === "automatically" ? "manually" : "automatically";
    this.settings.renameNotes = newValue;
    await this.plugin.saveSettings();
    const notificationKey = newValue === "automatically" ? "notifications.automaticRenamingEnabled" : "notifications.automaticRenamingDisabled";
    new import_obsidian24.Notice(t(notificationKey));
  }
};

// src/core/title-insertion.ts
var import_obsidian25 = require("obsidian");
init_utils();
init_i18n();
init_constants();
var TitleInsertion = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async insertTitleOnCreation(file) {
    try {
      const untitledWord = t("untitled").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      const untitledPattern = new RegExp(`^${untitledWord}(\\s\\d+)?$`);
      if (untitledPattern.test(file.basename)) {
        verboseLog(this.plugin, `Skipping title insertion for untitled file: ${file.path}`);
        return;
      }
      let content;
      try {
        content = await this.plugin.app.vault.read(file);
      } catch (error) {
        console.error(`Failed to read file ${file.path} for title insertion:`, error);
        return;
      }
      verboseLog(this.plugin, `Title insertion delay complete. File content length: ${content.length} chars, trimmed: "${content.trim()}"`);
      if (content.trim() !== "") {
        verboseLog(this.plugin, `Skipping title insertion - file already has content: ${file.path}`);
        return;
      }
      let cleanTitle = file.basename;
      for (const [forbiddenChar, normalChar] of Object.entries(TITLE_CHAR_REVERSAL_MAP)) {
        cleanTitle = cleanTitle.replaceAll(forbiddenChar, normalChar);
      }
      verboseLog(this.plugin, `Inserting title "${cleanTitle}" in new file: ${file.path}`);
      const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian25.MarkdownView);
      const inCanvas = !activeView;
      let newContent = cleanTitle;
      if (!inCanvas && this.plugin.settings.moveCursorToFirstLine) {
        if (this.plugin.settings.placeCursorAtLineEnd) {
          newContent += "\n";
        } else {
          newContent += "\n";
        }
      } else {
        newContent += "\n";
      }
      let currentContent;
      let retryCount = 0;
      const maxRetries = 3;
      const retryDelay = 500;
      do {
        try {
          currentContent = await this.plugin.app.vault.read(file);
          verboseLog(this.plugin, `Re-read file content (attempt ${retryCount + 1}). Length: ${currentContent.length} chars`);
          if (currentContent.trim() !== "") {
            verboseLog(this.plugin, `Template content found after ${retryCount + 1} attempts`);
            break;
          }
          if (retryCount < maxRetries - 1) {
            verboseLog(this.plugin, `File still empty, retrying in ${retryDelay}ms...`);
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
          }
        } catch (error) {
          console.error(`Failed to re-read file ${file.path} for title insertion:`, error);
          return;
        }
        retryCount++;
      } while (retryCount < maxRetries && currentContent.trim() === "");
      if (currentContent.trim() !== "") {
        verboseLog(this.plugin, `File now has template content, inserting title into existing content`);
        const metadata = this.plugin.app.metadataCache.getFileCache(file);
        const lines = currentContent.split("\n");
        if (metadata == null ? void 0 : metadata.frontmatterPosition) {
          const insertLine = metadata.frontmatterPosition.end.line + 1;
          lines.splice(insertLine, 0, cleanTitle);
          verboseLog(this.plugin, `Inserted title after frontmatter at line ${insertLine}`);
        } else {
          lines.unshift(cleanTitle);
          verboseLog(this.plugin, `Inserted title at beginning of file`);
        }
        const finalContent = lines.join("\n");
        await this.plugin.app.vault.modify(file, finalContent);
      } else {
        verboseLog(this.plugin, `File still empty, inserting title as new content`);
        await this.plugin.app.vault.modify(file, newContent);
      }
      if (!inCanvas && this.plugin.settings.moveCursorToFirstLine) {
        setTimeout(() => {
          this.handleCursorPositioning(file);
        }, 50);
      }
      verboseLog(this.plugin, `Successfully inserted title in ${file.path}`);
    } catch (error) {
      console.error(`Error inserting title on creation for ${file.path}:`, error);
    }
  }
  async handleCursorPositioning(file) {
    var _a, _b, _c, _d, _e, _f, _g;
    try {
      verboseLog(this.plugin, `handleCursorPositioning called for ${file.path}`);
      const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian25.MarkdownView);
      verboseLog(this.plugin, `Active view found: ${!!activeView}, file matches: ${((_a = activeView == null ? void 0 : activeView.file) == null ? void 0 : _a.path) === file.path}`);
      if (activeView && ((_b = activeView.file) == null ? void 0 : _b.path) === file.path) {
        await activeView.leaf.setViewState({
          type: "markdown",
          state: {
            mode: "source",
            source: false
          }
        });
        await ((_c = activeView.editor) == null ? void 0 : _c.focus());
        let titleLineNumber = 0;
        let titleLineLength = 0;
        const metadata = this.plugin.app.metadataCache.getFileCache(file);
        if (metadata == null ? void 0 : metadata.frontmatterPosition) {
          titleLineNumber = metadata.frontmatterPosition.end.line + 1;
          verboseLog(this.plugin, `Found frontmatter ending at line ${metadata.frontmatterPosition.end.line}, title on line ${titleLineNumber}`);
        } else {
          titleLineNumber = 0;
          verboseLog(this.plugin, `No frontmatter found, title on line ${titleLineNumber}`);
        }
        titleLineLength = ((_e = (_d = activeView.editor) == null ? void 0 : _d.getLine(titleLineNumber)) == null ? void 0 : _e.length) || 0;
        if (this.plugin.settings.placeCursorAtLineEnd) {
          (_f = activeView.editor) == null ? void 0 : _f.setCursor({ line: titleLineNumber, ch: titleLineLength });
          verboseLog(this.plugin, `Moved cursor to end of title line ${titleLineNumber} (${titleLineLength} chars) via handleCursorPositioning for ${file.path}`);
        } else {
          (_g = activeView.editor) == null ? void 0 : _g.setCursor({ line: titleLineNumber + 1, ch: 0 });
          verboseLog(this.plugin, `Moved cursor to line after title (line ${titleLineNumber + 1}) via handleCursorPositioning for ${file.path}`);
        }
      } else {
        verboseLog(this.plugin, `Skipping cursor positioning - no matching active view for ${file.path}`);
      }
    } catch (error) {
      console.error(`Error positioning cursor for ${file.path}:`, error);
    }
  }
};

// src/core/link-manager.ts
var import_obsidian26 = require("obsidian");
init_utils();
init_modals();
init_i18n();
var LinkManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async addSafeInternalLink() {
    var _a;
    const activeEditor = (_a = this.plugin.app.workspace.activeEditor) == null ? void 0 : _a.editor;
    if (!activeEditor) {
      new import_obsidian26.Notice(t("notifications.errorNoActiveNote"));
      return;
    }
    const selection = activeEditor.getSelection();
    if (selection.trim()) {
      const safeLinkTarget = generateSafeLinkTarget(selection, this.plugin.settings);
      const wikiLink = `[[${safeLinkTarget}]]`;
      activeEditor.replaceSelection(wikiLink);
    } else {
      const modal = new InternalLinkModal(this.plugin.app, this.plugin, (linkTarget) => {
        const safeLinkTarget = generateSafeLinkTarget(linkTarget, this.plugin.settings);
        const wikiLink = `[[${safeLinkTarget}]]`;
        activeEditor.replaceSelection(wikiLink);
      });
      modal.open();
    }
  }
  async addSafeInternalLinkWithCaption() {
    var _a;
    const activeEditor = (_a = this.plugin.app.workspace.activeEditor) == null ? void 0 : _a.editor;
    if (!activeEditor) {
      new import_obsidian26.Notice(t("notifications.errorNoActiveNote"));
      return;
    }
    const selection = activeEditor.getSelection();
    if (selection.trim()) {
      const safeLinkTarget = generateSafeLinkTarget(selection, this.plugin.settings);
      const wikiLink = `[[${safeLinkTarget}|${selection}]]`;
      activeEditor.replaceSelection(wikiLink);
    } else {
      const modal = new InternalLinkModal(this.plugin.app, this.plugin, (linkTarget, linkCaption) => {
        const safeLinkTarget = generateSafeLinkTarget(linkTarget, this.plugin.settings);
        let wikiLink;
        if (linkCaption && linkCaption.trim()) {
          wikiLink = `[[${safeLinkTarget}|${linkCaption}]]`;
        } else {
          wikiLink = `[[${safeLinkTarget}|${linkTarget}]]`;
        }
        activeEditor.replaceSelection(wikiLink);
      }, true);
      modal.open();
    }
  }
};

// main.ts
var FirstLineIsTitle = class extends import_obsidian27.Plugin {
  constructor() {
    super(...arguments);
    this.isFullyLoaded = false;
    this.pluginLoadTime = 0;
    // Track files with pending metadata cache updates (for alias manager sync)
    this.pendingMetadataUpdates = /* @__PURE__ */ new Set();
    // Track FLIT modifications to suppress debug output
    this.flitModifications = /* @__PURE__ */ new Set();
    // Track batch operations to suppress debug output
    this.batchOperations = /* @__PURE__ */ new Set();
  }
  isTagWranglerEnabled() {
    return this.app.plugins.enabledPlugins.has("tag-wrangler");
  }
  cleanupStaleCache() {
    if (this.cacheManager) {
      this.cacheManager.forceCleanup();
      verboseLog(this, "Cache cleanup completed");
    }
  }
  async putFirstLineInTitleForFolder(folder) {
    return this.folderOperations.putFirstLineInTitleForFolder(folder);
  }
  async toggleFolderExclusion(folderPath) {
    return this.folderOperations.toggleFolderExclusion(folderPath);
  }
  async putFirstLineInTitleForTag(tagName, omitBodyTags = false, omitNestedTags = false) {
    return this.tagOperations.putFirstLineInTitleForTag(tagName, omitBodyTags, omitNestedTags);
  }
  async toggleTagExclusion(tagName) {
    return this.tagOperations.toggleTagExclusion(tagName);
  }
  // Debug logging helper for setting changes
  debugLog(settingName, value) {
    if (this.settings.verboseLogging) {
      console.debug(`Setting changed: ${settingName} = ${JSON.stringify(value)}`);
    }
  }
  // Debug file content output
  outputDebugFileContent(file, action, editorContent) {
    if (!this.settings.verboseLogging || !this.settings.debugOutputFullContent) {
      return;
    }
    try {
      const content = editorContent != null ? editorContent : "N/A (no editor content available)";
      console.debug(`CONTENT [${action}] ${file.path}:`);
      console.debug("--- FILE CONTENT START ---");
      console.debug(content);
      console.debug("--- FILE CONTENT END ---");
    } catch (error) {
      console.debug(`CONTENT [${action}] ${file.path}: Failed to read file:`, error);
    }
  }
  // Output all current settings when debug mode is enabled
  outputAllSettings() {
    if (!this.settings.verboseLogging) {
      return;
    }
    console.debug("SETTINGS: Complete configuration dump:");
    console.debug("--- SETTINGS START ---");
    console.debug(JSON.stringify(this.settings, null, 2));
    console.debug("--- SETTINGS END ---");
  }
  async insertTitleOnCreation(file) {
    return this.titleInsertion.insertTitleOnCreation(file);
  }
  getSelectedFolders() {
    return this.folderOperations.getSelectedFolders();
  }
  getAllMarkdownFilesInFolder(folder) {
    return this.folderOperations.getAllMarkdownFilesInFolder(folder);
  }
  async processMultipleFolders(folders, action) {
    return this.folderOperations.processMultipleFolders(folders, action);
  }
  async processMultipleFiles(files, action) {
    if (files.length === 0) return;
    let processed = 0;
    let skipped = 0;
    let errors = 0;
    new import_obsidian27.Notice(t("notifications.renamingNNotes").replace("{{count}}", String(files.length)));
    const exclusionOverrides = { ignoreFolder: true, ignoreTag: true, ignoreProperty: true };
    for (const file of files) {
      try {
        if (action === "rename") {
          const result = await this.renameEngine.processFile(file, true, true, void 0, false, exclusionOverrides);
          if (result.success) {
            processed++;
          } else {
            skipped++;
          }
        }
      } catch (error) {
        console.error(`Error processing file ${file.path}:`, error);
        errors++;
      }
    }
    if (errors > 0) {
      const errorMsg = t("notifications.renamedNotesWithErrors").replace("{{renamed}}", String(processed)).replace("{{total}}", String(files.length)).replace("{{errors}}", String(errors));
      new import_obsidian27.Notice(errorMsg, 0);
    } else {
      const successMsg = t("notifications.renamedNotes").replace("{{renamed}}", String(processed)).replace("{{total}}", String(files.length));
      new import_obsidian27.Notice(successMsg, 0);
    }
  }
  async registerDynamicCommands() {
    if (!this.settings.enableCommandPalette) return;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "md") return;
    const hasDisableProperty = await hasDisablePropertyInFile(activeFile, this.app);
    const commandsToRemove = ["disable-renaming-for-note", "enable-renaming-for-note"];
    commandsToRemove.forEach((id) => {
      if (this.app.commands.commands[id]) {
        this.app.commands.removeCommand(id);
      }
    });
    if (hasDisableProperty) {
      if (this.settings.commandPaletteVisibility.enableRenaming) {
        this.addCommand({
          id: "enable-renaming-for-note",
          name: t("commands.enableRenamingForNote"),
          icon: "square-check",
          callback: async () => {
            await this.enableRenamingForNote();
          }
        });
      }
    } else {
      if (this.settings.commandPaletteVisibility.disableRenaming) {
        this.addCommand({
          id: "disable-renaming-for-note",
          name: t("commands.disableRenamingForNote"),
          icon: "square-x",
          callback: async () => {
            await this.disableRenamingForNote();
          }
        });
      }
    }
  }
  parsePropertyValue(value) {
    const lowerValue = value.toLowerCase().trim();
    if (lowerValue === "true") return true;
    if (lowerValue === "false") return false;
    if (!isNaN(Number(value)) && value.trim() !== "") {
      return Number(value);
    }
    return value;
  }
  async disableRenamingForNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "md") {
      new import_obsidian27.Notice(t("notifications.errorNoActiveNote"));
      return;
    }
    await this.propertyManager.ensurePropertyTypeIsCheckbox();
    const hasProperty = await hasDisablePropertyInFile(activeFile, this.app);
    try {
      if (!hasProperty) {
        await this.app.fileManager.processFrontMatter(activeFile, (frontmatter) => {
          frontmatter[this.settings.disableRenamingKey] = this.parsePropertyValue(this.settings.disableRenamingValue);
        });
        await this.registerDynamicCommands();
      }
      new import_obsidian27.Notice(t("notifications.disabledRenamingFor", { filename: activeFile.basename }));
    } catch (error) {
      console.error("Failed to disable renaming:", error);
      new import_obsidian27.Notice(t("notifications.failedToDisable"));
    }
  }
  async enableRenamingForNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "md") {
      new import_obsidian27.Notice(t("notifications.errorNoActiveNote"));
      return;
    }
    const hasProperty = await hasDisablePropertyInFile(activeFile, this.app);
    try {
      if (hasProperty) {
        await this.app.fileManager.processFrontMatter(activeFile, (frontmatter) => {
          delete frontmatter[this.settings.disableRenamingKey];
        });
        await this.registerDynamicCommands();
      }
      new import_obsidian27.Notice(t("notifications.enabledRenamingFor", { filename: activeFile.basename }));
    } catch (error) {
      console.error("Failed to enable renaming:", error);
      new import_obsidian27.Notice(t("notifications.failedToEnable"));
    }
  }
  async addSafeInternalLink() {
    return this.linkManager.addSafeInternalLink();
  }
  async addSafeInternalLinkWithCaption() {
    return this.linkManager.addSafeInternalLinkWithCaption();
  }
  updatePropertyVisibility() {
    this.propertyVisibility.updatePropertyVisibility();
  }
  checkAndShowNotices() {
    const today = this.getTodayDateString();
    this.updateLastUsageDate(today);
    if (!this.settings.hasShownFirstTimeNotice) {
      this.showFirstTimeNotice();
      return;
    }
    if (this.settings.lastUsageDate && this.isInactive(this.settings.lastUsageDate, today) && this.settings.renameNotes === "Automatically") {
      this.showInactivityNotice();
    }
  }
  getTodayDateString() {
    const today = /* @__PURE__ */ new Date();
    return today.getFullYear() + "-" + String(today.getMonth() + 1).padStart(2, "0") + "-" + String(today.getDate()).padStart(2, "0");
  }
  getCurrentTimestamp() {
    const now = /* @__PURE__ */ new Date();
    return now.getFullYear() + "-" + String(now.getMonth() + 1).padStart(2, "0") + "-" + String(now.getDate()).padStart(2, "0") + " " + String(now.getHours()).padStart(2, "0") + ":" + String(now.getMinutes()).padStart(2, "0");
  }
  isInactive(lastUsageDate, todayDate) {
    const lastDate = new Date(lastUsageDate);
    const today = new Date(todayDate);
    const daysDiff = Math.floor((today.getTime() - lastDate.getTime()) / (1e3 * 60 * 60 * 24));
    return daysDiff > 30;
  }
  showFirstTimeNotice() {
    new import_obsidian27.Notice(t("notifications.firstTimeNotice"), 1e4);
    this.settings.hasShownFirstTimeNotice = true;
    this.saveSettings();
  }
  showInactivityNotice() {
    new import_obsidian27.Notice(t("notifications.firstTimeNotice"), 1e4);
  }
  updateLastUsageDate(today) {
    if (this.settings.lastUsageDate !== today) {
      this.settings.lastUsageDate = today;
      this.saveSettings();
    }
  }
  // Call this method at the start of any significant plugin operation
  trackUsage() {
    const today = this.getTodayDateString();
    this.updateLastUsageDate(today);
  }
  markFlitModificationStart(path) {
    this.flitModifications.add(path);
  }
  markFlitModificationEnd(path) {
    setTimeout(() => {
      this.flitModifications.delete(path);
    }, 100);
  }
  markBatchOperationStart(path) {
    this.batchOperations.add(path);
  }
  markBatchOperationEnd(path) {
    setTimeout(() => {
      this.batchOperations.delete(path);
    }, 100);
  }
  async onload() {
    this.pluginLoadTime = Date.now();
    initI18n();
    await this.loadSettings();
    if (this.settings.verboseLogging && this.settings.debugEnabledTimestamp) {
      const enabledTime = new Date(this.settings.debugEnabledTimestamp).getTime();
      const currentTime = (/* @__PURE__ */ new Date()).getTime();
      const hoursPassed = (currentTime - enabledTime) / (1e3 * 60 * 60);
      if (hoursPassed >= 24) {
        this.settings.verboseLogging = false;
        await this.saveSettings();
      }
    }
    this.cacheManager = new CacheManager(this);
    this.checkAndShowNotices();
    this.renameEngine = new RenameEngine(this);
    this.aliasManager = new AliasManager(this);
    this.contextMenuManager = new ContextMenuManager(this);
    this.folderOperations = new FolderOperations(
      this.app,
      this.settings,
      this.renameEngine,
      this.saveSettings.bind(this),
      this.debugLog.bind(this),
      this.processMultipleFiles.bind(this)
    );
    this.tagOperations = new TagOperations(
      this.app,
      this.settings,
      this.renameEngine,
      this.saveSettings.bind(this),
      this.debugLog.bind(this)
    );
    this.fileOperations = new FileOperations(this);
    this.editorLifecycle = new EditorLifecycleManager(this);
    this.workspaceIntegration = new WorkspaceIntegration(this);
    this.propertyManager = new PropertyManager(this);
    this.titleInsertion = new TitleInsertion(this);
    this.linkManager = new LinkManager(this);
    this.propertyVisibility = new PropertyVisibility(this);
    this.settings.osPreset = detectOS();
    await this.saveSettings();
    verboseLog(this, "Plugin loaded", this.settings);
    verboseLog(this, `Detected OS: \`${this.settings.osPreset}\``);
    const pluginInitializer = new PluginInitializer(this);
    await pluginInitializer.initializeFirstEnableLogic();
    await pluginInitializer.loadStyles();
    this.addSettingTab(new FirstLineIsTitleSettings(this.app, this));
    this.commandRegistrar = new CommandRegistrar(this);
    this.commandRegistrar.registerCommands();
    if (this.settings.enableRibbon) {
      this.app.workspace.onLayoutReady(() => {
        setTimeout(() => {
          this.workspaceIntegration.registerRibbonIcons();
        }, 0);
      });
    }
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (!this.settings.enableContextMenus) return;
        let hasVisibleItems = false;
        if (file instanceof import_obsidian27.TFile && file.extension === "md") {
          if (this.settings.commandVisibility.filePutFirstLineInTitle) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle(t("commands.putFirstLineInTitle")).setIcon("file-pen").onClick(async () => {
                const exclusionOverrides = { ignoreFolder: true, ignoreTag: true, ignoreProperty: true };
                await this.renameEngine.processFile(file, true, true, void 0, false, exclusionOverrides);
              });
            });
          }
          const fileCache = this.app.metadataCache.getFileCache(file);
          let hasDisableProperty = false;
          if (fileCache && fileCache.frontmatter) {
            const frontmatter = fileCache.frontmatter;
            const value = frontmatter[this.settings.disableRenamingKey];
            if (value !== void 0) {
              const valueStr = String(value).toLowerCase();
              const expectedValue = String(this.settings.disableRenamingValue).toLowerCase();
              hasDisableProperty = valueStr === expectedValue;
            }
          }
          if (!hasDisableProperty && this.settings.commandVisibility.fileExclude) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle(t("commands.disableRenamingForNote")).setIcon("square-x").onClick(async () => {
                try {
                  await this.propertyManager.ensurePropertyTypeIsCheckbox();
                  await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
                    frontmatter[this.settings.disableRenamingKey] = this.parsePropertyValue(this.settings.disableRenamingValue);
                  });
                  new import_obsidian27.Notice(t("notifications.disabledRenamingFor", { filename: file.basename }));
                } catch (error) {
                  console.error("Failed to disable renaming:", error);
                  new import_obsidian27.Notice(t("notifications.failedToDisable"));
                }
              });
            });
          } else if (hasDisableProperty && this.settings.commandVisibility.fileStopExcluding) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle(t("commands.enableRenamingForNote")).setIcon("square-check").onClick(async () => {
                try {
                  await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
                    delete frontmatter[this.settings.disableRenamingKey];
                  });
                  new import_obsidian27.Notice(t("notifications.enabledRenamingFor", { filename: file.basename }));
                } catch (error) {
                  console.error("Failed to enable renaming:", error);
                  new import_obsidian27.Notice(t("notifications.failedToEnable"));
                }
              });
            });
          }
        } else if (file instanceof import_obsidian27.TFolder) {
          if (this.settings.commandVisibility.folderPutFirstLineInTitle) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle(t("commands.putFirstLineInTitle")).setIcon("folder-pen").onClick(() => {
                new RenameFolderModal(this.app, this, file).open();
              });
            });
          }
          const shouldShowDisable = this.contextMenuManager.shouldShowDisableMenuForFolder(file.path);
          const menuText = this.contextMenuManager.getFolderMenuText(file.path);
          if (shouldShowDisable && this.settings.commandVisibility.folderExclude) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle(menuText.disable).setIcon("square-x").onClick(async () => {
                await this.toggleFolderExclusion(file.path);
              });
            });
          }
          if (!shouldShowDisable && this.settings.commandVisibility.folderStopExcluding) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle(menuText.enable).setIcon("square-check").onClick(async () => {
                await this.toggleFolderExclusion(file.path);
              });
            });
          }
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("files-menu", (menu, files) => {
        if (!this.settings.enableContextMenus) return;
        const markdownFiles = files.filter((file) => file instanceof import_obsidian27.TFile && file.extension === "md");
        const folders = files.filter((file) => file instanceof import_obsidian27.TFolder);
        if (markdownFiles.length > 0 && folders.length > 0) return;
        if (markdownFiles.length === 0 && folders.length === 0) return;
        let hasVisibleItems = false;
        if (markdownFiles.length > 0) {
          if (this.settings.commandVisibility.filePutFirstLineInTitle) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle(tp("commands.putFirstLineInTitleNNotes", markdownFiles.length)).setIcon("file-pen").onClick(async () => {
                new RenameModal(this.app, this, markdownFiles).open();
              });
            });
          }
          if (this.settings.commandVisibility.fileExclude) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle(tp("commands.disableRenamingNNotes", markdownFiles.length)).setIcon("square-x").onClick(async () => {
                new DisableEnableModal(this.app, this, markdownFiles, "disable").open();
              });
            });
          }
          if (this.settings.commandVisibility.fileStopExcluding) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle(tp("commands.enableRenamingNNotes", markdownFiles.length)).setIcon("square-check").onClick(async () => {
                new DisableEnableModal(this.app, this, markdownFiles, "enable").open();
              });
            });
          }
        }
        if (folders.length > 1) {
          this.contextMenuManager.addMultiFolderMenuItems(menu, folders);
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        if (!this.settings.enableContextMenus) return;
        const token = editor.getClickableTokenAt(editor.getCursor());
        if ((token == null ? void 0 : token.type) === "tag") {
          const tagName = token.text.startsWith("#") ? token.text.slice(1) : token.text;
          this.contextMenuManager.addTagMenuItems(menu, tagName);
        }
      })
    );
    this.registerDomEvent(document, "contextmenu", (evt) => {
      var _a;
      if (!this.settings.enableContextMenus) return;
      const target = evt.target;
      const tagElement = target.closest(".tag-pane-tag");
      if (tagElement) {
        const tagNameEl = tagElement.querySelector(".tag-pane-tag-text, .tag-pane-tag .tree-item-inner-text");
        const tagText = (_a = tagNameEl == null ? void 0 : tagNameEl.textContent) == null ? void 0 : _a.trim();
        if (tagText) {
          const tagName = tagText.startsWith("#") ? tagText.slice(1) : tagText;
          const menu = this.contextMenuManager.menuForEvent(evt);
          this.contextMenuManager.addTagMenuItems(menu, tagName);
        }
        return;
      }
      const yamlTagElement = target.closest('.metadata-property[data-property-key="tags"] .multi-select-pill');
      if (yamlTagElement) {
        return;
      }
      const readingModeTag = target.closest('a.tag[href^="#"]');
      if (readingModeTag) {
        const href = readingModeTag.getAttribute("href");
        if (href) {
          const tagName = href.slice(1);
          const menu = this.contextMenuManager.menuForEvent(evt);
          this.contextMenuManager.addTagMenuItems(menu, tagName);
        }
        return;
      }
    }, true);
    this.registerDomEvent(document, "contextmenu", (evt) => {
      var _a;
      if (!this.settings.enableContextMenus) return;
      const target = evt.target;
      const yamlTagElement = target.closest('.metadata-property[data-property-key="tags"] .multi-select-pill');
      if (yamlTagElement) {
        const tagText = (_a = yamlTagElement.textContent) == null ? void 0 : _a.trim();
        if (tagText) {
          const tagName = tagText.startsWith("#") ? tagText.slice(1) : tagText;
          const plugin = this;
          const remove = around(import_obsidian27.Menu.prototype, {
            showAtPosition(old) {
              return function(...args) {
                remove();
                plugin.contextMenuManager.addTagMenuItems(this, tagName);
                return old.apply(this, args);
              };
            }
          });
          if (import_obsidian27.Menu.forEvent) {
            const remove2 = around(import_obsidian27.Menu, { forEvent(old) {
              return function(ev) {
                const m = old.call(this, evt);
                if (ev === evt) {
                  plugin.contextMenuManager.addTagMenuItems(m, tagName);
                  remove();
                }
                remove2();
                return m;
              };
            } });
            setTimeout(remove2, 0);
          }
          setTimeout(remove, 0);
        }
      }
    }, true);
    this.registerEvent(
      this.app.workspace.on("search:results-menu", (menu, leaf) => {
        var _a, _b;
        if (!this.settings.enableVaultSearchContextMenu) return;
        let files = [];
        if ((_b = (_a = leaf.dom) == null ? void 0 : _a.vChildren) == null ? void 0 : _b.children) {
          leaf.dom.vChildren.children.forEach((e) => {
            if (e.file && e.file instanceof import_obsidian27.TFile && e.file.extension === "md") {
              files.push(e.file);
            }
          });
        }
        if (files.length < 1) return;
        let hasVisibleItems = false;
        if (this.settings.vaultSearchContextMenuVisibility.putFirstLineInTitle) {
          if (!hasVisibleItems) {
            menu.addSeparator();
            hasVisibleItems = true;
          }
          menu.addItem((item) => {
            item.setTitle(tp("commands.putFirstLineInTitleNNotes", files.length)).setIcon("file-pen").onClick(async () => {
              new RenameModal(this.app, this, files).open();
            });
          });
        }
        if (this.settings.vaultSearchContextMenuVisibility.disable) {
          if (!hasVisibleItems) {
            menu.addSeparator();
            hasVisibleItems = true;
          }
          menu.addItem((item) => {
            item.setTitle(tp("commands.disableRenamingNNotes", files.length)).setIcon("square-x").onClick(async () => {
              new DisableEnableModal(this.app, this, files, "disable").open();
            });
          });
        }
        if (this.settings.vaultSearchContextMenuVisibility.enable) {
          if (!hasVisibleItems) {
            menu.addSeparator();
            hasVisibleItems = true;
          }
          menu.addItem((item) => {
            item.setTitle(tp("commands.enableRenamingNNotes", files.length)).setIcon("square-check").onClick(async () => {
              new DisableEnableModal(this.app, this, files, "enable").open();
            });
          });
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-change", async (editor, info) => {
        var _a, _b;
        verboseLog(this, `Editor change detected for file: ${((_a = info.file) == null ? void 0 : _a.path) || "unknown"}`);
        if (info.file && editor) {
          const content = editor.getValue();
          this.fileOperations.checkYamlAndResolve(info.file, content);
          this.outputDebugFileContent(info.file, "MODIFIED", content);
        }
        if (this.settings.renameNotes !== "automatically") {
          verboseLog(this, `Skipping: automatic renaming disabled (${this.settings.renameNotes})`);
          return;
        }
        if (!info.file || info.file.extension !== "md") {
          verboseLog(this, `Skipping: not markdown file (${((_b = info.file) == null ? void 0 : _b.extension) || "no file"})`);
          return;
        }
        if (!this.isFullyLoaded) {
          verboseLog(this, `Skipping: plugin not fully loaded`);
          return;
        }
        if (this.editorLifecycle.isFileInCreationDelay(info.file.path)) {
          verboseLog(this, `Skipping editor-change: file in creation delay: ${info.file.path}`);
          return;
        }
        if (this.settings.fileReadMethod !== "Editor") {
          verboseLog(this, `Skipping editor-change: fileReadMethod is '${this.settings.fileReadMethod}' (not 'Editor')`);
          return;
        }
        if (this.settings.checkInterval === 0) {
          verboseLog(this, `Processing immediate change for: ${info.file.path}`);
          await this.renameEngine.processEditorChangeOptimal(editor, info.file);
        } else {
          verboseLog(this, `Editor changed, starting/checking throttle timer for: ${info.file.path}`);
          this.editorLifecycle.handleEditorChangeWithThrottle(editor, info.file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", async (file) => {
        if (!(file instanceof import_obsidian27.TFile) || file.extension !== "md") return;
        if (this.settings.fileReadMethod === "Cache" || this.settings.fileReadMethod === "File") {
          if (this.settings.renameNotes === "automatically" && this.isFullyLoaded) {
            verboseLog(this, `Modify event: processing ${file.path} (fileReadMethod: ${this.settings.fileReadMethod})`);
            await this.renameEngine.processFile(file, true);
          }
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (abstractFile) => {
        if (abstractFile instanceof import_obsidian27.TFile) {
          if (this.cacheManager) {
            this.cacheManager.notifyFileDeleted(abstractFile.path);
          }
          verboseLog(this, `File deleted, cleaned up cache: ${abstractFile.path}`);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (abstractFile, oldPath) => {
        if (abstractFile instanceof import_obsidian27.TFile) {
          this.editorLifecycle.clearCreationDelayTimer(oldPath);
          this.editorLifecycle.clearViewReadinessTimer(oldPath);
          const lastContent = this.renameEngine.getLastEditorContent(oldPath);
          if (lastContent !== void 0) {
            this.renameEngine.deleteLastEditorContent(oldPath);
            this.renameEngine.setLastEditorContent(abstractFile.path, lastContent);
          }
          if (this.cacheManager) {
            this.cacheManager.notifyFileRenamed(oldPath, abstractFile.path);
          }
          verboseLog(this, `File renamed, updated cache: ${oldPath} -> ${abstractFile.path}`);
        }
      })
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        if (this.pendingMetadataUpdates.has(file.path)) {
          this.pendingMetadataUpdates.delete(file.path);
          verboseLog(this, `Metadata cache updated, cleared pending flag: ${file.path}`);
        }
      })
    );
    this.propertyManager.setupNotificationSuppression();
    this.workspaceIntegration.setupCursorPositioning();
    this.workspaceIntegration.setupSaveEventHook();
    this.updatePropertyVisibility();
    this.app.workspace.onLayoutReady(() => {
      setTimeout(() => {
        this.isFullyLoaded = true;
        this.editorLifecycle.initializeCheckingSystem();
        verboseLog(this, "Checking system initialized based on checkInterval setting");
      }, 1e3);
    });
  }
  onunload() {
    if (this.cacheManager) {
      this.cacheManager.dispose();
    }
    if (this.editorLifecycle) {
      this.editorLifecycle.clearCheckingSystems();
    }
    if (this.workspaceIntegration) {
      this.workspaceIntegration.cleanup();
    }
    if (this.propertyManager) {
      this.propertyManager.cleanupNotificationSuppression();
    }
    if (this.propertyVisibility) {
      this.propertyVisibility.cleanup();
    }
    if (this.cacheManager) {
      this.cacheManager.clearAllAliasTimers();
    }
    verboseLog(this, "Plugin unloaded");
  }
  async loadSettings() {
    const loadedData = await this.loadData() || {};
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      loadedData
    );
    if (!this.settings.scopeStrategy) {
      this.settings.scopeStrategy = "Enable in all notes except below";
    }
    if (this.settings.excludedFolders.length === 0) {
      this.settings.excludedFolders.push("");
    }
    if (this.settings.excludedTags.length === 0) {
      this.settings.excludedTags.push("");
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
