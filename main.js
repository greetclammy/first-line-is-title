/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FirstLineIsTitle
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  excludedFolders: [],
  charCount: 100,
  checkInterval: 500,
  charReplacements: {
    slash: " \u2215 ",
    colon: "\u0589",
    pipe: "\u2758",
    hash: "\uFF03",
    leftBracket: "\u301A",
    rightBracket: "\u301B",
    caret: "\u02C6",
    dot: "\u2024"
  },
  charReplacementEnabled: {
    slash: true,
    colon: true,
    pipe: true,
    hash: true,
    leftBracket: true,
    rightBracket: true,
    caret: true,
    dot: false
  },
  customReplacements: [
    { searchText: ".", replaceText: "\u2024", onlyAtStart: false, enabled: true },
    { searchText: "- [ ] ", replaceText: "\u2714\uFE0F", onlyAtStart: true, enabled: true },
    { searchText: "- [x] ", replaceText: "\u2705", onlyAtStart: true, enabled: true }
  ],
  omitHtmlTags: true,
  enableIllegalCharReplacements: false,
  enableCustomReplacements: false,
  renameOnFocus: true
};
var renamedFileCount = 0;
var tempNewPaths = [];
var onTimeout = true;
var timeout;
var previousFile;
var previousContent = /* @__PURE__ */ new Map();
function inExcludedFolder(file, settings) {
  var _a;
  if (settings.excludedFolders.length === 0) return false;
  if (settings.excludedFolders.includes((_a = file.parent) == null ? void 0 : _a.path))
    return true;
  return false;
}
function extractTitle(line, settings) {
  const originalLine = line;
  line = line.trim();
  line = line.replace(/<%\s*tp\.file\.cursor\(\)\s*%>/, "").trim();
  if (line === "<%*") {
    return "Untitled";
  }
  const isValidHeading = /^#{1,6}\s/.test(line);
  const escapeMap = /* @__PURE__ */ new Map();
  let escapeCounter = 0;
  line = line.replace(/\\(.)/g, (match, char) => {
    const placeholder = `__ESCAPED_${escapeCounter++}__`;
    escapeMap.set(placeholder, char);
    return placeholder;
  });
  line = line.replace(/%%.*?%%/g, (match) => {
    return match.slice(2, -2);
  });
  if (settings.omitHtmlTags) {
    let previousLine = "";
    while (line !== previousLine) {
      previousLine = line;
      line = line.replace(/<([a-zA-Z][a-zA-Z0-9]*)\b[^>]*>(.*?)<\/\1>/g, "$2");
    }
  }
  const embedLinkRegex = /!\[\[(.*?)\]\]/g;
  line = line.replace(embedLinkRegex, "[[$1]]");
  const regularEmbedRegex = /!\[(.*?)\]\((.*?)\)/g;
  line = line.replace(regularEmbedRegex, (match, caption) => caption);
  if (isValidHeading) {
    const headerArr = [
      "# ",
      "## ",
      "### ",
      "#### ",
      "##### ",
      "###### "
    ];
    for (let i = 0; i < headerArr.length; i++) {
      if (line.startsWith(headerArr[i])) {
        line = line.slice(headerArr[i].length).trim();
        break;
      }
    }
  }
  if (settings.enableCustomReplacements) {
    for (const replacement of settings.customReplacements) {
      if (replacement.searchText === "" || !replacement.enabled) continue;
      let tempLine = line;
      if (replacement.onlyAtStart) {
        if (tempLine.startsWith(replacement.searchText)) {
          tempLine = replacement.replaceText + tempLine.slice(replacement.searchText.length);
        }
      } else {
        tempLine = tempLine.replaceAll(replacement.searchText, replacement.replaceText);
      }
      if (tempLine.trim() === "" && line.trim() === replacement.searchText.trim()) {
        return "Untitled";
      }
      line = tempLine;
    }
  }
  while (line.includes("[[") && line.includes("]]")) {
    const openBracket = line.indexOf("[[");
    const closeBracket = line.indexOf("]]", openBracket);
    if (openBracket === -1 || closeBracket === -1) break;
    const linkText = line.slice(openBracket + 2, closeBracket);
    const beforeLink = line.slice(0, openBracket);
    const afterLink = line.slice(closeBracket + 2);
    const pipeIndex = linkText.indexOf("|");
    const resolvedText = pipeIndex !== -1 ? linkText.slice(pipeIndex + 1) : linkText;
    line = (beforeLink + resolvedText + afterLink).trim();
  }
  const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
  line = line.replace(markdownLinkRegex, (_, title) => title);
  for (const [placeholder, char] of escapeMap) {
    line = line.replace(placeholder, char);
  }
  return line;
}
var RenameAllFilesModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const heading = contentEl.createEl("h2", { text: "Warning" });
    heading.style.textAlign = "center";
    contentEl.createEl("p", {
      text: "This will edit all of your files except those in excluded folders, and may introduce errors. Make sure you have backed up your files."
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.marginTop = "20px";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => this.close();
    const renameButton = buttonContainer.createEl("button", { text: "Rename all files" });
    renameButton.addClass("mod-cta");
    renameButton.onclick = async () => {
      this.close();
      await this.renameAllFiles();
    };
  }
  async renameAllFiles() {
    let filesToRename = [];
    this.app.vault.getMarkdownFiles().forEach((file) => {
      if (!inExcludedFolder(file, this.plugin.settings)) {
        filesToRename.push(file);
      }
    });
    renamedFileCount = 0;
    tempNewPaths = [];
    const pleaseWaitNotice = new import_obsidian.Notice(`Renaming files, please wait...`, 0);
    try {
      await Promise.all(
        filesToRename.map(
          (file) => this.plugin.renameFile(file, true)
        )
      );
    } finally {
      pleaseWaitNotice.hide();
      new import_obsidian.Notice(
        `Renamed ${renamedFileCount}/${filesToRename.length} files.`,
        0
      );
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var FirstLineIsTitle = class extends import_obsidian.Plugin {
  cleanupStaleCache() {
    tempNewPaths = tempNewPaths.filter((path) => {
      return this.app.vault.getAbstractFileByPath(path) !== null;
    });
    for (const [path, content] of previousContent) {
      if (!this.app.vault.getAbstractFileByPath(path)) {
        previousContent.delete(path);
      }
    }
  }
  async renameFile(file, noDelay = false) {
    var _a, _b, _c, _d;
    if (inExcludedFolder(file, this.settings)) return;
    if (file.extension !== "md") return;
    if (noDelay === false) {
      if (onTimeout) {
        if (previousFile == file.path) {
          clearTimeout(timeout);
        }
        previousFile = file.path;
        timeout = setTimeout(() => {
          onTimeout = false;
          this.renameFile(file);
        }, this.settings.checkInterval);
        return;
      }
      onTimeout = true;
    } else {
      if (!tempNewPaths.length || tempNewPaths.length < 10) {
        tempNewPaths = [];
      }
    }
    this.cleanupStaleCache();
    let content = await this.app.vault.cachedRead(file);
    if (content.startsWith("---")) {
      let index = content.indexOf("---", 3);
      if (index != -1) content = content.slice(index + 3).trimStart();
    }
    const currentName = file.basename;
    let firstLine = content.split("\n")[0];
    const previousFileContent = previousContent.get(file.path);
    if (content.trim() === "" && previousFileContent && previousFileContent.trim() !== "") {
      const parentPath2 = ((_a = file.parent) == null ? void 0 : _a.path) === "/" ? "" : ((_b = file.parent) == null ? void 0 : _b.path) + "/";
      let newPath2 = `${parentPath2}Untitled.md`;
      let counter2 = 0;
      let fileExists2 = this.app.vault.getAbstractFileByPath(newPath2) != null;
      while (fileExists2 || tempNewPaths.includes(newPath2)) {
        if (file.path == newPath2) {
          previousContent.set(file.path, content);
          return;
        }
        counter2 += 1;
        newPath2 = `${parentPath2}Untitled ${counter2}.md`;
        fileExists2 = this.app.vault.getAbstractFileByPath(newPath2) != null;
      }
      if (noDelay) {
        tempNewPaths.push(newPath2);
      }
      await this.app.fileManager.renameFile(file, newPath2);
      renamedFileCount += 1;
      previousContent.set(file.path, content);
      return;
    }
    previousContent.set(file.path, content);
    if (firstLine === "") {
      return;
    }
    const escapedName = currentName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const wikiLinkRegex = new RegExp(`\\[\\[${escapedName}(\\|.*?)?\\]\\]`);
    const internalMarkdownLinkRegex = new RegExp(`\\(\\#${escapedName}\\)`, "i");
    const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
    let isSelfReferencing = false;
    if (wikiLinkRegex.test(firstLine)) {
      isSelfReferencing = true;
    }
    let match;
    while ((match = markdownLinkRegex.exec(firstLine)) !== null) {
      const url = match[2];
      if (url.startsWith("#") && url.includes(currentName)) {
        isSelfReferencing = true;
        break;
      }
    }
    if (isSelfReferencing) {
      new import_obsidian.Notice("File not renamed - first line references current filename", 0);
      return;
    }
    content = extractTitle(firstLine, this.settings);
    const charMap = {
      "/": this.settings.charReplacements.slash,
      ":": this.settings.charReplacements.colon,
      "|": this.settings.charReplacements.pipe,
      "#": this.settings.charReplacements.hash,
      "[": this.settings.charReplacements.leftBracket,
      "]": this.settings.charReplacements.rightBracket,
      "^": this.settings.charReplacements.caret,
      ".": this.settings.charReplacements.dot
    };
    const illegalChars = Object.keys(charMap).join("");
    const illegalNames = [
      "CON",
      "PRN",
      "AUX",
      "NUL",
      "COM1",
      "COM2",
      "COM3",
      "COM4",
      "COM5",
      "COM6",
      "COM7",
      "COM8",
      "COM9",
      "COM0",
      "LPT1",
      "LPT2",
      "LPT3",
      "LPT4",
      "LPT5",
      "LPT6",
      "LPT7",
      "LPT8",
      "LPT9",
      "LPT0"
    ];
    let newFileName = "";
    for (let i = 0; i < content.length; i++) {
      if (newFileName.length >= this.settings.charCount - 1) {
        newFileName = newFileName.trimEnd();
        newFileName += "\u2026";
        break;
      }
      let char = content[i];
      if (illegalChars.includes(char)) {
        let shouldReplace = false;
        let replacement = "";
        if (this.settings.enableIllegalCharReplacements) {
          switch (char) {
            case "/":
              shouldReplace = this.settings.charReplacementEnabled.slash;
              replacement = this.settings.charReplacements.slash;
              break;
            case ":":
              shouldReplace = this.settings.charReplacementEnabled.colon;
              replacement = this.settings.charReplacements.colon;
              break;
            case "|":
              shouldReplace = this.settings.charReplacementEnabled.pipe;
              replacement = this.settings.charReplacements.pipe;
              break;
            case "#":
              shouldReplace = this.settings.charReplacementEnabled.hash;
              replacement = this.settings.charReplacements.hash;
              break;
            case "[":
              shouldReplace = this.settings.charReplacementEnabled.leftBracket;
              replacement = this.settings.charReplacements.leftBracket;
              break;
            case "]":
              shouldReplace = this.settings.charReplacementEnabled.rightBracket;
              replacement = this.settings.charReplacements.rightBracket;
              break;
            case "^":
              shouldReplace = this.settings.charReplacementEnabled.caret;
              replacement = this.settings.charReplacements.caret;
              break;
            case ".":
              shouldReplace = this.settings.charReplacementEnabled.dot;
              replacement = this.settings.charReplacements.dot;
              break;
          }
        }
        if (shouldReplace && replacement !== "") {
          newFileName += replacement;
        }
      } else {
        newFileName += char;
      }
    }
    newFileName = newFileName.trim().replace(/\s+/g, " ");
    while (newFileName[0] == ".") {
      newFileName = newFileName.slice(1);
    }
    const isIllegalName = newFileName === "" || illegalNames.includes(newFileName.toUpperCase());
    if (isIllegalName) newFileName = "Untitled";
    const parentPath = ((_c = file.parent) == null ? void 0 : _c.path) === "/" ? "" : ((_d = file.parent) == null ? void 0 : _d.path) + "/";
    let newPath = `${parentPath}${newFileName}.md`;
    let counter = 0;
    let fileExists = this.app.vault.getAbstractFileByPath(newPath) != null;
    while (fileExists || tempNewPaths.includes(newPath)) {
      if (file.path == newPath) return;
      counter += 1;
      newPath = `${parentPath}${newFileName} ${counter}.md`;
      fileExists = this.app.vault.getAbstractFileByPath(newPath) != null;
    }
    if (noDelay) {
      tempNewPaths.push(newPath);
    }
    await this.app.fileManager.renameFile(file, newPath);
    renamedFileCount += 1;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new FirstLineIsTitleSettings(this.app, this));
    this.addCommand({
      id: "rename-current-file",
      name: "Rename current file",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && activeFile.extension === "md") {
          await this.renameFile(activeFile, true);
        }
      }
    });
    this.addCommand({
      id: "rename-all-files",
      name: "Rename all files",
      callback: () => {
        new RenameAllFilesModal(this.app, this).open();
      }
    });
    this.registerEvent(
      this.app.vault.on("modify", (abstractFile) => {
        if (abstractFile instanceof import_obsidian.TFile && abstractFile.extension === "md") {
          const noDelay = this.settings.checkInterval === 0;
          this.renameFile(abstractFile, noDelay);
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if (this.settings.renameOnFocus && leaf && leaf.view && leaf.view.file && leaf.view.file instanceof import_obsidian.TFile && leaf.view.file.extension === "md") {
          this.renameFile(leaf.view.file, true);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (abstractFile) => {
        if (abstractFile instanceof import_obsidian.TFile) {
          const index = tempNewPaths.indexOf(abstractFile.path);
          if (index > -1) {
            tempNewPaths.splice(index, 1);
          }
          previousContent.delete(abstractFile.path);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (abstractFile, oldPath) => {
        if (abstractFile instanceof import_obsidian.TFile) {
          const index = tempNewPaths.indexOf(oldPath);
          if (index > -1) {
            tempNewPaths[index] = abstractFile.path;
          }
          const oldContent = previousContent.get(oldPath);
          if (oldContent !== void 0) {
            previousContent.delete(oldPath);
            previousContent.set(abstractFile.path, oldContent);
          }
        }
      })
    );
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var FirstLineIsTitleSettings = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    this.containerEl.empty();
    new import_obsidian.Setting(this.containerEl).setName("Exclude folders").setDesc(
      "Folder paths to exclude from auto-renaming. Includes all subfolders. Separate by newline. Case-sensitive."
    ).addTextArea((text) => {
      text.setPlaceholder("/\nfolder\nfolder/subfolder").setValue(this.plugin.settings.excludedFolders.join("\n")).onChange(async (value) => {
        this.plugin.settings.excludedFolders = value.split("\n");
        await this.plugin.saveSettings();
      });
      text.inputEl.cols = 28;
      text.inputEl.rows = 4;
    });
    new import_obsidian.Setting(this.containerEl).setName("Character count").setDesc("The maximum number of characters to put in title. Enter a value from 10 to 200. Default: 100.").addText(
      (text) => text.setPlaceholder("100").setValue(String(this.plugin.settings.charCount)).onChange(async (value) => {
        if (value === "") {
          this.plugin.settings.charCount = DEFAULT_SETTINGS.charCount;
        } else {
          const numVal = Number(value);
          if (numVal >= 10 && numVal <= 200) {
            this.plugin.settings.charCount = numVal;
          }
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(this.containerEl).setName("Check interval").setDesc("Interval in milliseconds of how often to rename files while editing. Increase if there's performance issues. Default: 500.").addText(
      (text) => text.setPlaceholder("500").setValue(String(this.plugin.settings.checkInterval)).onChange(async (value) => {
        if (value === "") {
          this.plugin.settings.checkInterval = DEFAULT_SETTINGS.checkInterval;
        } else if (!isNaN(Number(value))) {
          this.plugin.settings.checkInterval = Number(value);
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(this.containerEl).setName("Omit HTML tags").setDesc("Don't put HTML tags like <u> in title.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.omitHtmlTags).onChange(async (value) => {
        this.plugin.settings.omitHtmlTags = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(this.containerEl).setName("Rename on focus").setDesc("Automatically rename files when they become focused/active.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.renameOnFocus).onChange(async (value) => {
        this.plugin.settings.renameOnFocus = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(this.containerEl).setName("Rename all files").setDesc("Rename all files except those in excluded folders. Can also be run from the Command palette.").addButton(
      (button) => button.setButtonText("Rename").onClick(() => {
        new RenameAllFilesModal(this.app, this.plugin).open();
      })
    );
    this.containerEl.createEl("br");
    const charHeaderContainer = this.containerEl.createEl("div", { cls: "setting-item" });
    charHeaderContainer.style.display = "flex";
    charHeaderContainer.style.justifyContent = "space-between";
    charHeaderContainer.style.alignItems = "center";
    charHeaderContainer.style.marginBottom = "10px";
    const charHeader = charHeaderContainer.createEl("h3", { text: "Illegal character replacements" });
    charHeader.style.margin = "0";
    const headerToggleSetting = new import_obsidian.Setting(document.createElement("div"));
    headerToggleSetting.addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableIllegalCharReplacements).onChange(async (value) => {
        this.plugin.settings.enableIllegalCharReplacements = value;
        await this.plugin.saveSettings();
        updateCharacterReplacementUI();
      });
      charHeaderContainer.appendChild(toggle.toggleEl);
    });
    const charDescEl = this.containerEl.createEl("div", {
      text: "Define replacements for illegal filename characters. Whitespace preserved.",
      cls: "setting-item-description"
    });
    this.containerEl.createEl("br");
    const charSettings = [
      { key: "slash", name: "Slash /", char: "/" },
      { key: "colon", name: "Colon :", char: ":" },
      { key: "pipe", name: "Pipe |", char: "|" },
      { key: "hash", name: "Hash #", char: "#" },
      { key: "leftBracket", name: "Left bracket [", char: "[" },
      { key: "rightBracket", name: "Right bracket ]", char: "]" },
      { key: "caret", name: "Caret ^", char: "^" }
    ];
    const updateCharacterReplacementUI = () => {
      const isEnabled = this.plugin.settings.enableIllegalCharReplacements;
      charDescEl.style.opacity = isEnabled ? "1" : "0.5";
      const charSettingsEls = this.containerEl.querySelectorAll(".char-replacement-setting");
      charSettingsEls.forEach((el) => {
        el.style.opacity = isEnabled ? "1" : "0.5";
        el.style.pointerEvents = isEnabled ? "auto" : "none";
        const inputs = el.querySelectorAll('input[type="text"]');
        const toggles = el.querySelectorAll('.checkbox-container, input[type="checkbox"], .clickable-icon');
        inputs.forEach((input) => input.disabled = !isEnabled);
        toggles.forEach((toggle) => {
          toggle.style.pointerEvents = isEnabled ? "auto" : "none";
          if (toggle instanceof HTMLInputElement) {
            toggle.disabled = !isEnabled;
          }
        });
      });
    };
    charSettings.forEach((setting, index) => {
      const rowEl = this.containerEl.createEl("div", { cls: "char-replacement-setting" });
      rowEl.style.display = "flex";
      rowEl.style.alignItems = "center";
      rowEl.style.padding = "8px 0";
      if (index < charSettings.length - 1) {
        rowEl.style.borderBottom = "1px solid var(--background-modifier-border)";
      }
      const toggleSetting = new import_obsidian.Setting(document.createElement("div"));
      toggleSetting.addToggle((toggle) => {
        toggle.setValue(this.plugin.settings.charReplacementEnabled[setting.key]).onChange(async (value) => {
          this.plugin.settings.charReplacementEnabled[setting.key] = value;
          await this.plugin.saveSettings();
        });
        toggle.toggleEl.style.margin = "0";
        rowEl.appendChild(toggle.toggleEl);
      });
      const nameLabel = rowEl.createEl("span", { text: setting.name });
      nameLabel.style.marginLeft = "8px";
      nameLabel.style.minWidth = "120px";
      nameLabel.style.flexGrow = "1";
      const textInput = rowEl.createEl("input", { type: "text" });
      textInput.placeholder = "Replace with";
      textInput.value = this.plugin.settings.charReplacements[setting.key];
      textInput.style.width = "200px";
      textInput.setAttribute("data-setting-key", setting.key);
      textInput.addEventListener("input", async (e) => {
        this.plugin.settings.charReplacements[setting.key] = e.target.value;
        await this.plugin.saveSettings();
      });
    });
    updateCharacterReplacementUI();
    const restoreDefaultsSetting = new import_obsidian.Setting(this.containerEl).addButton(
      (button) => button.setButtonText("Restore defaults").onClick(async () => {
        this.plugin.settings.charReplacements = { ...DEFAULT_SETTINGS.charReplacements };
        await this.plugin.saveSettings();
        charSettings.forEach((setting) => {
          const textInput = this.containerEl.querySelector(`input[data-setting-key="${setting.key}"]`);
          if (textInput) {
            textInput.value = this.plugin.settings.charReplacements[setting.key];
          }
        });
      })
    );
    restoreDefaultsSetting.settingEl.addClass("restore-defaults-button");
    restoreDefaultsSetting.settingEl.style.opacity = this.plugin.settings.enableIllegalCharReplacements ? "1" : "0.5";
    restoreDefaultsSetting.settingEl.style.pointerEvents = this.plugin.settings.enableIllegalCharReplacements ? "auto" : "none";
    this.containerEl.createEl("br");
    const customHeaderContainer = this.containerEl.createEl("div", { cls: "setting-item" });
    customHeaderContainer.style.display = "flex";
    customHeaderContainer.style.justifyContent = "space-between";
    customHeaderContainer.style.alignItems = "center";
    customHeaderContainer.style.marginBottom = "10px";
    const customHeader = customHeaderContainer.createEl("h3", { text: "Custom replacements" });
    customHeader.style.margin = "0";
    const customHeaderToggleSetting = new import_obsidian.Setting(document.createElement("div"));
    customHeaderToggleSetting.addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableCustomReplacements).onChange(async (value) => {
        this.plugin.settings.enableCustomReplacements = value;
        await this.plugin.saveSettings();
        updateCustomReplacementUI();
      });
      customHeaderContainer.appendChild(toggle.toggleEl);
    });
    const customDescEl = this.containerEl.createEl("div", { cls: "setting-item-description" });
    customDescEl.innerHTML = "Define custom text replacements. Whitespace preserved.<br><br>Leave <em>Replace with</em> blank to omit text entirely. If <em>Replace with</em> is blank and <em>Text to replace</em> matches whole line, put <em>Untitled</em> in title.";
    this.containerEl.createEl("br");
    const updateCustomReplacementUI = () => {
      const isEnabled = this.plugin.settings.enableCustomReplacements;
      customDescEl.style.opacity = isEnabled ? "1" : "0.5";
      const customSettingsEls = this.containerEl.querySelectorAll(".custom-replacement-setting");
      customSettingsEls.forEach((el) => {
        el.style.opacity = isEnabled ? "1" : "0.5";
        el.style.pointerEvents = isEnabled ? "auto" : "none";
        const inputs = el.querySelectorAll('input[type="text"]');
        const toggles = el.querySelectorAll('.checkbox-container, input[type="checkbox"], .clickable-icon');
        const buttons = el.querySelectorAll("button");
        inputs.forEach((input) => input.disabled = !isEnabled);
        toggles.forEach((toggle) => {
          toggle.style.pointerEvents = isEnabled ? "auto" : "none";
          if (toggle instanceof HTMLInputElement) {
            toggle.disabled = !isEnabled;
          }
        });
        buttons.forEach((button) => button.disabled = !isEnabled);
      });
      const addButton = this.containerEl.querySelector(".add-replacement-button button");
      if (addButton) {
        addButton.disabled = !isEnabled;
        addButton.parentElement.style.opacity = isEnabled ? "1" : "0.5";
      }
    };
    const renderCustomReplacements = () => {
      const existingCustomSettings = this.containerEl.querySelectorAll(".custom-replacement-setting");
      existingCustomSettings.forEach((el) => el.remove());
      const existingAddButton = this.containerEl.querySelector(".add-replacement-button");
      if (existingAddButton) existingAddButton.remove();
      this.plugin.settings.customReplacements.forEach((replacement, index) => {
        const rowEl = this.containerEl.createEl("div", { cls: "custom-replacement-setting" });
        rowEl.style.display = "flex";
        rowEl.style.alignItems = "center";
        rowEl.style.padding = "8px 0";
        rowEl.style.borderBottom = "1px solid var(--background-modifier-border)";
        const individualToggleSetting = new import_obsidian.Setting(document.createElement("div"));
        individualToggleSetting.addToggle((toggle) => {
          toggle.setValue(replacement.enabled).onChange(async (value) => {
            this.plugin.settings.customReplacements[index].enabled = value;
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          rowEl.appendChild(toggle.toggleEl);
        });
        const input1 = rowEl.createEl("input", { type: "text" });
        input1.placeholder = "Text to replace";
        input1.value = replacement.searchText;
        input1.style.width = "30%";
        input1.style.marginLeft = "8px";
        input1.addEventListener("input", async (e) => {
          this.plugin.settings.customReplacements[index].searchText = e.target.value;
          await this.plugin.saveSettings();
        });
        const input2 = rowEl.createEl("input", { type: "text" });
        input2.placeholder = "Replace with";
        input2.value = replacement.replaceText;
        input2.style.width = "30%";
        input2.style.marginLeft = "8px";
        input2.addEventListener("input", async (e) => {
          this.plugin.settings.customReplacements[index].replaceText = e.target.value;
          await this.plugin.saveSettings();
        });
        const toggleSetting = new import_obsidian.Setting(document.createElement("div"));
        toggleSetting.addToggle((toggle) => {
          toggle.setValue(replacement.onlyAtStart).onChange(async (value) => {
            this.plugin.settings.customReplacements[index].onlyAtStart = value;
            await this.plugin.saveSettings();
          });
          const toggleEl = toggle.toggleEl;
          toggleEl.style.margin = "0";
          toggleEl.style.marginLeft = "8px";
          rowEl.appendChild(toggleEl);
        });
        const toggleLabel = rowEl.createEl("span", { text: "Match at line start only" });
        toggleLabel.style.fontSize = "0.9em";
        toggleLabel.style.whiteSpace = "nowrap";
        toggleLabel.style.marginLeft = "8px";
        const removeButton = rowEl.createEl("button", { text: "Remove" });
        removeButton.addClass("mod-warning");
        removeButton.style.marginLeft = "16px";
        removeButton.addEventListener("click", async () => {
          this.plugin.settings.customReplacements.splice(index, 1);
          await this.plugin.saveSettings();
          renderCustomReplacements();
        });
      });
      const addButtonSetting = new import_obsidian.Setting(this.containerEl).addButton(
        (button) => button.setButtonText("Add replacement").onClick(async () => {
          this.plugin.settings.customReplacements.push({
            searchText: "",
            replaceText: "",
            onlyAtStart: false,
            enabled: true
          });
          await this.plugin.saveSettings();
          renderCustomReplacements();
        })
      );
      addButtonSetting.settingEl.addClass("add-replacement-button");
      updateCustomReplacementUI();
    };
    renderCustomReplacements();
  }
};
