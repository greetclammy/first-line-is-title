/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FirstLineIsTitle
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var PLUGIN_STYLES = `
.flit-modal-heading {
    text-align: center;
}

.flit-modal-button-container {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 20px;
}

.flit-char-header-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.flit-char-header {
    margin: 0;
}

.flit-char-settings-container {
    display: block;
}

.flit-char-settings-container.hidden {
    display: none;
}

.flit-char-replacement-section-header {
    margin-bottom: 10px;
}

.flit-char-replacement-section-header.windows-android {
    margin-top: 20px;
    margin-bottom: 10px;
    padding-top: 15px;
    border-top: 2px solid var(--background-modifier-border);
    display: flex;
    align-items: center;
    gap: 10px;
}

.flit-section-title {
    margin: 0;
    font-size: 1.1em;
    font-weight: bold;
}

.flit-char-replacement-header, .flit-char-replacement-setting {
    display: flex;
    align-items: flex-start;
    padding: 8px 0;
    border-bottom: 1px solid var(--background-modifier-border);
    gap: 8px;
    width: fit-content;
    min-width: 750px;
}

.flit-char-replacement-header {
    border-bottom: 2px solid var(--background-modifier-border);
    font-weight: bold;
    font-size: 0.9em;
}

.flit-char-replacement-header.hidden {
    display: none;
}

.flit-char-replacement-setting:last-of-type {
    border-bottom: none;
}

.flit-char-replacement-setting.disabled {
    opacity: 0.5;
    pointer-events: none;
}

.flit-char-replacement-setting.hidden {
    display: none;
}

.flit-char-name-column {
    width: 320px;
    min-width: 320px;
    max-width: 320px;
    flex-shrink: 0;
    text-align: left;
    display: flex;
    flex-direction: column;
}

.flit-char-name-column .setting-item-name {
    margin-bottom: 2px;
}

.flit-char-name-column .setting-item-description {
    margin-top: 0;
    margin-bottom: 0;
    font-size: 0.85em;
    color: var(--text-muted);
}

.flit-char-text-input-container {
    width: 150px;
    min-width: 150px;
    max-width: 150px;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    gap: 4px;
}

.flit-char-text-input {
    width: 120px !important;
    min-width: 120px !important;
    max-width: 120px !important;
    flex: none !important;
    flex-grow: 0 !important;
    flex-shrink: 0 !important;
    box-sizing: border-box;
    overflow: hidden;
    text-overflow: ellipsis;
}

.flit-restore-icon {
    padding: 4px;
    background: transparent;
    border: none;
    cursor: pointer;
    color: var(--text-muted);
    display: flex;
    align-items: center;
}

.flit-restore-icon:hover {
    color: var(--text-normal);
}

.flit-custom-header-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.flit-custom-header {
    margin: 0;
}

.flit-table-container {
    overflow-x: auto;
    overflow-y: hidden;
    width: 100%;
    margin-bottom: 10px;
}

.flit-table-wrapper {
    width: fit-content;
    min-width: 100%;
}

.flit-custom-replacement-header, .flit-safeword-header {
    display: flex;
    align-items: center;
    padding: 8px 0;
    border-bottom: 2px solid var(--background-modifier-border);
    font-weight: bold;
    font-size: 0.9em;
    gap: 8px;
    width: fit-content;
    min-width: 750px;
}

.flit-custom-replacement-header .flit-toggle-column:first-of-type,
.flit-safeword-header .flit-toggle-column:first-of-type {
    margin-right: -5px;
}

.flit-custom-replacement-header .flit-toggle-column:last-of-type,
.flit-safeword-header .flit-toggle-column:last-of-type {
    margin-right: -5px;
}

.flit-custom-replacement-header.hidden, .flit-safeword-header.hidden {
    display: none;
}

.flit-custom-replacement-setting, .flit-safeword-setting {
    display: flex;
    align-items: flex-start;
    padding: 8px 0;
    border-bottom: 1px solid var(--background-modifier-border);
    gap: 8px;
    width: fit-content;
    min-width: 750px;
}

.flit-custom-replacement-setting .flit-toggle-column:first-of-type,
.flit-safeword-setting .flit-toggle-column:first-of-type {
    margin-right: -5px;
}

.flit-custom-replacement-setting .flit-toggle-column:last-of-type,
.flit-safeword-setting .flit-toggle-column:last-of-type {
    margin-right: -5px;
}

.flit-custom-replacement-setting:last-of-type, .flit-safeword-setting:last-of-type {
    border-bottom: none;
}

.flit-custom-replacement-setting.hidden, .flit-safeword-setting.hidden {
    display: none;
}

.flit-enable-column {
    width: 60px;
    min-width: 60px;
    max-width: 60px;
    flex-shrink: 0;
    text-align: left;
}

.flit-text-column {
    width: 200px;
    min-width: 200px;
    max-width: 200px;
    flex-shrink: 0;
    text-align: left;
    overflow: hidden;
}

.flit-text-column.flit-safeword-input {
    width: 408px;
    min-width: 408px;
    max-width: 408px;
}

.flit-text-column input {
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
    overflow: hidden;
    text-overflow: ellipsis;
}

.flit-toggle-column {
    width: 85px;
    min-width: 85px;
    max-width: 85px;
    flex-shrink: 0;
    text-align: left;
    line-height: 1.2;
}

.flit-toggle-column.center {
    display: flex;
    justify-content: left;
}

.flit-actions-column {
    width: 80px;
    min-width: 80px;
    max-width: 80px;
    flex-shrink: 0;
}

.flit-button-container {
    display: flex;
    gap: 4px;
    align-items: center;
}

.flit-nav-button {
    padding: 4px;
    background: transparent;
    border: none;
    cursor: pointer;
}

.flit-nav-button.disabled {
    cursor: not-allowed;
    opacity: 0.5;
}

.flit-delete-button {
    padding: 4px;
    background: transparent;
    border: none;
    cursor: pointer;
    color: var(--text-error);
}

.flit-desc-disabled {
    opacity: 0.5;
}

.flit-add-replacement-button.hidden, .flit-add-safeword-button.hidden {
    display: none;
}
`;
var DEFAULT_SETTINGS = {
  excludedFolders: [],
  charCount: 100,
  checkInterval: 600,
  disableRenamingKey: "rename",
  disableRenamingValue: "off",
  osPreset: "macOS",
  charReplacements: {
    slash: " \u2215 ",
    colon: "\u0589",
    asterisk: "\u2217",
    question: "\uFE56",
    lessThan: "\u2039",
    greaterThan: "\u203A",
    quote: "\uFF02",
    pipe: "\u2758",
    hash: "\uFF03",
    leftBracket: "\uFF3B",
    rightBracket: "\uFF3D",
    caret: "\u02C6",
    backslash: "\u29F5",
    dot: "\u2024"
  },
  charReplacementEnabled: {
    slash: false,
    colon: false,
    asterisk: false,
    question: false,
    lessThan: false,
    greaterThan: false,
    quote: false,
    pipe: false,
    hash: false,
    leftBracket: false,
    rightBracket: false,
    caret: false,
    backslash: false,
    dot: false
  },
  charReplacementTrimLeft: {
    slash: false,
    colon: false,
    asterisk: false,
    question: false,
    lessThan: false,
    greaterThan: false,
    quote: false,
    pipe: false,
    hash: false,
    leftBracket: true,
    rightBracket: true,
    caret: false,
    backslash: false,
    dot: false
  },
  charReplacementTrimRight: {
    slash: false,
    colon: false,
    asterisk: false,
    question: false,
    lessThan: false,
    greaterThan: false,
    quote: false,
    pipe: false,
    hash: false,
    leftBracket: true,
    rightBracket: true,
    caret: false,
    backslash: false,
    dot: false
  },
  customReplacements: [
    { searchText: "- [ ] ", replaceText: "\u2714\uFE0F ", onlyAtStart: true, onlyWholeLine: false, enabled: true },
    { searchText: "- [x] ", replaceText: "\u2705 ", onlyAtStart: true, onlyWholeLine: false, enabled: true }
  ],
  safewords: [
    { text: "Title", onlyAtStart: false, onlyWholeLine: false, enabled: false }
  ],
  omitHtmlTags: false,
  enableForbiddenCharReplacements: false,
  enableCustomReplacements: false,
  enableSafewords: false,
  renameOnFocus: false,
  renameAutomatically: true,
  manualNotificationMode: "On title change",
  windowsAndroidEnabled: false,
  hasEnabledForbiddenChars: false,
  hasEnabledWindowsAndroid: false,
  hasEnabledSafewords: false,
  skipExcalidrawFiles: false,
  grabTitleFromCardLink: false,
  excludeSubfolders: true
};
var UNIVERSAL_FORBIDDEN_CHARS = ["/", ":", "|", String.fromCharCode(92), "#", "[", "]", "^"];
var WINDOWS_ANDROID_CHARS = ["*", "?", "<", ">", '"'];
var OS_FORBIDDEN_CHARS = {
  "macOS": UNIVERSAL_FORBIDDEN_CHARS,
  "Windows": [...UNIVERSAL_FORBIDDEN_CHARS, ...WINDOWS_ANDROID_CHARS],
  "Linux": UNIVERSAL_FORBIDDEN_CHARS
};
var renamedFileCount = 0;
var tempNewPaths = [];
var onTimeout = true;
var timeout;
var previousFile;
var previousContent = /* @__PURE__ */ new Map();
function detectOS() {
  if (typeof process === "undefined" || !process.platform) {
    const userAgent = navigator.userAgent.toLowerCase();
    if (userAgent.includes("android")) {
      return "Linux";
    } else if (userAgent.includes("iphone") || userAgent.includes("ipad")) {
      return "macOS";
    }
    return "Linux";
  }
  switch (process.platform) {
    case "darwin":
      return "macOS";
    case "win32":
      return "Windows";
    default:
      return "Linux";
  }
}
function inExcludedFolder(file, settings) {
  var _a;
  if (settings.excludedFolders.length === 0) return false;
  const filePath = (_a = file.parent) == null ? void 0 : _a.path;
  if (settings.excludedFolders.includes(filePath)) {
    return true;
  }
  if (settings.excludeSubfolders) {
    for (const excludedFolder of settings.excludedFolders) {
      if (filePath && filePath.startsWith(excludedFolder + "/")) {
        return true;
      }
    }
  }
  return false;
}
function hasDisableProperty(content, settings) {
  if (!settings.disableRenamingKey || !settings.disableRenamingValue) return false;
  if (!content.startsWith("---")) return false;
  const frontmatterEnd = content.indexOf("---", 3);
  if (frontmatterEnd === -1) return false;
  const frontmatter = content.slice(3, frontmatterEnd);
  const escapedKey = settings.disableRenamingKey.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const escapedValue = settings.disableRenamingValue.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const disableRegex = new RegExp(`^\\s*${escapedKey}\\s*:\\s*${escapedValue}\\s*$`, "im");
  return disableRegex.test(frontmatter);
}
function isExcalidrawFile(content, settings) {
  if (!settings.skipExcalidrawFiles) return false;
  if (!content.startsWith("---")) return false;
  const frontmatterEnd = content.indexOf("---", 3);
  if (frontmatterEnd === -1) return false;
  const frontmatter = content.slice(3, frontmatterEnd);
  const excalidrawRegex = /^\s*excalidraw-plugin\s*:\s*parsed\s*$/m;
  return excalidrawRegex.test(frontmatter);
}
function containsSafeword(filename, settings) {
  if (!settings.enableSafewords) return false;
  for (const safeword of settings.safewords) {
    if (!safeword.enabled || !safeword.text) continue;
    if (safeword.onlyWholeLine) {
      if (filename.trim() === safeword.text.trim()) {
        return true;
      }
    } else if (safeword.onlyAtStart) {
      if (filename.startsWith(safeword.text)) {
        return true;
      }
    } else {
      if (filename.includes(safeword.text)) {
        return true;
      }
    }
  }
  return false;
}
function extractTitle(line, settings) {
  const originalLine = line;
  line = line.trim();
  line = line.replace(/<%\s*tp\.file\.cursor\(\)\s*%>/, "").trim();
  if (line === "<%*") {
    return "Untitled";
  }
  const isValidHeading = /^#{1,6}\s/.test(line);
  const escapeMap = /* @__PURE__ */ new Map();
  let escapeCounter = 0;
  const backslashReplacementEnabled = settings.enableForbiddenCharReplacements && settings.charReplacementEnabled.backslash;
  if (!backslashReplacementEnabled) {
    line = line.replace(/\\(.)/g, (match, char) => {
      const placeholder = `__ESCAPED_${escapeCounter++}__`;
      escapeMap.set(placeholder, char);
      return placeholder;
    });
  }
  line = line.replace(/%%.*?%%/g, (match) => {
    return match.slice(2, -2);
  });
  if (settings.omitHtmlTags) {
    let previousLine = "";
    while (line !== previousLine) {
      previousLine = line;
      line = line.replace(/<([a-zA-Z][a-zA-Z0-9]*)\b[^>]*>(.*?)<\/\1>/g, "$2");
    }
  }
  const embedLinkRegex = /!\[\[(.*?)\]\]/g;
  line = line.replace(embedLinkRegex, "[[$1]]");
  const regularEmbedRegex = /!\[(.*?)\]\((.*?)\)/g;
  line = line.replace(regularEmbedRegex, (match, caption) => caption);
  if (isValidHeading) {
    const headerArr = [
      "# ",
      "## ",
      "### ",
      "#### ",
      "##### ",
      "###### "
    ];
    for (let i = 0; i < headerArr.length; i++) {
      if (line.startsWith(headerArr[i])) {
        line = line.slice(headerArr[i].length).trim();
        break;
      }
    }
  }
  if (settings.enableCustomReplacements) {
    for (const replacement of settings.customReplacements) {
      if (replacement.searchText === "" || !replacement.enabled) continue;
      let tempLine = line;
      if (replacement.onlyWholeLine) {
        if (line.trim() === replacement.searchText.trim()) {
          tempLine = replacement.replaceText;
        }
      } else if (replacement.onlyAtStart) {
        if (tempLine.startsWith(replacement.searchText)) {
          tempLine = replacement.replaceText + tempLine.slice(replacement.searchText.length);
        }
      } else {
        tempLine = tempLine.replaceAll(replacement.searchText, replacement.replaceText);
      }
      if (tempLine.trim() === "" && line.trim() === replacement.searchText.trim()) {
        return "Untitled";
      }
      line = tempLine;
    }
  }
  while (line.includes("[[") && line.includes("]]")) {
    const openBracket = line.indexOf("[[");
    const closeBracket = line.indexOf("]]", openBracket);
    if (openBracket === -1 || closeBracket === -1) break;
    const linkText = line.slice(openBracket + 2, closeBracket);
    const beforeLink = line.slice(0, openBracket);
    const afterLink = line.slice(closeBracket + 2);
    const pipeIndex = linkText.indexOf("|");
    const resolvedText = pipeIndex !== -1 ? linkText.slice(pipeIndex + 1) : linkText;
    line = (beforeLink + resolvedText + afterLink).trim();
  }
  const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
  line = line.replace(markdownLinkRegex, (_, title) => title);
  if (!backslashReplacementEnabled) {
    for (const [placeholder, char] of escapeMap) {
      line = line.replace(placeholder, char);
    }
  }
  return line;
}
var RenameAllFilesModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const heading = contentEl.createEl("h2", { text: "Warning", cls: "flit-modal-heading" });
    contentEl.createEl("p", {
      text: "This will edit all of your files except those in excluded folders, and may introduce errors. Make sure you have backed up your files."
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container flit-modal-button-container" });
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => this.close();
    const renameButton = buttonContainer.createEl("button", { text: "Rename all files" });
    renameButton.addClass("mod-cta");
    renameButton.onclick = async () => {
      this.close();
      await this.renameAllFiles();
    };
  }
  async renameAllFiles() {
    let filesToRename = [];
    this.app.vault.getMarkdownFiles().forEach((file) => {
      if (!inExcludedFolder(file, this.plugin.settings)) {
        filesToRename.push(file);
      }
    });
    renamedFileCount = 0;
    tempNewPaths = [];
    const pleaseWaitNotice = new import_obsidian.Notice(`Renaming files, please wait...`, 0);
    try {
      const errors = [];
      for (const file of filesToRename) {
        try {
          await this.plugin.renameFile(file, true);
        } catch (error) {
          errors.push(`Failed to rename ${file.path}: ${error}`);
        }
      }
      if (errors.length > 0) {
        new import_obsidian.Notice(`Completed with ${errors.length} errors. Check console for details.`, 5e3);
        console.error("Rename errors:", errors);
      }
    } finally {
      pleaseWaitNotice.hide();
      new import_obsidian.Notice(
        `Renamed ${renamedFileCount}/${filesToRename.length} files.`,
        5e3
      );
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var FirstLineIsTitle = class extends import_obsidian.Plugin {
  cleanupStaleCache() {
    tempNewPaths = tempNewPaths.filter((path) => {
      return this.app.vault.getAbstractFileByPath(path) !== null;
    });
    for (const [path, content] of previousContent) {
      if (!this.app.vault.getAbstractFileByPath(path)) {
        previousContent.delete(path);
      }
    }
  }
  async renameFile(file, noDelay = false, ignoreExclusions = false) {
    var _a, _b, _c, _d;
    if (!ignoreExclusions && inExcludedFolder(file, this.settings)) return;
    if (file.extension !== "md") return;
    if (noDelay === false) {
      if (onTimeout) {
        if (previousFile == file.path) {
          clearTimeout(timeout);
        }
        previousFile = file.path;
        timeout = setTimeout(() => {
          onTimeout = false;
          this.renameFile(file);
        }, this.settings.checkInterval);
        return;
      }
      onTimeout = true;
    } else {
      if (!tempNewPaths.length || tempNewPaths.length < 10) {
        tempNewPaths = [];
      }
    }
    this.cleanupStaleCache();
    let content;
    try {
      content = await this.app.vault.cachedRead(file);
    } catch (error) {
      console.error(`Failed to read file ${file.path}:`, error);
      throw new Error(`Failed to read file: ${error.message}`);
    }
    if (!ignoreExclusions && hasDisableProperty(content, this.settings)) {
      return;
    }
    if (!ignoreExclusions && isExcalidrawFile(content, this.settings)) {
      return;
    }
    if (!ignoreExclusions && containsSafeword(file.name, this.settings)) {
      return;
    }
    if (content.startsWith("---")) {
      let index = content.indexOf("---", 3);
      if (index != -1) content = content.slice(index + 3).trimStart();
    }
    const currentName = file.basename;
    let firstLine = content.split("\n")[0];
    if (this.settings.grabTitleFromCardLink) {
      let embedMatch = content.match(/^embed\s*\n[\s\S]*?title:\s*"([^"]+)"/);
      if (!embedMatch) {
        embedMatch = content.match(/^```embed[^\n]*\n[\s\S]*?title:\s*"([^"]+)"/);
      }
      if (!embedMatch) {
        embedMatch = content.match(/^embed\s*\n[\s\S]*?title:\s*(.+?)(?:\n|$)/);
      }
      if (embedMatch) {
        firstLine = embedMatch[1];
      } else {
        let cardlinkMatch = content.match(/^cardlink\s*\n[\s\S]*?title:\s*"([^"]+)"/);
        if (!cardlinkMatch) {
          cardlinkMatch = content.match(/^```cardlink[^\n]*\n[\s\S]*?title:\s*"([^"]+)"/);
        }
        if (cardlinkMatch) {
          firstLine = cardlinkMatch[1];
        }
      }
    }
    const previousFileContent = previousContent.get(file.path);
    if (content.trim() === "" && previousFileContent && previousFileContent.trim() !== "") {
      const parentPath2 = ((_a = file.parent) == null ? void 0 : _a.path) === "/" ? "" : ((_b = file.parent) == null ? void 0 : _b.path) + "/";
      let newPath2 = `${parentPath2}Untitled.md`;
      let counter2 = 0;
      let fileExists2 = this.app.vault.getAbstractFileByPath(newPath2) != null;
      while (fileExists2 || tempNewPaths.includes(newPath2)) {
        if (file.path == newPath2) {
          previousContent.set(file.path, content);
          return;
        }
        counter2 += 1;
        newPath2 = `${parentPath2}Untitled ${counter2}.md`;
        fileExists2 = this.app.vault.getAbstractFileByPath(newPath2) != null;
      }
      if (noDelay) {
        tempNewPaths.push(newPath2);
      }
      try {
        await this.app.fileManager.renameFile(file, newPath2);
        renamedFileCount += 1;
      } catch (error) {
        console.error(`Failed to rename file ${file.path} to ${newPath2}:`, error);
        throw new Error(`Failed to rename file: ${error.message}`);
      }
      previousContent.set(file.path, content);
      return;
    }
    previousContent.set(file.path, content);
    if (firstLine === "") {
      return;
    }
    const escapedName = currentName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const wikiLinkRegex = new RegExp(`\\[\\[${escapedName}(\\|.*?)?\\]\\]`);
    const internalMarkdownLinkRegex = new RegExp(`\\(\\#${escapedName}\\)`, "i");
    const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
    let isSelfReferencing = false;
    if (wikiLinkRegex.test(firstLine)) {
      isSelfReferencing = true;
    }
    let match;
    while ((match = markdownLinkRegex.exec(firstLine)) !== null) {
      const url = match[2];
      if (url.startsWith("#") && url.includes(currentName)) {
        isSelfReferencing = true;
        break;
      }
    }
    if (isSelfReferencing) {
      new import_obsidian.Notice("File not renamed - first line references current filename", 0);
      return;
    }
    content = extractTitle(firstLine, this.settings);
    const charMap = {
      "/": this.settings.charReplacements.slash,
      ":": this.settings.charReplacements.colon,
      "|": this.settings.charReplacements.pipe,
      "#": this.settings.charReplacements.hash,
      "[": this.settings.charReplacements.leftBracket,
      "]": this.settings.charReplacements.rightBracket,
      "^": this.settings.charReplacements.caret,
      "*": this.settings.charReplacements.asterisk,
      "?": this.settings.charReplacements.question,
      "<": this.settings.charReplacements.lessThan,
      ">": this.settings.charReplacements.greaterThan,
      '"': this.settings.charReplacements.quote,
      [String.fromCharCode(92)]: this.settings.charReplacements.backslash,
      ".": this.settings.charReplacements.dot
    };
    const universalForbiddenChars = UNIVERSAL_FORBIDDEN_CHARS;
    const windowsAndroidChars = WINDOWS_ANDROID_CHARS;
    const allForbiddenChars = [...universalForbiddenChars];
    if (this.settings.windowsAndroidEnabled) {
      allForbiddenChars.push(...windowsAndroidChars);
    }
    const forbiddenChars = [...new Set(allForbiddenChars)].join("");
    const forbiddenNames = [
      "CON",
      "PRN",
      "AUX",
      "NUL",
      "COM1",
      "COM2",
      "COM3",
      "COM4",
      "COM5",
      "COM6",
      "COM7",
      "COM8",
      "COM9",
      "COM0",
      "LPT1",
      "LPT2",
      "LPT3",
      "LPT4",
      "LPT5",
      "LPT6",
      "LPT7",
      "LPT8",
      "LPT9",
      "LPT0"
    ];
    let newFileName = "";
    for (let i = 0; i < content.length; i++) {
      if (newFileName.length >= this.settings.charCount - 1) {
        newFileName = newFileName.trimEnd();
        newFileName += "\u2026";
        break;
      }
      let char = content[i];
      if (forbiddenChars.includes(char)) {
        let shouldReplace = false;
        let replacement = "";
        if (this.settings.enableForbiddenCharReplacements) {
          let settingKey = null;
          switch (char) {
            case "/":
              settingKey = "slash";
              break;
            case String.fromCharCode(92):
              settingKey = "backslash";
              break;
            case ":":
              settingKey = "colon";
              break;
            case "|":
              settingKey = "pipe";
              break;
            case "#":
              settingKey = "hash";
              break;
            case "[":
              settingKey = "leftBracket";
              break;
            case "]":
              settingKey = "rightBracket";
              break;
            case "^":
              settingKey = "caret";
              break;
            case "*":
              settingKey = "asterisk";
              break;
            case "?":
              settingKey = "question";
              break;
            case "<":
              settingKey = "lessThan";
              break;
            case ">":
              settingKey = "greaterThan";
              break;
            case '"':
              settingKey = "quote";
              break;
            case ".":
              settingKey = "dot";
              break;
          }
          const isWindowsAndroidChar = ["*", "?", "<", ">", '"'].includes(char);
          const canReplace = isWindowsAndroidChar ? this.settings.windowsAndroidEnabled && settingKey && this.settings.charReplacementEnabled[settingKey] : settingKey && this.settings.charReplacementEnabled[settingKey];
          if (canReplace && settingKey) {
            shouldReplace = true;
            replacement = charMap[char] || "";
            if (replacement !== "") {
              if (this.settings.charReplacementTrimLeft[settingKey]) {
                newFileName = newFileName.trimEnd();
              }
              if (this.settings.charReplacementTrimRight[settingKey]) {
                while (i + 1 < content.length && /\s/.test(content[i + 1])) {
                  i++;
                }
              }
            }
          }
        }
        if (shouldReplace && replacement !== "") {
          newFileName += replacement;
        }
      } else {
        newFileName += char;
      }
    }
    newFileName = newFileName.trim().replace(/\s+/g, " ");
    while (newFileName[0] == ".") {
      newFileName = newFileName.slice(1);
    }
    const isForbiddenName = newFileName === "" || forbiddenNames.includes(newFileName.toUpperCase());
    if (isForbiddenName) newFileName = "Untitled";
    const parentPath = ((_c = file.parent) == null ? void 0 : _c.path) === "/" ? "" : ((_d = file.parent) == null ? void 0 : _d.path) + "/";
    let newPath = `${parentPath}${newFileName}.md`;
    let counter = 0;
    let fileExists = this.app.vault.getAbstractFileByPath(newPath) != null;
    while (fileExists || tempNewPaths.includes(newPath)) {
      if (file.path == newPath) return;
      counter += 1;
      newPath = `${parentPath}${newFileName} ${counter}.md`;
      fileExists = this.app.vault.getAbstractFileByPath(newPath) != null;
    }
    if (noDelay) {
      tempNewPaths.push(newPath);
    }
    try {
      await this.app.fileManager.renameFile(file, newPath);
      renamedFileCount += 1;
    } catch (error) {
      console.error(`Failed to rename file ${file.path} to ${newPath}:`, error);
      throw new Error(`Failed to rename file: ${error.message}`);
    }
  }
  async onload() {
    await this.loadSettings();
    this.settings.osPreset = detectOS();
    await this.saveSettings();
    const styleEl = document.createElement("style");
    styleEl.textContent = PLUGIN_STYLES;
    document.head.appendChild(styleEl);
    this.addSettingTab(new FirstLineIsTitleSettings(this.app, this));
    this.addCommand({
      id: "rename-current-file-unless-excluded",
      name: "Rename current file unless excluded",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && activeFile.extension === "md") {
          await this.renameFile(activeFile, true, false);
        }
      }
    });
    this.addCommand({
      id: "rename-current-file",
      name: "Rename current file",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && activeFile.extension === "md") {
          await this.renameFile(activeFile, true, true);
        }
      }
    });
    this.addCommand({
      id: "rename-all-files",
      name: "Rename all files",
      callback: () => {
        new RenameAllFilesModal(this.app, this).open();
      }
    });
    this.registerEvent(
      this.app.vault.on("modify", (abstractFile) => {
        if (abstractFile instanceof import_obsidian.TFile && abstractFile.extension === "md") {
          const noDelay = this.settings.checkInterval === 0;
          this.renameFile(abstractFile, noDelay);
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if (this.settings.renameOnFocus && leaf && leaf.view && leaf.view.file && leaf.view.file instanceof import_obsidian.TFile && leaf.view.file.extension === "md") {
          this.renameFile(leaf.view.file, true);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (abstractFile) => {
        if (abstractFile instanceof import_obsidian.TFile) {
          const index = tempNewPaths.indexOf(abstractFile.path);
          if (index > -1) {
            tempNewPaths.splice(index, 1);
          }
          previousContent.delete(abstractFile.path);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (abstractFile, oldPath) => {
        if (abstractFile instanceof import_obsidian.TFile) {
          const index = tempNewPaths.indexOf(oldPath);
          if (index > -1) {
            tempNewPaths[index] = abstractFile.path;
          }
          const oldContent = previousContent.get(oldPath);
          if (oldContent !== void 0) {
            previousContent.delete(oldPath);
            previousContent.set(abstractFile.path, oldContent);
          }
        }
      })
    );
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var FirstLineIsTitleSettings = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    this.containerEl.empty();
    new import_obsidian.Setting(this.containerEl).setName("Rename automatically").setDesc("Renames files automatically when the first line changes. If disabled, files will only be renamed when invoking a command manually.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.renameAutomatically).onChange(async (value) => {
        this.plugin.settings.renameAutomatically = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(this.containerEl).setName("Exclude folders").setDesc(
      "Folder paths to exclude from auto-renaming. Separate by newline. Case-sensitive."
    ).addTextArea((text) => {
      text.setPlaceholder("/\nfolder\nfolder/subfolder").setValue(this.plugin.settings.excludedFolders.join("\n")).onChange(async (value) => {
        this.plugin.settings.excludedFolders = value.split("\n");
        await this.plugin.saveSettings();
      });
      text.inputEl.cols = 28;
      text.inputEl.rows = 4;
    });
    new import_obsidian.Setting(this.containerEl).setName("Exclude subfolders").setDesc("Exclude all subfolders of excluded folders.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.excludeSubfolders).onChange(async (value) => {
        this.plugin.settings.excludeSubfolders = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(this.containerEl).setName("Character count").setDesc("The maximum number of characters to put in title. Can't exceed 255 characters. Default: 100.").addText(
      (text) => text.setPlaceholder("100").setValue(String(this.plugin.settings.charCount)).onChange(async (value) => {
        if (value === "") {
          this.plugin.settings.charCount = DEFAULT_SETTINGS.charCount;
        } else {
          const numVal = Number(value);
          if (numVal >= 1 && numVal <= 255) {
            this.plugin.settings.charCount = numVal;
          }
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(this.containerEl).setName("Check interval").setDesc("Interval in milliseconds of how often to rename files while editing. Increase in case of issues. Default: 600.").addText(
      (text) => text.setPlaceholder("500").setValue(String(this.plugin.settings.checkInterval)).onChange(async (value) => {
        if (value === "") {
          this.plugin.settings.checkInterval = DEFAULT_SETTINGS.checkInterval;
        } else if (!isNaN(Number(value))) {
          this.plugin.settings.checkInterval = Number(value);
        }
        await this.plugin.saveSettings();
      })
    );
    const propertyDisableSetting = new import_obsidian.Setting(this.containerEl).setName("Property to disable renaming").setDesc("Define the key:property pair that will disable renaming for files that contain it. Case insensitive.");
    const propertyContainer = propertyDisableSetting.controlEl.createDiv({ cls: "flit-property-disable-container" });
    propertyContainer.style.display = "flex";
    propertyContainer.style.gap = "10px";
    const keyInput = propertyContainer.createEl("input", { type: "text" });
    keyInput.placeholder = "key";
    keyInput.style.width = "120px";
    keyInput.value = this.plugin.settings.disableRenamingKey;
    keyInput.addEventListener("input", async (e) => {
      this.plugin.settings.disableRenamingKey = e.target.value;
      await this.plugin.saveSettings();
    });
    const valueInput = propertyContainer.createEl("input", { type: "text" });
    valueInput.placeholder = "value";
    valueInput.style.width = "120px";
    valueInput.value = this.plugin.settings.disableRenamingValue;
    valueInput.addEventListener("input", async (e) => {
      this.plugin.settings.disableRenamingValue = e.target.value;
      await this.plugin.saveSettings();
    });
    new import_obsidian.Setting(this.containerEl).setName("Omit HTML tags").setDesc("Don't put HTML tags like <u> in title.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.omitHtmlTags).onChange(async (value) => {
        this.plugin.settings.omitHtmlTags = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(this.containerEl).setName("Rename on focus").setDesc("Automatically rename files when they become focused/active.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.renameOnFocus).onChange(async (value) => {
        this.plugin.settings.renameOnFocus = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(this.containerEl).setName("Show notification when renaming manually").setDesc("Controls when to show notifications for the 'Rename current file' command.").addDropdown(
      (dropdown) => dropdown.addOption("Always", "Always").addOption("On title change", "On title change").addOption("Never", "Never").setValue(this.plugin.settings.manualNotificationMode).onChange(async (value) => {
        this.plugin.settings.manualNotificationMode = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(this.containerEl).setName("Rename all files").setDesc("Rename all files except those in excluded folders. Can also be run from the Command palette.").addButton(
      (button) => button.setButtonText("Rename").onClick(() => {
        new RenameAllFilesModal(this.app, this.plugin).open();
      })
    );
    this.containerEl.createEl("br");
    this.containerEl.createEl("h6", { text: "Compatibility with other plugins" });
    new import_obsidian.Setting(this.containerEl).setName("Don't rename Excalidraw files").setDesc("Files that have the property `excalidraw-plugin: parsed` won't be renamed.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.skipExcalidrawFiles).onChange(async (value) => {
        this.plugin.settings.skipExcalidrawFiles = value;
        await this.plugin.saveSettings();
      })
    );
    const cardLinkSetting = new import_obsidian.Setting(this.containerEl).setName("Grab title from card link");
    const cardLinkDesc = cardLinkSetting.descEl;
    cardLinkDesc.appendText("If a note starts with a card link created with ");
    cardLinkDesc.createEl("em", { text: "Link Embed" });
    cardLinkDesc.appendText(" or ");
    cardLinkDesc.createEl("em", { text: "Auto Card Link" });
    cardLinkDesc.appendText(", the card link title will be put it in filename.");
    cardLinkSetting.addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.grabTitleFromCardLink).onChange(async (value) => {
        this.plugin.settings.grabTitleFromCardLink = value;
        await this.plugin.saveSettings();
      })
    );
    this.containerEl.createEl("br");
    const charHeaderContainer = this.containerEl.createEl("div", { cls: "setting-item flit-char-header-container" });
    const charHeader = charHeaderContainer.createEl("h3", { text: "Forbidden character replacements", cls: "flit-char-header" });
    const headerToggleSetting = new import_obsidian.Setting(document.createElement("div"));
    headerToggleSetting.addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableForbiddenCharReplacements).onChange(async (value) => {
        this.plugin.settings.enableForbiddenCharReplacements = value;
        if (value && !this.plugin.settings.hasEnabledForbiddenChars) {
          const allOSesKeys = ["leftBracket", "rightBracket", "hash", "caret", "pipe", "backslash", "slash", "colon", "dot"];
          allOSesKeys.forEach((key) => {
            this.plugin.settings.charReplacementEnabled[key] = true;
          });
          this.plugin.settings.hasEnabledForbiddenChars = true;
          const currentOS = detectOS();
          if ((currentOS === "Windows" || currentOS === "Linux") && !this.plugin.settings.hasEnabledWindowsAndroid) {
            this.plugin.settings.windowsAndroidEnabled = true;
            const windowsAndroidKeys = ["asterisk", "quote", "lessThan", "greaterThan", "question"];
            windowsAndroidKeys.forEach((key) => {
              this.plugin.settings.charReplacementEnabled[key] = true;
            });
            this.plugin.settings.hasEnabledWindowsAndroid = true;
          }
        }
        await this.plugin.saveSettings();
        updateCharacterSettings();
        updateCharacterReplacementUI();
      });
      charHeaderContainer.appendChild(toggle.toggleEl);
    });
    const charDescEl = this.containerEl.createEl("div", { cls: "setting-item-description" });
    const updateCharDescriptionContent = () => {
      const isEnabled = this.plugin.settings.enableForbiddenCharReplacements;
      if (isEnabled) {
        charDescEl.setText("Define replacements for forbidden filename characters. Characters are omitted entirely if disabled.");
      } else {
        charDescEl.setText("Define replacements for forbidden filename characters. Characters are omitted entirely if disabled.");
      }
    };
    updateCharDescriptionContent();
    this.containerEl.createEl("br");
    const charSettingsContainer = this.containerEl.createDiv({ cls: "flit-char-settings-container" });
    const updateCharacterReplacementUI = () => {
      const isEnabled = this.plugin.settings.enableForbiddenCharReplacements;
      if (isEnabled) {
        charDescEl.classList.remove("flit-desc-disabled");
      } else {
        charDescEl.classList.add("flit-desc-disabled");
      }
      updateCharDescriptionContent();
      if (isEnabled) {
        charSettingsContainer.classList.remove("hidden");
      } else {
        charSettingsContainer.classList.add("hidden");
      }
    };
    const updateCharacterSettings = () => {
      charSettingsContainer.empty();
      const primaryCharSettings = [
        { key: "leftBracket", name: "Left bracket [", char: "[" },
        { key: "rightBracket", name: "Right bracket ]", char: "]" },
        { key: "hash", name: "Hash #", char: "#" },
        { key: "caret", name: "Caret ^", char: "^" },
        { key: "pipe", name: "Pipe |", char: "|" },
        { key: "backslash", name: "Backslash \\", char: String.fromCharCode(92), description: "Note: replacing the backslash disables its use as an escape character for overriding the omission of markdown syntax and HTML tags (if enabled)." },
        { key: "slash", name: "Forward slash /", char: "/" },
        { key: "colon", name: "Colon :", char: ":" },
        { key: "dot", name: "Dot .", char: ".", description: "Note: the dot is only forbidden at filename start." }
      ];
      const windowsAndroidChars = [
        { key: "asterisk", name: "Asterisk *", char: "*" },
        { key: "quote", name: 'Quote "', char: '"' },
        { key: "lessThan", name: "Less than <", char: "<" },
        { key: "greaterThan", name: "Greater than >", char: ">" },
        { key: "question", name: "Question mark ?", char: "?" }
      ];
      const allOSesHeader = charSettingsContainer.createEl("div", { cls: "flit-char-replacement-section-header" });
      const allOSesTitle = allOSesHeader.createEl("h3", { text: "All OSes", cls: "flit-section-title" });
      const allOSesDescContainer = charSettingsContainer.createEl("div");
      const allOSesDesc = allOSesDescContainer.createEl("div", {
        text: "The following characters are forbidden in Obsidian filenames on all OSes.",
        cls: "setting-item-description"
      });
      allOSesDesc.style.marginBottom = "10px";
      const allOSesTableContainer = charSettingsContainer.createEl("div", { cls: "flit-table-container" });
      const allOSesTableWrapper = allOSesTableContainer.createEl("div", { cls: "flit-table-wrapper" });
      const headerRow = allOSesTableWrapper.createEl("div", { cls: "flit-char-replacement-header" });
      const enableHeader = headerRow.createDiv({ cls: "flit-enable-column" });
      enableHeader.textContent = "Enable";
      const charHeader2 = headerRow.createDiv({ cls: "flit-char-name-column" });
      charHeader2.textContent = "Character";
      const replaceHeader = headerRow.createDiv({ cls: "flit-char-text-input-container" });
      replaceHeader.textContent = "Replace with";
      const trimLeftHeader = headerRow.createDiv({ cls: "flit-toggle-column" });
      const trimLeftLine1 = trimLeftHeader.createDiv();
      trimLeftLine1.textContent = "Trim";
      const trimLeftLine2 = trimLeftHeader.createDiv();
      trimLeftLine2.textContent = "whitespace";
      const trimLeftLine3 = trimLeftHeader.createDiv();
      trimLeftLine3.textContent = "to the left";
      const trimRightHeader = headerRow.createDiv({ cls: "flit-toggle-column" });
      const trimRightLine1 = trimRightHeader.createDiv();
      trimRightLine1.textContent = "Trim";
      const trimRightLine2 = trimRightHeader.createDiv();
      trimRightLine2.textContent = "whitespace";
      const trimRightLine3 = trimRightHeader.createDiv();
      trimRightLine3.textContent = "to the right";
      primaryCharSettings.forEach((setting, index) => {
        const rowEl = allOSesTableWrapper.createEl("div", { cls: "flit-char-replacement-setting" });
        const toggleContainer = rowEl.createDiv({ cls: "flit-enable-column" });
        const toggleSetting = new import_obsidian.Setting(document.createElement("div"));
        toggleSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.charReplacementEnabled[setting.key]).onChange(async (value) => {
            this.plugin.settings.charReplacementEnabled[setting.key] = value;
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          toggleContainer.appendChild(toggle.toggleEl);
        });
        const nameContainer = rowEl.createEl("div", { cls: "flit-char-name-column" });
        const nameEl = nameContainer.createEl("div", { text: setting.name, cls: "setting-item-name" });
        if (setting.description) {
          nameContainer.createEl("div", { text: setting.description, cls: "setting-item-description" });
        }
        const inputContainer = rowEl.createDiv({ cls: "flit-char-text-input-container" });
        const restoreButton = inputContainer.createEl("button", {
          cls: "clickable-icon flit-restore-icon",
          attr: { "aria-label": "Restore default" }
        });
        (0, import_obsidian.setIcon)(restoreButton, "rotate-ccw");
        restoreButton.addEventListener("click", async () => {
          this.plugin.settings.charReplacements[setting.key] = DEFAULT_SETTINGS.charReplacements[setting.key];
          textInput.value = DEFAULT_SETTINGS.charReplacements[setting.key];
          await this.plugin.saveSettings();
        });
        const textInput = inputContainer.createEl("input", { type: "text", cls: "flit-char-text-input" });
        textInput.placeholder = "Replace with";
        textInput.value = this.plugin.settings.charReplacements[setting.key];
        textInput.style.width = "120px";
        textInput.addEventListener("input", async (e) => {
          this.plugin.settings.charReplacements[setting.key] = e.target.value;
          await this.plugin.saveSettings();
        });
        const trimLeftContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const trimLeftSetting = new import_obsidian.Setting(document.createElement("div"));
        trimLeftSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.charReplacementTrimLeft[setting.key]).onChange(async (value) => {
            this.plugin.settings.charReplacementTrimLeft[setting.key] = value;
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          trimLeftContainer.appendChild(toggle.toggleEl);
        });
        const trimRightContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const trimRightSetting = new import_obsidian.Setting(document.createElement("div"));
        trimRightSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.charReplacementTrimRight[setting.key]).onChange(async (value) => {
            this.plugin.settings.charReplacementTrimRight[setting.key] = value;
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          trimRightContainer.appendChild(toggle.toggleEl);
        });
      });
      const windowsAndroidHeader = charSettingsContainer.createEl("div", { cls: "flit-char-replacement-section-header windows-android" });
      const sectionTitle = windowsAndroidHeader.createEl("h3", { text: "Windows/Android", cls: "flit-section-title" });
      const windowsAndroidToggleSetting = new import_obsidian.Setting(document.createElement("div"));
      windowsAndroidToggleSetting.addToggle((toggle) => {
        toggle.setValue(this.plugin.settings.windowsAndroidEnabled).onChange(async (value) => {
          this.plugin.settings.windowsAndroidEnabled = value;
          if (value && !this.plugin.settings.hasEnabledWindowsAndroid) {
            windowsAndroidChars.forEach((setting) => {
              this.plugin.settings.charReplacementEnabled[setting.key] = true;
            });
            this.plugin.settings.hasEnabledWindowsAndroid = true;
          }
          await this.plugin.saveSettings();
          updateCharacterSettings();
        });
        toggle.toggleEl.style.margin = "0";
        windowsAndroidHeader.appendChild(toggle.toggleEl);
      });
      const sectionDescContainer = charSettingsContainer.createEl("div");
      const sectionDesc = sectionDescContainer.createEl("div", {
        text: "The following characters are forbidden in Obsidian filenames on Windows and Android only.",
        cls: "setting-item-description"
      });
      sectionDesc.style.marginBottom = "10px";
      const winAndroidTableContainer = charSettingsContainer.createEl("div", { cls: "flit-table-container" });
      const winAndroidTableWrapper = winAndroidTableContainer.createEl("div", { cls: "flit-table-wrapper" });
      const winAndroidHeaderRow = winAndroidTableWrapper.createEl("div", { cls: "flit-char-replacement-header" });
      winAndroidHeaderRow.createDiv({ cls: "flit-enable-column" }).textContent = "Enable";
      winAndroidHeaderRow.createDiv({ cls: "flit-char-name-column" }).textContent = "Character";
      winAndroidHeaderRow.createDiv({ cls: "flit-char-text-input-container" }).textContent = "Replace with";
      const winTrimLeftHeader = winAndroidHeaderRow.createDiv({ cls: "flit-toggle-column" });
      winTrimLeftHeader.createDiv().textContent = "Trim";
      winTrimLeftHeader.createDiv().textContent = "whitespace";
      winTrimLeftHeader.createDiv().textContent = "to the left";
      const winTrimRightHeader = winAndroidHeaderRow.createDiv({ cls: "flit-toggle-column" });
      winTrimRightHeader.createDiv().textContent = "Trim";
      winTrimRightHeader.createDiv().textContent = "whitespace";
      winTrimRightHeader.createDiv().textContent = "to the right";
      windowsAndroidChars.forEach((setting, index) => {
        const rowEl = winAndroidTableWrapper.createEl("div", { cls: "flit-char-replacement-setting" });
        const isDisabled = !this.plugin.settings.windowsAndroidEnabled;
        if (isDisabled) {
          rowEl.classList.add("disabled");
        }
        const toggleContainer = rowEl.createDiv({ cls: "flit-enable-column" });
        const toggleSetting = new import_obsidian.Setting(document.createElement("div"));
        toggleSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.charReplacementEnabled[setting.key]).onChange(async (value) => {
            this.plugin.settings.charReplacementEnabled[setting.key] = value;
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          if (isDisabled) {
            toggle.setDisabled(true);
          }
          toggleContainer.appendChild(toggle.toggleEl);
        });
        const nameContainer = rowEl.createEl("div", { cls: "flit-char-name-column" });
        nameContainer.createEl("div", { text: setting.name, cls: "setting-item-name" });
        const inputContainer = rowEl.createDiv({ cls: "flit-char-text-input-container" });
        const restoreButton = inputContainer.createEl("button", {
          cls: "clickable-icon flit-restore-icon",
          attr: { "aria-label": "Restore default" }
        });
        (0, import_obsidian.setIcon)(restoreButton, "rotate-ccw");
        if (isDisabled) {
          restoreButton.disabled = true;
        }
        restoreButton.addEventListener("click", async () => {
          this.plugin.settings.charReplacements[setting.key] = DEFAULT_SETTINGS.charReplacements[setting.key];
          textInput.value = DEFAULT_SETTINGS.charReplacements[setting.key];
          await this.plugin.saveSettings();
        });
        const textInput = inputContainer.createEl("input", { type: "text", cls: "flit-char-text-input" });
        textInput.placeholder = "Replace with";
        textInput.value = this.plugin.settings.charReplacements[setting.key];
        textInput.style.width = "120px";
        textInput.disabled = isDisabled;
        textInput.addEventListener("input", async (e) => {
          this.plugin.settings.charReplacements[setting.key] = e.target.value;
          await this.plugin.saveSettings();
        });
        const trimLeftContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const trimLeftSetting = new import_obsidian.Setting(document.createElement("div"));
        trimLeftSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.charReplacementTrimLeft[setting.key]).onChange(async (value) => {
            this.plugin.settings.charReplacementTrimLeft[setting.key] = value;
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          if (isDisabled) {
            toggle.setDisabled(true);
          }
          trimLeftContainer.appendChild(toggle.toggleEl);
        });
        const trimRightContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const trimRightSetting = new import_obsidian.Setting(document.createElement("div"));
        trimRightSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.charReplacementTrimRight[setting.key]).onChange(async (value) => {
            this.plugin.settings.charReplacementTrimRight[setting.key] = value;
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          if (isDisabled) {
            toggle.setDisabled(true);
          }
          trimRightContainer.appendChild(toggle.toggleEl);
        });
      });
      updateCharacterReplacementUI();
    };
    updateCharacterSettings();
    this.containerEl.createEl("br");
    const customHeaderContainer = this.containerEl.createEl("div", { cls: "setting-item flit-custom-header-container" });
    const customHeader = customHeaderContainer.createEl("h3", { text: "Custom replacements", cls: "flit-custom-header" });
    const customHeaderToggleSetting = new import_obsidian.Setting(document.createElement("div"));
    customHeaderToggleSetting.addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableCustomReplacements).onChange(async (value) => {
        this.plugin.settings.enableCustomReplacements = value;
        await this.plugin.saveSettings();
        updateCustomReplacementUI();
      });
      customHeaderContainer.appendChild(toggle.toggleEl);
    });
    const customDescEl = this.containerEl.createEl("div", { cls: "setting-item-description" });
    const updateCustomDescriptionContent = () => {
      const isEnabled = this.plugin.settings.enableCustomReplacements;
      customDescEl.empty();
      if (isEnabled) {
        customDescEl.createEl("span", { text: "Define custom text replacements." });
        customDescEl.createEl("br");
        customDescEl.createEl("br");
        const ul = customDescEl.createEl("ul");
        ul.style.margin = "0";
        ul.style.paddingLeft = "20px";
        ul.createEl("li", { text: "Rules are applied sequentially from top to bottom." });
        ul.createEl("li", { text: "Whitespace preserved." });
        const li3 = ul.createEl("li");
        li3.appendText("Leave ");
        li3.createEl("em", { text: "Replace with" });
        li3.appendText(" blank to omit text entirely.");
        const li4 = ul.createEl("li");
        li4.appendText("If ");
        li4.createEl("em", { text: "Replace with" });
        li4.appendText(" is blank and ");
        li4.createEl("em", { text: "Text to replace" });
        li4.appendText(" matches whole line, the filename becomes ");
        li4.createEl("em", { text: "Untitled" });
        li4.appendText(".");
      } else {
        customDescEl.createEl("span", { text: "Define custom text replacements." });
      }
    };
    updateCustomDescriptionContent();
    this.containerEl.createEl("br");
    const updateCustomReplacementUI = () => {
      const isEnabled = this.plugin.settings.enableCustomReplacements;
      if (isEnabled) {
        customDescEl.classList.remove("flit-desc-disabled");
      } else {
        customDescEl.classList.add("flit-desc-disabled");
      }
      updateCustomDescriptionContent();
      const customSettingsEls = this.containerEl.querySelectorAll(".flit-custom-replacement-setting, .flit-custom-replacement-header, .flit-add-replacement-button");
      customSettingsEls.forEach((el) => {
        if (isEnabled) {
          el.classList.remove("hidden");
        } else {
          el.classList.add("hidden");
        }
      });
    };
    const renderCustomReplacements = () => {
      const existingCustomSettings = this.containerEl.querySelectorAll(".flit-custom-replacement-setting, .flit-custom-replacement-header, .flit-custom-table-container");
      existingCustomSettings.forEach((el) => el.remove());
      const existingAddButton = this.containerEl.querySelector(".flit-add-replacement-button");
      if (existingAddButton) existingAddButton.remove();
      const tableContainer = this.containerEl.createEl("div", { cls: "flit-table-container flit-custom-table-container" });
      const tableWrapper = tableContainer.createEl("div", { cls: "flit-table-wrapper" });
      const headerRow = tableWrapper.createEl("div", { cls: "flit-custom-replacement-header" });
      const enableHeader = headerRow.createDiv({ cls: "flit-enable-column" });
      enableHeader.textContent = "Enable";
      const textToReplaceHeader = headerRow.createDiv({ cls: "flit-text-column" });
      textToReplaceHeader.textContent = "Text to replace";
      const replaceWithHeader = headerRow.createDiv({ cls: "flit-text-column" });
      replaceWithHeader.textContent = "Replace with";
      const startOnlyHeader = headerRow.createDiv({ cls: "flit-toggle-column" });
      const startLine1 = startOnlyHeader.createDiv();
      startLine1.textContent = "Match at";
      const startLine2 = startOnlyHeader.createDiv();
      startLine2.textContent = "line start";
      const startLine3 = startOnlyHeader.createDiv();
      startLine3.textContent = "only";
      const wholeLineHeader = headerRow.createDiv({ cls: "flit-toggle-column" });
      const wholeLine1 = wholeLineHeader.createDiv();
      wholeLine1.textContent = "Match";
      const wholeLine2 = wholeLineHeader.createDiv();
      wholeLine2.textContent = "whole line";
      const wholeLine3 = wholeLineHeader.createDiv();
      wholeLine3.textContent = "only";
      const actionsHeader = headerRow.createDiv({ cls: "flit-actions-column" });
      actionsHeader.textContent = "";
      this.plugin.settings.customReplacements.forEach((replacement, index) => {
        const rowEl = tableWrapper.createEl("div", { cls: "flit-custom-replacement-setting" });
        const toggleContainer = rowEl.createDiv({ cls: "flit-enable-column" });
        const individualToggleSetting = new import_obsidian.Setting(document.createElement("div"));
        individualToggleSetting.addToggle((toggle) => {
          toggle.setValue(replacement.enabled).onChange(async (value) => {
            this.plugin.settings.customReplacements[index].enabled = value;
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          toggleContainer.appendChild(toggle.toggleEl);
        });
        const input1Container = rowEl.createDiv({ cls: "flit-text-column" });
        const input1 = input1Container.createEl("input", { type: "text" });
        input1.placeholder = "Text to replace";
        input1.value = replacement.searchText;
        input1.addEventListener("input", async (e) => {
          this.plugin.settings.customReplacements[index].searchText = e.target.value;
          await this.plugin.saveSettings();
        });
        const input2Container = rowEl.createDiv({ cls: "flit-text-column" });
        const input2 = input2Container.createEl("input", { type: "text" });
        input2.placeholder = "Replace with";
        input2.value = replacement.replaceText;
        input2.addEventListener("input", async (e) => {
          this.plugin.settings.customReplacements[index].replaceText = e.target.value;
          await this.plugin.saveSettings();
        });
        const startToggleContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const startToggleSetting = new import_obsidian.Setting(document.createElement("div"));
        startToggleSetting.addToggle((toggle) => {
          toggle.setValue(replacement.onlyAtStart).onChange(async (value) => {
            this.plugin.settings.customReplacements[index].onlyAtStart = value;
            if (value) {
              this.plugin.settings.customReplacements[index].onlyWholeLine = false;
            }
            await this.plugin.saveSettings();
            renderCustomReplacements();
          });
          toggle.toggleEl.style.margin = "0";
          if (replacement.onlyWholeLine) {
            toggle.setDisabled(true);
            toggle.toggleEl.style.opacity = "0.5";
            toggle.toggleEl.style.pointerEvents = "none";
          }
          startToggleContainer.appendChild(toggle.toggleEl);
        });
        const wholeToggleContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const wholeToggleSetting = new import_obsidian.Setting(document.createElement("div"));
        wholeToggleSetting.addToggle((toggle) => {
          toggle.setValue(replacement.onlyWholeLine).onChange(async (value) => {
            this.plugin.settings.customReplacements[index].onlyWholeLine = value;
            if (value) {
              this.plugin.settings.customReplacements[index].onlyAtStart = false;
            }
            await this.plugin.saveSettings();
            renderCustomReplacements();
          });
          toggle.toggleEl.style.margin = "0";
          if (replacement.onlyAtStart) {
            toggle.setDisabled(true);
            toggle.toggleEl.style.opacity = "0.5";
            toggle.toggleEl.style.pointerEvents = "none";
          }
          wholeToggleContainer.appendChild(toggle.toggleEl);
        });
        const buttonContainer = rowEl.createDiv({ cls: "flit-actions-column flit-button-container" });
        const upButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-nav-button",
          attr: { "aria-label": "Move up" }
        });
        if (index === 0) {
          upButton.classList.add("disabled");
        }
        (0, import_obsidian.setIcon)(upButton, "chevron-up");
        if (index > 0) {
          upButton.addEventListener("click", async () => {
            const temp = this.plugin.settings.customReplacements[index];
            this.plugin.settings.customReplacements[index] = this.plugin.settings.customReplacements[index - 1];
            this.plugin.settings.customReplacements[index - 1] = temp;
            await this.plugin.saveSettings();
            renderCustomReplacements();
          });
        }
        const downButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-nav-button",
          attr: { "aria-label": "Move down" }
        });
        if (index === this.plugin.settings.customReplacements.length - 1) {
          downButton.classList.add("disabled");
        }
        (0, import_obsidian.setIcon)(downButton, "chevron-down");
        if (index < this.plugin.settings.customReplacements.length - 1) {
          downButton.addEventListener("click", async () => {
            const temp = this.plugin.settings.customReplacements[index];
            this.plugin.settings.customReplacements[index] = this.plugin.settings.customReplacements[index + 1];
            this.plugin.settings.customReplacements[index + 1] = temp;
            await this.plugin.saveSettings();
            renderCustomReplacements();
          });
        }
        const deleteButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-delete-button",
          attr: { "aria-label": "Delete" }
        });
        (0, import_obsidian.setIcon)(deleteButton, "trash-2");
        deleteButton.addEventListener("click", async () => {
          this.plugin.settings.customReplacements.splice(index, 1);
          await this.plugin.saveSettings();
          renderCustomReplacements();
        });
      });
      const addButtonSetting = new import_obsidian.Setting(this.containerEl).addButton(
        (button) => button.setButtonText("Add replacement").onClick(async () => {
          this.plugin.settings.customReplacements.push({
            searchText: "",
            replaceText: "",
            onlyAtStart: false,
            onlyWholeLine: false,
            enabled: true
          });
          await this.plugin.saveSettings();
          renderCustomReplacements();
        })
      );
      addButtonSetting.settingEl.addClass("flit-add-replacement-button");
      updateCustomReplacementUI();
    };
    renderCustomReplacements();
    this.containerEl.createEl("br");
    const safewordsHeaderContainer = this.containerEl.createEl("div", { cls: "setting-item flit-custom-header-container" });
    const safewordsHeader = safewordsHeaderContainer.createEl("h3", { text: "Safewords", cls: "flit-custom-header" });
    const safewordsHeaderToggleSetting = new import_obsidian.Setting(document.createElement("div"));
    safewordsHeaderToggleSetting.addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableSafewords).onChange(async (value) => {
        this.plugin.settings.enableSafewords = value;
        if (value && !this.plugin.settings.hasEnabledSafewords) {
          if (this.plugin.settings.safewords.length === 0) {
            this.plugin.settings.safewords.push({
              text: "Title",
              onlyAtStart: false,
              onlyWholeLine: false,
              enabled: false
            });
          }
          this.plugin.settings.hasEnabledSafewords = true;
        }
        await this.plugin.saveSettings();
        updateSafewordsUI();
      });
      safewordsHeaderContainer.appendChild(toggle.toggleEl);
    });
    const safewordsDescEl = this.containerEl.createEl("div", { cls: "setting-item-description" });
    const updateSafewordsDescriptionContent = () => {
      const isEnabled = this.plugin.settings.enableSafewords;
      safewordsDescEl.empty();
      if (isEnabled) {
        safewordsDescEl.createEl("span", { text: "Filenames that contain the entries below won't be renamed." });
      } else {
        safewordsDescEl.createEl("span", { text: "Filenames that contain the entries below won't be renamed." });
      }
    };
    updateSafewordsDescriptionContent();
    this.containerEl.createEl("br");
    const updateSafewordsUI = () => {
      const isEnabled = this.plugin.settings.enableSafewords;
      if (isEnabled) {
        safewordsDescEl.classList.remove("flit-desc-disabled");
      } else {
        safewordsDescEl.classList.add("flit-desc-disabled");
      }
      updateSafewordsDescriptionContent();
      const safewordSettingsEls = this.containerEl.querySelectorAll(".flit-safeword-setting, .flit-safeword-header, .flit-add-safeword-button");
      safewordSettingsEls.forEach((el) => {
        if (isEnabled) {
          el.classList.remove("hidden");
        } else {
          el.classList.add("hidden");
        }
      });
    };
    const renderSafewords = () => {
      const existingSafewordSettings = this.containerEl.querySelectorAll(".flit-safeword-setting, .flit-safeword-header, .flit-safeword-table-container");
      existingSafewordSettings.forEach((el) => el.remove());
      const existingAddButton = this.containerEl.querySelector(".flit-add-safeword-button");
      if (existingAddButton) existingAddButton.remove();
      const tableContainer = this.containerEl.createEl("div", { cls: "flit-table-container flit-safeword-table-container" });
      const tableWrapper = tableContainer.createEl("div", { cls: "flit-table-wrapper" });
      const headerRow = tableWrapper.createEl("div", { cls: "flit-safeword-header" });
      const enableHeader = headerRow.createDiv({ cls: "flit-enable-column" });
      enableHeader.textContent = "Enable";
      const safewordHeader = headerRow.createDiv({ cls: "flit-text-column flit-safeword-input" });
      safewordHeader.textContent = "Safeword";
      const startOnlyHeader = headerRow.createDiv({ cls: "flit-toggle-column" });
      const startLine1 = startOnlyHeader.createDiv();
      startLine1.textContent = "Match at";
      const startLine2 = startOnlyHeader.createDiv();
      startLine2.textContent = "line start";
      const startLine3 = startOnlyHeader.createDiv();
      startLine3.textContent = "only";
      const wholeLineHeader = headerRow.createDiv({ cls: "flit-toggle-column" });
      const wholeLine1 = wholeLineHeader.createDiv();
      wholeLine1.textContent = "Match";
      const wholeLine2 = wholeLineHeader.createDiv();
      wholeLine2.textContent = "whole line";
      const wholeLine3 = wholeLineHeader.createDiv();
      wholeLine3.textContent = "only";
      const actionsHeader = headerRow.createDiv({ cls: "flit-actions-column" });
      actionsHeader.textContent = "";
      this.plugin.settings.safewords.forEach((safeword, index) => {
        const rowEl = tableWrapper.createEl("div", { cls: "flit-safeword-setting" });
        const toggleContainer = rowEl.createDiv({ cls: "flit-enable-column" });
        const individualToggleSetting = new import_obsidian.Setting(document.createElement("div"));
        individualToggleSetting.addToggle((toggle) => {
          toggle.setValue(safeword.enabled).onChange(async (value) => {
            this.plugin.settings.safewords[index].enabled = value;
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          toggleContainer.appendChild(toggle.toggleEl);
        });
        const inputContainer = rowEl.createDiv({ cls: "flit-text-column flit-safeword-input" });
        const input = inputContainer.createEl("input", { type: "text" });
        input.placeholder = "Safeword";
        input.value = safeword.text;
        input.addEventListener("input", async (e) => {
          const inputEl = e.target;
          let value = inputEl.value;
          const universalForbidden = ["/", ":", "|", String.fromCharCode(92), "#", "[", "]", "^"];
          const windowsAndroidForbidden = ["*", "?", "<", ">", '"'];
          let forbiddenChars = [...universalForbidden];
          if (this.plugin.settings.osPreset === "Windows" || this.plugin.settings.osPreset === "Linux") {
            forbiddenChars.push(...windowsAndroidForbidden);
          }
          let filteredValue = "";
          for (let i = 0; i < value.length; i++) {
            const char = value[i];
            if (char === "." && i === 0) {
              continue;
            }
            if (forbiddenChars.includes(char)) {
              continue;
            }
            filteredValue += char;
          }
          if (filteredValue !== value) {
            inputEl.value = filteredValue;
            const cursorPos = Math.min(inputEl.selectionStart || 0, filteredValue.length);
            inputEl.setSelectionRange(cursorPos, cursorPos);
          }
          this.plugin.settings.safewords[index].text = filteredValue;
          await this.plugin.saveSettings();
        });
        const startToggleContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const startToggleSetting = new import_obsidian.Setting(document.createElement("div"));
        startToggleSetting.addToggle((toggle) => {
          toggle.setValue(safeword.onlyAtStart).onChange(async (value) => {
            this.plugin.settings.safewords[index].onlyAtStart = value;
            if (value) {
              this.plugin.settings.safewords[index].onlyWholeLine = false;
            }
            await this.plugin.saveSettings();
            renderSafewords();
          });
          toggle.toggleEl.style.margin = "0";
          if (safeword.onlyWholeLine) {
            toggle.setDisabled(true);
            toggle.toggleEl.style.opacity = "0.5";
            toggle.toggleEl.style.pointerEvents = "none";
          }
          startToggleContainer.appendChild(toggle.toggleEl);
        });
        const wholeToggleContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const wholeToggleSetting = new import_obsidian.Setting(document.createElement("div"));
        wholeToggleSetting.addToggle((toggle) => {
          toggle.setValue(safeword.onlyWholeLine).onChange(async (value) => {
            this.plugin.settings.safewords[index].onlyWholeLine = value;
            if (value) {
              this.plugin.settings.safewords[index].onlyAtStart = false;
            }
            await this.plugin.saveSettings();
            renderSafewords();
          });
          toggle.toggleEl.style.margin = "0";
          if (safeword.onlyAtStart) {
            toggle.setDisabled(true);
            toggle.toggleEl.style.opacity = "0.5";
            toggle.toggleEl.style.pointerEvents = "none";
          }
          wholeToggleContainer.appendChild(toggle.toggleEl);
        });
        const buttonContainer = rowEl.createDiv({ cls: "flit-actions-column flit-button-container" });
        const upButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-nav-button",
          attr: { "aria-label": "Move up" }
        });
        if (index === 0) {
          upButton.classList.add("disabled");
        }
        (0, import_obsidian.setIcon)(upButton, "chevron-up");
        if (index > 0) {
          upButton.addEventListener("click", async () => {
            const temp = this.plugin.settings.safewords[index];
            this.plugin.settings.safewords[index] = this.plugin.settings.safewords[index - 1];
            this.plugin.settings.safewords[index - 1] = temp;
            await this.plugin.saveSettings();
            renderSafewords();
          });
        }
        const downButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-nav-button",
          attr: { "aria-label": "Move down" }
        });
        if (index === this.plugin.settings.safewords.length - 1) {
          downButton.classList.add("disabled");
        }
        (0, import_obsidian.setIcon)(downButton, "chevron-down");
        if (index < this.plugin.settings.safewords.length - 1) {
          downButton.addEventListener("click", async () => {
            const temp = this.plugin.settings.safewords[index];
            this.plugin.settings.safewords[index] = this.plugin.settings.safewords[index + 1];
            this.plugin.settings.safewords[index + 1] = temp;
            await this.plugin.saveSettings();
            renderSafewords();
          });
        }
        const deleteButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-delete-button",
          attr: { "aria-label": "Delete" }
        });
        (0, import_obsidian.setIcon)(deleteButton, "trash-2");
        deleteButton.addEventListener("click", async () => {
          this.plugin.settings.safewords.splice(index, 1);
          await this.plugin.saveSettings();
          renderSafewords();
        });
      });
      const addButtonSetting = new import_obsidian.Setting(this.containerEl).addButton(
        (button) => button.setButtonText("Add safeword").onClick(async () => {
          this.plugin.settings.safewords.push({
            text: "",
            onlyAtStart: false,
            onlyWholeLine: false,
            enabled: true
          });
          await this.plugin.saveSettings();
          renderSafewords();
        })
      );
      addButtonSetting.settingEl.addClass("flit-add-safeword-button");
      updateSafewordsUI();
    };
    renderSafewords();
  }
};
