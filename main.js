/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/constants.ts
var DEFAULT_SETTINGS, UNIVERSAL_FORBIDDEN_CHARS, WINDOWS_ANDROID_CHARS, TITLE_CHAR_REVERSAL_MAP;
var init_constants = __esm({
  "src/constants.ts"() {
    DEFAULT_SETTINGS = {
      folderScopeStrategy: "Only exclude...",
      tagScopeStrategy: "Only exclude...",
      propertyScopeStrategy: "Only exclude...",
      excludedFolders: [""],
      excludedTags: [""],
      excludedProperties: [],
      charCount: 100,
      checkInterval: 0,
      osPreset: "macOS",
      charReplacements: {
        slash: " \u2215 ",
        colon: "\u0589",
        asterisk: "\u2217",
        question: "\uFE56",
        lessThan: "\u2039",
        greaterThan: "\u203A",
        quote: "\uFF02",
        pipe: "\u2758",
        hash: "\uFF03",
        leftBracket: "\uFF3B",
        rightBracket: "\uFF3D",
        caret: "\u02C6",
        backslash: "\u29F5",
        dot: "\u2024"
      },
      charReplacementEnabled: {
        slash: false,
        colon: false,
        asterisk: false,
        question: false,
        lessThan: false,
        greaterThan: false,
        quote: false,
        pipe: false,
        hash: false,
        leftBracket: false,
        rightBracket: false,
        caret: false,
        backslash: false,
        dot: true
      },
      charReplacementTrimLeft: {
        slash: false,
        colon: false,
        asterisk: false,
        question: false,
        lessThan: false,
        greaterThan: false,
        quote: false,
        pipe: false,
        hash: false,
        leftBracket: true,
        rightBracket: true,
        caret: false,
        backslash: false,
        dot: false
      },
      charReplacementTrimRight: {
        slash: false,
        colon: false,
        asterisk: false,
        question: false,
        lessThan: false,
        greaterThan: false,
        quote: false,
        pipe: false,
        hash: false,
        leftBracket: true,
        rightBracket: true,
        caret: false,
        backslash: false,
        dot: false
      },
      customReplacements: [
        { searchText: "- [ ] ", replaceText: "\u2714\uFE0F ", onlyAtStart: true, onlyWholeLine: false, enabled: false },
        { searchText: "- [x] ", replaceText: "\u2705 ", onlyAtStart: true, onlyWholeLine: false, enabled: false }
      ],
      safewords: [
        { text: "To do", onlyAtStart: false, onlyWholeLine: false, enabled: false, caseSensitive: false }
      ],
      omitComments: false,
      omitHtmlTags: false,
      stripTemplaterSyntax: true,
      enableStripMarkup: true,
      stripMarkupSettings: {
        headings: true,
        bold: true,
        italic: true,
        strikethrough: true,
        highlight: true,
        wikilinks: true,
        markdownLinks: true,
        quote: true,
        callouts: true,
        unorderedLists: true,
        orderedLists: true,
        taskLists: true,
        code: true,
        codeBlocks: true,
        footnotes: true,
        comments: true,
        htmlTags: true
      },
      stripMarkupInAlias: false,
      stripCommentsEntirely: true,
      applyCustomRulesInAlias: false,
      enableForbiddenCharReplacements: false,
      enableCustomReplacements: false,
      applyCustomRulesAfterForbiddenChars: false,
      applyCustomRulesAfterMarkupStripping: false,
      enableSafewords: false,
      renameOnFocus: false,
      renameOnSave: false,
      renameNotes: "automatically",
      manualNotificationMode: "Always",
      windowsAndroidEnabled: false,
      hasEnabledForbiddenChars: false,
      hasEnabledWindowsAndroid: false,
      hasEnabledCustomReplacements: false,
      hasEnabledSafewords: false,
      hasEnabledAliases: false,
      grabTitleFromCardLink: true,
      excludeSubfolders: true,
      tagMatchingMode: "In Properties and note body",
      excludeChildTags: true,
      fileReadMethod: "Editor",
      // Default to editor method
      verboseLogging: false,
      // Added default for verbose logging
      debugOutputFullContent: false,
      // Default OFF for debug content output
      debugEnabledTimestamp: "",
      // No debug enabled timestamp yet
      hasShownFirstTimeNotice: false,
      // First-time notice not shown yet
      hasSetupExclusions: false,
      // Exclusions tab not opened yet
      hasSetPropertyType: false,
      // Property type not set yet
      lastUsageDate: "",
      // No usage date yet
      currentSettingsTab: "general",
      // Default to general tab
      commandVisibility: {
        folderPutFirstLineInTitle: true,
        folderExclude: true,
        folderStopExcluding: true,
        filePutFirstLineInTitle: true,
        fileExclude: true,
        fileStopExcluding: true,
        tagPutFirstLineInTitle: true,
        tagExclude: true,
        tagStopExcluding: true,
        addSafeInternalLink: true,
        addSafeInternalLinkWithCaption: true
      },
      enableContextMenus: true,
      enableVaultSearchContextMenu: true,
      vaultSearchContextMenuVisibility: {
        putFirstLineInTitle: true,
        disable: true,
        enable: true
      },
      enableCommandPalette: true,
      commandPaletteVisibility: {
        renameCurrentFileUnlessExcluded: true,
        renameCurrentFile: true,
        renameAllFiles: true,
        disableRenaming: true,
        enableRenaming: true,
        toggleAutomaticRenaming: true
      },
      enableRibbon: true,
      ribbonVisibility: {
        renameCurrentFile: true,
        renameAllNotes: false,
        toggleAutomaticRenaming: false
      },
      enableAliases: false,
      truncateAlias: false,
      addAliasOnlyIfFirstLineDiffers: false,
      aliasPropertyKey: "aliases",
      hideAliasProperty: "never",
      hideAliasInSidebar: false,
      keepEmptyAliasProperty: true,
      whatToPutInTitle: "any_first_line_content",
      includeSubfolders: true,
      includeBodyTags: true,
      includeNestedTags: true,
      moveCursorToFirstLine: true,
      insertTitleOnCreation: false,
      placeCursorAtLineEnd: true,
      waitForCursorTemplate: false,
      suppressMergeNotifications: false,
      newNoteDelay: 0,
      waitForTemplate: false,
      addHeadingToTitle: false,
      disableRenamingKey: "no rename",
      disableRenamingValue: "true",
      modalCheckboxStates: {
        folderRename: {
          includeSubfolders: true,
          renameExcludedFolders: false,
          renameExcludedTags: false,
          renameExcludedProperties: false
        },
        tagRename: {
          includeChildTags: true,
          renameExcludedFolders: false,
          renameExcludedTags: false,
          renameExcludedProperties: false
        },
        searchRename: {
          renameExcludedFolders: false,
          renameExcludedTags: false,
          renameExcludedProperties: false
        },
        folderDisable: {
          includeSubfolders: true
        },
        tagDisable: {
          includeChildTags: true
        }
      }
    };
    UNIVERSAL_FORBIDDEN_CHARS = ["/", ":", "|", String.fromCharCode(92), "#", "[", "]", "^"];
    WINDOWS_ANDROID_CHARS = ["*", "?", "<", ">", '"'];
    TITLE_CHAR_REVERSAL_MAP = {
      "\u2215": "/",
      // Unicode: \u2215 -> slash
      "\u0589": ":",
      // Unicode: \u0589 -> colon
      "\u2217": "*",
      // Unicode: \u2217 -> asterisk
      "\uFE56": "?",
      // Unicode: \uFE56 -> question
      "\u2039": "<",
      // Unicode: \u2039 -> lessThan
      "\u203A": ">",
      // Unicode: \u203A -> greaterThan
      "\uFF02": '"',
      // Unicode: \uFF02 -> quote
      "\u2758": "|",
      // Unicode: \u2758 -> pipe
      "\uFF03": "#",
      // Unicode: \uFF03 -> hash
      "\uFF3B": "[",
      // Unicode: \uFF3B -> leftBracket
      "\uFF3D": "]",
      // Unicode: \uFF3D -> rightBracket
      "\u02C6": "^",
      // Unicode: \u02C6 -> caret
      "\u29F5": "\\",
      // Unicode: \u29F5 -> backslash
      "\u2024": "."
      // Unicode: \u2024 -> dot
    };
  }
});

// src/utils.ts
var utils_exports = {};
__export(utils_exports, {
  containsSafeword: () => containsSafeword,
  detectOS: () => detectOS,
  extractTitle: () => extractTitle,
  fileHasExcludedProperties: () => fileHasExcludedProperties,
  fileHasTargetTags: () => fileHasTargetTags,
  generateSafeLinkTarget: () => generateSafeLinkTarget,
  hasDisablePropertyInFile: () => hasDisablePropertyInFile,
  inExcludedFolder: () => inExcludedFolder,
  isFileExcluded: () => isFileExcluded,
  isFileInTargetFolders: () => isFileInTargetFolders,
  isValidHeading: () => isValidHeading,
  normalizePropertyValue: () => normalizePropertyValue,
  shouldProcessFile: () => shouldProcessFile,
  verboseLog: () => verboseLog
});
function verboseLog(plugin, message, data) {
  if (plugin.settings.verboseLogging) {
    if (data) {
      console.debug(message, data);
    } else {
      console.debug(message);
    }
  }
}
function isValidHeading(line) {
  return /^#{1,6}\s+.*/.test(line);
}
function normalizePropertyValue(value) {
  if (typeof value !== "string") return value;
  if (value === "true") return true;
  if (value === "false") return false;
  if (value === "null") return null;
  if (value !== "" && !isNaN(Number(value))) {
    return Number(value);
  }
  return value;
}
function detectOS() {
  if (import_obsidian.Platform.isMacOS || import_obsidian.Platform.isIosApp) {
    return "macOS";
  }
  if (import_obsidian.Platform.isWin) {
    return "Windows";
  }
  return "Linux";
}
function inExcludedFolder(file, settings) {
  var _a;
  const nonEmptyFolders = settings.excludedFolders.filter((folder) => folder.trim() !== "");
  if (nonEmptyFolders.length === 0) return false;
  const filePath = (_a = file.parent) == null ? void 0 : _a.path;
  if (nonEmptyFolders.includes(filePath)) {
    return true;
  }
  if (settings.excludeSubfolders) {
    for (const excludedFolder of nonEmptyFolders) {
      if (filePath && filePath.startsWith(excludedFolder + "/")) {
        return true;
      }
    }
  }
  return false;
}
function isFileInTargetFolders(file, settings) {
  var _a;
  const nonEmptyFolders = settings.excludedFolders.filter((folder) => folder.trim() !== "");
  if (nonEmptyFolders.length === 0) return false;
  const filePath = (_a = file.parent) == null ? void 0 : _a.path;
  if (nonEmptyFolders.includes(filePath)) {
    return true;
  }
  if (settings.excludeSubfolders) {
    for (const targetFolder of nonEmptyFolders) {
      if (filePath && filePath.startsWith(targetFolder + "/")) {
        return true;
      }
    }
  }
  return false;
}
function fileHasExcludedProperties(file, settings, app) {
  const nonEmptyProperties = settings.excludedProperties.filter(
    (prop) => prop.key.trim() !== ""
  );
  if (nonEmptyProperties.length === 0) return false;
  const fileCache = app.metadataCache.getFileCache(file);
  if (!fileCache || !fileCache.frontmatter) return false;
  const frontmatter = fileCache.frontmatter;
  for (const excludedProp of nonEmptyProperties) {
    const propKey = excludedProp.key.trim();
    const propValue = excludedProp.value.trim();
    if (propKey in frontmatter) {
      if (propValue === "") {
        return true;
      }
      const frontmatterValue = frontmatter[propKey];
      if (typeof frontmatterValue === "string") {
        if (frontmatterValue === propValue) {
          return true;
        }
      } else if (Array.isArray(frontmatterValue)) {
        if (frontmatterValue.some((val) => String(val) === propValue)) {
          return true;
        }
      } else if (frontmatterValue != null) {
        if (String(frontmatterValue) === propValue) {
          return true;
        }
      }
    }
  }
  return false;
}
function fileHasTargetTags(file, settings, app, content) {
  const nonEmptyTags = settings.excludedTags.filter((tag) => tag.trim() !== "");
  if (nonEmptyTags.length === 0) return false;
  const fileCache = app.metadataCache.getFileCache(file);
  if (settings.tagMatchingMode !== "In note body only") {
    let fileTags = [];
    if (content) {
      fileTags = parseTagsFromYAML(content);
    } else if (fileCache && fileCache.frontmatter && fileCache.frontmatter.tags) {
      const frontmatterTags = fileCache.frontmatter.tags;
      fileTags = Array.isArray(frontmatterTags) ? frontmatterTags.map(String) : [String(frontmatterTags)];
    }
    for (const targetTag of nonEmptyTags) {
      const normalizedTargetTag = targetTag.startsWith("#") ? targetTag.slice(1) : targetTag;
      for (const fileTag of fileTags) {
        const normalizedFileTag = fileTag.toString();
        if (normalizedFileTag === normalizedTargetTag) {
          return true;
        }
        if (settings.excludeChildTags) {
          if (normalizedFileTag.startsWith(normalizedTargetTag + "/")) {
            return true;
          }
        }
      }
    }
  }
  if (settings.tagMatchingMode !== "In Properties only") {
    let inlineTagsInContent = [];
    if (content && settings.tagMatchingMode === "In Properties and note body") {
      inlineTagsInContent = parseInlineTagsFromText(content);
    } else if (content && settings.tagMatchingMode === "In note body only") {
      const bodyContent = stripFrontmatter(content);
      inlineTagsInContent = parseInlineTagsFromText(bodyContent);
    } else if (!content) {
      if (fileCache && fileCache.tags) {
        inlineTagsInContent = fileCache.tags.map(
          (tag) => tag.tag.startsWith("#") ? tag.tag.slice(1) : tag.tag
        );
      }
    }
    for (const targetTag of nonEmptyTags) {
      const normalizedTargetTag = targetTag.startsWith("#") ? targetTag.slice(1) : targetTag;
      for (const inlineTag of inlineTagsInContent) {
        if (inlineTag === normalizedTargetTag) {
          return true;
        }
        if (settings.excludeChildTags) {
          if (inlineTag.startsWith(normalizedTargetTag + "/")) {
            return true;
          }
        }
      }
    }
  }
  return false;
}
function shouldProcessFile(file, settings, app, content, exclusionOverrides) {
  const isInTargetFolders = isFileInTargetFolders(file, settings);
  const hasTargetTags = fileHasTargetTags(file, settings, app, content);
  const hasTargetProperties = fileHasExcludedProperties(file, settings, app);
  const applyStrategy = (isTargeted, hasTargets, strategy) => {
    if (strategy === "Only exclude...") {
      return hasTargets ? isTargeted : false;
    } else {
      return hasTargets ? !isTargeted : true;
    }
  };
  const shouldExcludeFromFolders = (exclusionOverrides == null ? void 0 : exclusionOverrides.ignoreFolder) ? false : applyStrategy(
    isInTargetFolders,
    settings.excludedFolders.some((folder) => folder.trim() !== ""),
    settings.folderScopeStrategy
  );
  const shouldExcludeFromTags = (exclusionOverrides == null ? void 0 : exclusionOverrides.ignoreTag) ? false : applyStrategy(
    hasTargetTags,
    settings.excludedTags.some((tag) => tag.trim() !== ""),
    settings.tagScopeStrategy
  );
  const shouldExcludeFromProperties = (exclusionOverrides == null ? void 0 : exclusionOverrides.ignoreProperty) ? false : applyStrategy(
    hasTargetProperties,
    settings.excludedProperties.some((prop) => prop.key.trim() !== ""),
    settings.propertyScopeStrategy
  );
  return !(shouldExcludeFromFolders || shouldExcludeFromTags || shouldExcludeFromProperties);
}
function isFileExcluded(file, settings, app, content) {
  if (fileHasExcludedProperties(file, settings, app)) {
    return true;
  }
  if (inExcludedFolder(file, settings)) {
    return true;
  }
  const nonEmptyTags = settings.excludedTags.filter((tag) => tag.trim() !== "");
  if (nonEmptyTags.length > 0) {
    const fileCache = app.metadataCache.getFileCache(file);
    if (settings.tagMatchingMode !== "In note body only" && fileCache && fileCache.frontmatter && fileCache.frontmatter.tags) {
      const frontmatterTags = fileCache.frontmatter.tags;
      const fileTags = Array.isArray(frontmatterTags) ? frontmatterTags : [frontmatterTags];
      for (const excludedTag of nonEmptyTags) {
        const normalizedExcludedTag = excludedTag.startsWith("#") ? excludedTag.slice(1) : excludedTag;
        for (const fileTag of fileTags) {
          const normalizedFileTag = fileTag.toString();
          if (normalizedFileTag === normalizedExcludedTag) {
            return true;
          }
          if (settings.excludeChildTags) {
            if (normalizedFileTag.startsWith(normalizedExcludedTag + "/")) {
              return true;
            }
          }
        }
      }
    }
    if (settings.tagMatchingMode !== "In Properties only") {
      let inlineTagsInContent = [];
      if (content && settings.tagMatchingMode === "In Properties and note body") {
        inlineTagsInContent = parseInlineTagsFromText(content);
      } else if (content && settings.tagMatchingMode === "In note body only") {
        const bodyContent = stripFrontmatter(content);
        inlineTagsInContent = parseInlineTagsFromText(bodyContent);
      } else if (!content) {
        if (fileCache && fileCache.tags) {
          inlineTagsInContent = fileCache.tags.map(
            (tag) => tag.tag.startsWith("#") ? tag.tag.slice(1) : tag.tag
          );
        }
      }
      for (const excludedTag of nonEmptyTags) {
        const normalizedExcludedTag = excludedTag.startsWith("#") ? excludedTag.slice(1) : excludedTag;
        for (const inlineTag of inlineTagsInContent) {
          if (inlineTag === normalizedExcludedTag) {
            return true;
          }
          if (settings.excludeChildTags) {
            if (inlineTag.startsWith(normalizedExcludedTag + "/")) {
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}
function parseInlineTagsFromText(content) {
  const tagRegex = /#([a-zA-Z][\w\-_/]*)/g;
  const tags = [];
  let match;
  while ((match = tagRegex.exec(content)) !== null) {
    const tag = match[1];
    if (!tags.includes(tag)) {
      tags.push(tag);
    }
  }
  return tags;
}
function stripFrontmatter(content) {
  if (!content.startsWith("---")) {
    return content;
  }
  const lines = content.split("\n");
  let endIndex = -1;
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].trim() === "---") {
      endIndex = i;
      break;
    }
  }
  if (endIndex === -1) {
    return content;
  }
  return lines.slice(endIndex + 1).join("\n");
}
function parseTagsFromYAML(content) {
  const tags = [];
  if (!content.startsWith("---")) {
    return tags;
  }
  const lines = content.split("\n");
  let yamlEndLine = -1;
  for (let i = 1; i < lines.length; i++) {
    if (lines[i] === "---") {
      yamlEndLine = i;
      break;
    }
  }
  if (yamlEndLine === -1) return tags;
  const yamlLines = lines.slice(1, yamlEndLine);
  let currentKey = "";
  let inArray = false;
  for (const line of yamlLines) {
    const trimmed = line.trim();
    if (trimmed === "" || trimmed.startsWith("#")) continue;
    if (trimmed.startsWith("- ")) {
      if (inArray && currentKey === "tags") {
        let tagValue = trimmed.substring(2).trim();
        if (tagValue.startsWith('"') && tagValue.endsWith('"') || tagValue.startsWith("'") && tagValue.endsWith("'")) {
          tagValue = tagValue.substring(1, tagValue.length - 1);
        }
        if (tagValue.startsWith("#")) {
          tagValue = tagValue.substring(1);
        }
        tags.push(tagValue);
      }
      continue;
    }
    if (trimmed.includes(":")) {
      const colonIndex = trimmed.indexOf(":");
      const key = trimmed.substring(0, colonIndex).trim();
      const value = trimmed.substring(colonIndex + 1).trim();
      currentKey = key;
      if (value === "" || value === "[") {
        inArray = true;
        continue;
      } else {
        inArray = false;
      }
      if (key === "tags" && value) {
        let tagValue = value;
        if (tagValue.startsWith('"') && tagValue.endsWith('"') || tagValue.startsWith("'") && tagValue.endsWith("'")) {
          tagValue = tagValue.substring(1, tagValue.length - 1);
        }
        if (tagValue.startsWith("#")) {
          tagValue = tagValue.substring(1);
        }
        tags.push(tagValue);
      }
    }
  }
  return tags;
}
async function hasDisablePropertyInFile(file, app, disableKey, disableValue) {
  try {
    const metadata = app.metadataCache.getFileCache(file);
    const frontmatter = metadata == null ? void 0 : metadata.frontmatter;
    if (!frontmatter) return false;
    const propertyValue = frontmatter[disableKey];
    if (propertyValue === void 0 || propertyValue === null) return false;
    const normalizedPropertyValue = normalizePropertyValue(propertyValue);
    const normalizedDisableValue = normalizePropertyValue(disableValue);
    if (Array.isArray(normalizedPropertyValue)) {
      return normalizedPropertyValue.some((item) => {
        const normalizedItem = normalizePropertyValue(item);
        if (typeof normalizedItem === "string" && typeof normalizedDisableValue === "string") {
          return normalizedItem.toLowerCase() === normalizedDisableValue.toLowerCase();
        }
        return normalizedItem === normalizedDisableValue;
      });
    }
    if (typeof normalizedPropertyValue === "string" && typeof normalizedDisableValue === "string") {
      return normalizedPropertyValue.toLowerCase() === normalizedDisableValue.toLowerCase();
    }
    return normalizedPropertyValue === normalizedDisableValue;
  } catch (error) {
    return false;
  }
}
function containsSafeword(filename, settings) {
  if (!settings.enableSafewords) return false;
  const filenameWithoutExt = filename.replace(/\.md$/, "");
  for (const safeword of settings.safewords) {
    if (!safeword.enabled || !safeword.text) continue;
    const compareFullFilename = safeword.caseSensitive ? filename : filename.toLowerCase();
    const compareFilenameWithoutExt = safeword.caseSensitive ? filenameWithoutExt : filenameWithoutExt.toLowerCase();
    const compareText = safeword.caseSensitive ? safeword.text : safeword.text.toLowerCase();
    for (const compareFilename of [compareFullFilename, compareFilenameWithoutExt]) {
      if (safeword.onlyWholeLine) {
        if (compareFilename.trim() === compareText.trim()) {
          return true;
        }
      } else if (safeword.onlyAtStart) {
        if (compareFilename.startsWith(compareText)) {
          return true;
        }
      } else {
        if (compareFilename.includes(compareText)) {
          return true;
        }
      }
    }
  }
  return false;
}
function extractTitle(line, settings) {
  const originalLine = line;
  line = line.trim();
  if (settings.stripTemplaterSyntax) {
    line = line.replace(/<%\s*tp\.file\.cursor\(\)\s*%>/, "").trim();
    if (line === "<%*") {
      return "Untitled";
    }
  }
  const isHeading = isValidHeading(originalLine);
  const isEmptyHeading = /^#{1,6}\s*$/.test(originalLine);
  if (isEmptyHeading) {
    return "Untitled";
  }
  const escapeMap = /* @__PURE__ */ new Map();
  let escapeCounter = 0;
  const backslashReplacementEnabled = settings.enableForbiddenCharReplacements && settings.charReplacementEnabled.backslash;
  if (!backslashReplacementEnabled) {
    line = line.replace(/\\(.)/g, (match, char) => {
      const placeholder = `__ESCAPED_${escapeCounter++}__`;
      escapeMap.set(placeholder, char);
      return placeholder;
    });
  }
  if (settings.enableStripMarkup || settings.omitComments || settings.omitHtmlTags) {
    const checkEscaped = (match, offset) => {
      if (backslashReplacementEnabled) return false;
      const matchEnd = offset + match.length;
      for (let i = offset; i < matchEnd; i++) {
        for (const placeholder of escapeMap.keys()) {
          if (line.indexOf(placeholder) === i) return true;
        }
      }
      return false;
    };
    if (settings.enableStripMarkup && settings.stripMarkupSettings.comments || settings.omitComments) {
      line = line.replace(/%%.*?%%/g, "");
      line = line.replace(/<!--.*?-->/g, "");
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.bold) {
      line = line.replace(/\*\*(.+?)\*\*/g, (match, content, offset) => {
        return checkEscaped(match, offset) ? match : content;
      });
      line = line.replace(/__(.+?)__/g, (match, content, offset) => {
        return checkEscaped(match, offset) ? match : content;
      });
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.italic) {
      line = line.replace(/(?<!\*)\*(?!\*)(.+?)(?<!\*)\*(?!\*)/g, (match, content, offset) => {
        return checkEscaped(match, offset) ? match : content;
      });
      line = line.replace(/(?<!_)_(?!_)(.+?)(?<!_)_(?!_)/g, (match, content, offset) => {
        return checkEscaped(match, offset) ? match : content;
      });
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.strikethrough) {
      line = line.replace(/~~(.+?)~~/g, (match, content, offset) => {
        return checkEscaped(match, offset) ? match : content;
      });
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.highlight) {
      line = line.replace(/==(.+?)==/g, (match, content, offset) => {
        return checkEscaped(match, offset) ? match : content;
      });
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.codeBlocks) {
      if (/^\s*```\s*$/.test(line)) {
        return "Untitled";
      }
      const codeBlockMatch = /^\s*```(?!`)[^\n]*\n([\s\S]+)/m.exec(line);
      if (codeBlockMatch) {
        const content = codeBlockMatch[1];
        const contentLines = content.split("\n");
        let foundLine = false;
        for (const contentLine of contentLines) {
          const trimmed = contentLine.trim();
          if (trimmed !== "" && !trimmed.startsWith("```")) {
            line = contentLine;
            foundLine = true;
            break;
          }
        }
        if (!foundLine) {
          return "Untitled";
        }
      }
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.code) {
      line = line.replace(/`(.+?)`/g, (match, content, offset) => {
        return checkEscaped(match, offset) ? match : content;
      });
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.callouts) {
      line = line.replace(/^>\s*\[![^\]]+\]\s*(.*)$/gm, "$1");
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.quote) {
      line = line.replace(/^>\s*(.*)$/gm, "$1");
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.taskLists) {
      line = line.replace(/^(?:[-+*]|\d+\.) \[.\] /gm, "");
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.unorderedLists) {
      line = line.replace(/^[-+*] /gm, "");
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.orderedLists) {
      line = line.replace(/^\d+\. /gm, "");
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.htmlTags || settings.omitHtmlTags) {
      let previousLine = "";
      while (line !== previousLine) {
        previousLine = line;
        line = line.replace(/<([a-zA-Z][a-zA-Z0-9]*)\b[^>]*>(.*?)<\/\1>/g, "$2");
      }
    }
    if (settings.enableStripMarkup && settings.stripMarkupSettings.footnotes) {
      line = line.replace(/\[\^[^\]]+\](?!:)/g, "");
      line = line.replace(/\^\[[^\]]+\](?!:)/g, "");
    }
  }
  const embedLinkRegex = /!\[\[(.*?)\]\]/g;
  line = line.replace(embedLinkRegex, "[[$1]]");
  const regularEmbedRegex = /!\[(.*?)\]\((.*?)\)/g;
  line = line.replace(regularEmbedRegex, (match, caption) => caption);
  if (isHeading && (!settings.enableStripMarkup || settings.stripMarkupSettings.headings)) {
    const headerArr = [
      "# ",
      "## ",
      "### ",
      "#### ",
      "##### ",
      "###### "
    ];
    for (let i = 0; i < headerArr.length; i++) {
      if (line.startsWith(headerArr[i])) {
        line = line.slice(headerArr[i].length).trim();
        break;
      }
    }
  }
  if (!settings.enableStripMarkup || settings.stripMarkupSettings.wikilinks) {
    while (line.includes("[[") && line.includes("]]")) {
      const openBracket = line.indexOf("[[");
      const closeBracket = line.indexOf("]]", openBracket);
      if (openBracket === -1 || closeBracket === -1) break;
      const linkText = line.slice(openBracket + 2, closeBracket);
      const beforeLink = line.slice(0, openBracket);
      const afterLink = line.slice(closeBracket + 2);
      const pipeIndex = linkText.indexOf("|");
      const resolvedText = pipeIndex !== -1 ? linkText.slice(pipeIndex + 1) : linkText;
      line = (beforeLink + resolvedText + afterLink).trim();
    }
  }
  const onlyEmptyLinksRegex = /^(\s*!?\[\]\([^)]*\)\s*)+$/;
  if (onlyEmptyLinksRegex.test(line)) {
    return "Untitled";
  }
  if (!settings.enableStripMarkup || settings.stripMarkupSettings.markdownLinks) {
    const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
    line = line.replace(markdownLinkRegex, (_, title) => title);
    line = line.replace(/!?\[\]\([^)]*\)/g, "").trim();
  }
  if (!backslashReplacementEnabled) {
    for (const [placeholder, char] of escapeMap) {
      line = line.replace(placeholder, char);
    }
  }
  return line;
}
function generateSafeLinkTarget(text, settings) {
  function detectOS2() {
    const platform = window.navigator.platform.toLowerCase();
    if (platform.indexOf("win") !== -1) return "Windows";
    if (platform.indexOf("mac") !== -1) return "macOS";
    return "Linux";
  }
  const charMap = {
    "/": settings.charReplacements.slash,
    ":": settings.charReplacements.colon,
    "|": settings.charReplacements.pipe,
    "#": settings.charReplacements.hash,
    "[": settings.charReplacements.leftBracket,
    "]": settings.charReplacements.rightBracket,
    "^": settings.charReplacements.caret,
    "*": settings.charReplacements.asterisk,
    "?": settings.charReplacements.question,
    "<": settings.charReplacements.lessThan,
    ">": settings.charReplacements.greaterThan,
    '"': settings.charReplacements.quote,
    [String.fromCharCode(92)]: settings.charReplacements.backslash,
    ".": settings.charReplacements.dot
  };
  const universalForbiddenChars = UNIVERSAL_FORBIDDEN_CHARS;
  const windowsAndroidChars = WINDOWS_ANDROID_CHARS;
  const allForbiddenChars = [...universalForbiddenChars];
  const currentOS = detectOS2();
  if (currentOS === "Windows" || settings.windowsAndroidEnabled) {
    allForbiddenChars.push(...windowsAndroidChars);
  }
  const forbiddenChars = [...new Set(allForbiddenChars)].join("");
  let result = "";
  for (let i = 0; i < text.length; i++) {
    let char = text[i];
    if (char === ".") {
      if (result === "") {
        if (settings.enableForbiddenCharReplacements && settings.charReplacementEnabled.dot) {
          const replacement = charMap["."] || "";
          if (replacement !== "") {
            if (settings.charReplacementTrimRight.dot) {
              while (i + 1 < text.length && /\s/.test(text[i + 1])) {
                i++;
              }
            }
            result += replacement;
          }
        }
      } else {
        result += ".";
      }
    } else if (forbiddenChars.includes(char)) {
      let shouldReplace = false;
      let replacement = "";
      if (settings.enableForbiddenCharReplacements) {
        let settingKey = null;
        switch (char) {
          case "/":
            settingKey = "slash";
            break;
          case String.fromCharCode(92):
            settingKey = "backslash";
            break;
          case ":":
            settingKey = "colon";
            break;
          case "|":
            settingKey = "pipe";
            break;
          case "#":
            settingKey = "hash";
            break;
          case "[":
            settingKey = "leftBracket";
            break;
          case "]":
            settingKey = "rightBracket";
            break;
          case "^":
            settingKey = "caret";
            break;
          case "*":
            settingKey = "asterisk";
            break;
          case "?":
            settingKey = "question";
            break;
          case "<":
            settingKey = "lessThan";
            break;
          case ">":
            settingKey = "greaterThan";
            break;
          case '"':
            settingKey = "quote";
            break;
        }
        const isWindowsAndroidChar = WINDOWS_ANDROID_CHARS.includes(char);
        const canReplace = isWindowsAndroidChar ? settings.windowsAndroidEnabled && settingKey && settings.charReplacementEnabled[settingKey] : settingKey && settings.charReplacementEnabled[settingKey];
        if (canReplace && settingKey) {
          shouldReplace = true;
          replacement = charMap[char] || "";
          if (replacement !== "") {
            if (settings.charReplacementTrimLeft[settingKey]) {
              result = result.trimEnd();
            }
            if (settings.charReplacementTrimRight[settingKey]) {
              while (i + 1 < text.length && /\s/.test(text[i + 1])) {
                i++;
              }
            }
          }
        }
      }
      if (shouldReplace && replacement !== "") {
        result += replacement;
      }
    } else {
      result += char;
    }
  }
  return result.trim();
}
var import_obsidian;
var init_utils = __esm({
  "src/utils.ts"() {
    import_obsidian = require("obsidian");
    init_constants();
  }
});

// src/modals.ts
var modals_exports = {};
__export(modals_exports, {
  ClearSettingsModal: () => ClearSettingsModal,
  DisableEnableModal: () => DisableEnableModal,
  InternalLinkModal: () => InternalLinkModal,
  ProcessTagModal: () => ProcessTagModal,
  RenameAllFilesModal: () => RenameAllFilesModal,
  RenameFolderModal: () => RenameFolderModal,
  RenameModal: () => RenameModal
});
var import_obsidian2, RenameAllFilesModal, RenameFolderModal, ProcessTagModal, ClearSettingsModal, RenameModal, DisableEnableModal, InternalLinkModal;
var init_modals = __esm({
  "src/modals.ts"() {
    import_obsidian2 = require("obsidian");
    init_utils();
    RenameAllFilesModal = class extends import_obsidian2.Modal {
      constructor(app, plugin) {
        super(app);
        this.plugin = plugin;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        const heading = contentEl.createEl("h2", { text: "Caution", cls: "flit-modal-heading" });
        const allFiles = this.app.vault.getMarkdownFiles();
        const count = allFiles.length;
        const messagePara = contentEl.createEl("p");
        messagePara.appendText("This will process ");
        messagePara.createEl("strong", { text: `${count} ${count === 1 ? "note" : "notes"}` });
        messagePara.appendText(".");
        const ensureList = contentEl.createEl("p", { text: "Ensure:" });
        ensureList.style.marginTop = "10px";
        ensureList.style.marginBottom = "10px";
        const ul = contentEl.createEl("ul");
        ul.style.marginTop = "0";
        ul.style.paddingLeft = "20px";
        const li1 = ul.createEl("li");
        li1.appendText("Your files are ");
        li1.createEl("a", { text: "backed up", href: "https://help.obsidian.md/backup" });
        li1.appendText(" in case of errors.");
        ul.createEl("li", { text: "Excluded folders, tags and properties are configured correctly in plugin settings." });
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container flit-modal-button-container" });
        const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
        cancelButton.onclick = () => this.close();
        const renameButton = buttonContainer.createEl("button", { text: "Rename" });
        renameButton.addClass("mod-cta");
        renameButton.onclick = async () => {
          this.close();
          await this.renameAllFiles();
        };
      }
      async renameAllFiles() {
        let filesToRename = [];
        this.app.vault.getMarkdownFiles().forEach((file) => {
          if (shouldProcessFile(file, this.plugin.settings, this.app)) {
            filesToRename.push(file);
          }
        });
        filesToRename.sort((a, b) => a.stat.ctime - b.stat.ctime);
        verboseLog(this.plugin, `Showing notice: Renaming ${filesToRename.length} notes...`);
        const pleaseWaitNotice = new import_obsidian2.Notice(`Renaming ${filesToRename.length} notes...`, 0);
        verboseLog(this.plugin, `Starting bulk rename of ${filesToRename.length} files`);
        const exclusionOverrides = {
          ignoreFolder: true,
          ignoreTag: true,
          ignoreProperty: true
        };
        let renamedFileCount = 0;
        try {
          const errors = [];
          for (const file of filesToRename) {
            try {
              await this.plugin.renameEngine.processFile(file, true, true, void 0, true, exclusionOverrides);
              renamedFileCount++;
            } catch (error) {
              errors.push(`Failed to rename ${file.path}: ${error}`);
              console.error(`Error renaming ${file.path}`, error);
            }
          }
          if (errors.length > 0) {
            verboseLog(this.plugin, `Showing notice: Renamed ${renamedFileCount}/${filesToRename.length} notes with ${errors.length} errors. Check console for details.`);
            new import_obsidian2.Notice(`Renamed ${renamedFileCount}/${filesToRename.length} notes with ${errors.length} errors. Check console for details.`, 0);
            console.error("Rename errors:", errors);
          }
        } finally {
          if (this.plugin.cacheManager) {
            this.plugin.cacheManager.clearReservedPaths();
            verboseLog(this.plugin, "Cache cleaned up immediately after batch operation");
          }
          pleaseWaitNotice.hide();
          verboseLog(this.plugin, `Showing notice: Renamed ${renamedFileCount}/${filesToRename.length} notes.`);
          new import_obsidian2.Notice(`Renamed ${renamedFileCount}/${filesToRename.length} notes.`, 0);
          verboseLog(this.plugin, `Bulk rename completed: ${renamedFileCount}/${filesToRename.length} files renamed`);
        }
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    RenameFolderModal = class extends import_obsidian2.Modal {
      constructor(app, plugin, folder) {
        super(app);
        this.plugin = plugin;
        this.folder = folder;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        const heading = contentEl.createEl("h2", { text: "Caution", cls: "flit-modal-heading" });
        const folderFiles = this.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian2.TFile && f.extension === "md").filter((f) => {
          var _a;
          return f.path.startsWith(this.folder.path + "/") || ((_a = f.parent) == null ? void 0 : _a.path) === this.folder.path;
        });
        const count = folderFiles.length;
        const messagePara = contentEl.createEl("p");
        messagePara.appendText("This will process ");
        messagePara.createEl("strong", { text: `${count} ${count === 1 ? "note" : "notes"}` });
        messagePara.appendText(".");
        messagePara.createEl("br");
        messagePara.createEl("br");
        messagePara.appendText("Ensure your files are ");
        messagePara.createEl("a", { text: "backed up", href: "https://help.obsidian.md/backup" });
        messagePara.appendText(" in case of errors.");
        const optionsContainer = contentEl.createDiv({ cls: "flit-modal-options" });
        const subfoldersContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const subfoldersCheckbox = subfoldersContainer.createEl("input", { type: "checkbox" });
        subfoldersCheckbox.id = "rename-subfolders";
        subfoldersCheckbox.checked = this.plugin.settings.modalCheckboxStates.folderRename.includeSubfolders;
        const subfoldersLabel = subfoldersContainer.createEl("label");
        subfoldersLabel.setAttribute("for", "rename-subfolders");
        subfoldersLabel.textContent = "Rename notes in all subfolders";
        const excludedFoldersContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedFoldersCheckbox = excludedFoldersContainer.createEl("input", { type: "checkbox" });
        excludedFoldersCheckbox.id = "rename-excluded-folders";
        excludedFoldersCheckbox.checked = this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedFolders;
        const excludedFoldersLabel = excludedFoldersContainer.createEl("label");
        excludedFoldersLabel.setAttribute("for", "rename-excluded-folders");
        excludedFoldersLabel.textContent = "Rename notes in excluded folders";
        const excludedTagsContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedTagsCheckbox = excludedTagsContainer.createEl("input", { type: "checkbox" });
        excludedTagsCheckbox.id = "rename-excluded-tags";
        excludedTagsCheckbox.checked = this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedTags;
        const excludedTagsLabel = excludedTagsContainer.createEl("label");
        excludedTagsLabel.setAttribute("for", "rename-excluded-tags");
        excludedTagsLabel.textContent = "Rename notes with excluded tags";
        const excludedPropsContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedPropsCheckbox = excludedPropsContainer.createEl("input", { type: "checkbox" });
        excludedPropsCheckbox.id = "rename-excluded-properties";
        excludedPropsCheckbox.checked = this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedProperties;
        const excludedPropsLabel = excludedPropsContainer.createEl("label");
        excludedPropsLabel.setAttribute("for", "rename-excluded-properties");
        excludedPropsLabel.textContent = "Rename notes with excluded properties";
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container flit-modal-button-container" });
        const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
        cancelButton.onclick = () => this.close();
        const renameButton = buttonContainer.createEl("button", { text: "Rename" });
        renameButton.addClass("mod-cta");
        renameButton.onclick = async () => {
          this.plugin.settings.modalCheckboxStates.folderRename.includeSubfolders = subfoldersCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedFolders = excludedFoldersCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedTags = excludedTagsCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.folderRename.renameExcludedProperties = excludedPropsCheckbox.checked;
          await this.plugin.saveSettings();
          this.close();
          await this.renameFolderFiles(
            subfoldersCheckbox.checked,
            excludedFoldersCheckbox.checked,
            excludedTagsCheckbox.checked,
            excludedPropsCheckbox.checked
          );
        };
      }
      async renameFolderFiles(includeSubfolders, renameExcludedFolders, renameExcludedTags, renameExcludedProperties) {
        var _a, _b;
        const allFiles = this.app.vault.getMarkdownFiles();
        const filesToRename = [];
        for (const file of allFiles) {
          const isInFolder = ((_a = file.parent) == null ? void 0 : _a.path) === this.folder.path;
          const isInSubfolder = file.path.startsWith(this.folder.path + "/") && ((_b = file.parent) == null ? void 0 : _b.path) !== this.folder.path;
          if (!isInFolder && (!includeSubfolders || !isInSubfolder)) {
            continue;
          }
          filesToRename.push(file);
        }
        filesToRename.sort((a, b) => a.stat.ctime - b.stat.ctime);
        verboseLog(this.plugin, `Renaming ${filesToRename.length} notes...`);
        const pleaseWaitNotice = new import_obsidian2.Notice(`Renaming ${filesToRename.length} notes...`, 0);
        const exclusionOverrides = {
          ignoreFolder: renameExcludedFolders,
          ignoreTag: renameExcludedTags,
          ignoreProperty: renameExcludedProperties
        };
        let renamedFileCount = 0;
        try {
          for (const file of filesToRename) {
            try {
              await this.plugin.renameEngine.processFile(file, true, true, void 0, true, exclusionOverrides);
              renamedFileCount++;
            } catch (error) {
              console.error(`Error processing ${file.path}`, error);
            }
          }
        } finally {
          if (this.plugin.cacheManager) {
            this.plugin.cacheManager.clearReservedPaths();
          }
          pleaseWaitNotice.hide();
          verboseLog(this.plugin, `Renamed ${renamedFileCount}/${filesToRename.length} notes.`);
          new import_obsidian2.Notice(`Renamed ${renamedFileCount}/${filesToRename.length} notes.`, 0);
        }
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    ProcessTagModal = class extends import_obsidian2.Modal {
      constructor(app, plugin, tag) {
        super(app);
        this.plugin = plugin;
        this.tag = tag;
      }
      onOpen() {
        var _a;
        const { contentEl } = this;
        contentEl.empty();
        const heading = contentEl.createEl("h2", { text: "Caution", cls: "flit-modal-heading" });
        const allFiles = this.app.vault.getMarkdownFiles();
        let count = 0;
        for (const file of allFiles) {
          const cache = this.app.metadataCache.getFileCache(file);
          if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.tags) {
            const frontmatterTags = Array.isArray(cache.frontmatter.tags) ? cache.frontmatter.tags : [cache.frontmatter.tags];
            for (const tag of frontmatterTags) {
              const normalizedTag = tag.startsWith("#") ? tag.slice(1) : tag;
              if (normalizedTag === this.tag || normalizedTag.startsWith(`${this.tag}/`)) {
                count++;
                break;
              }
            }
          }
          if (cache == null ? void 0 : cache.tags) {
            for (const tagCache of cache.tags) {
              const normalizedTag = tagCache.tag.startsWith("#") ? tagCache.tag.slice(1) : tagCache.tag;
              if (normalizedTag === this.tag || normalizedTag.startsWith(`${this.tag}/`)) {
                count++;
                break;
              }
            }
          }
        }
        const messagePara = contentEl.createEl("p");
        messagePara.appendText("This will process ");
        messagePara.createEl("strong", { text: `${count} ${count === 1 ? "note" : "notes"}` });
        messagePara.appendText(".");
        messagePara.createEl("br");
        messagePara.createEl("br");
        messagePara.appendText("Ensure your files are ");
        messagePara.createEl("a", { text: "backed up", href: "https://help.obsidian.md/backup" });
        messagePara.appendText(" in case of errors.");
        const optionsContainer = contentEl.createDiv({ cls: "flit-modal-options" });
        const childTagsContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const childTagsCheckbox = childTagsContainer.createEl("input", { type: "checkbox" });
        childTagsCheckbox.id = "rename-child-tags";
        childTagsCheckbox.checked = this.plugin.settings.modalCheckboxStates.tagRename.includeChildTags;
        const childTagsLabel = childTagsContainer.createEl("label");
        childTagsLabel.setAttribute("for", "rename-child-tags");
        childTagsLabel.textContent = "Rename notes with child tags (e.g., #parent/child)";
        const excludedFoldersContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedFoldersCheckbox = excludedFoldersContainer.createEl("input", { type: "checkbox" });
        excludedFoldersCheckbox.id = "rename-excluded-folders";
        excludedFoldersCheckbox.checked = this.plugin.settings.modalCheckboxStates.tagRename.renameExcludedFolders;
        const excludedFoldersLabel = excludedFoldersContainer.createEl("label");
        excludedFoldersLabel.setAttribute("for", "rename-excluded-folders");
        excludedFoldersLabel.textContent = "Rename notes in excluded folders";
        const excludedTagsContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedTagsCheckbox = excludedTagsContainer.createEl("input", { type: "checkbox" });
        excludedTagsCheckbox.id = "rename-excluded-tags";
        excludedTagsCheckbox.checked = this.plugin.settings.modalCheckboxStates.tagRename.renameExcludedTags;
        const excludedTagsLabel = excludedTagsContainer.createEl("label");
        excludedTagsLabel.setAttribute("for", "rename-excluded-tags");
        excludedTagsLabel.textContent = "Rename notes with excluded tags";
        const excludedPropsContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedPropsCheckbox = excludedPropsContainer.createEl("input", { type: "checkbox" });
        excludedPropsCheckbox.id = "rename-excluded-properties";
        excludedPropsCheckbox.checked = this.plugin.settings.modalCheckboxStates.tagRename.renameExcludedProperties;
        const excludedPropsLabel = excludedPropsContainer.createEl("label");
        excludedPropsLabel.setAttribute("for", "rename-excluded-properties");
        excludedPropsLabel.textContent = "Rename notes with excluded properties";
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container flit-modal-button-container" });
        const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
        cancelButton.onclick = () => this.close();
        const renameButton = buttonContainer.createEl("button", { text: "Rename" });
        renameButton.addClass("mod-cta");
        renameButton.onclick = async () => {
          this.plugin.settings.modalCheckboxStates.tagRename.includeChildTags = childTagsCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.tagRename.renameExcludedFolders = excludedFoldersCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.tagRename.renameExcludedTags = excludedTagsCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.tagRename.renameExcludedProperties = excludedPropsCheckbox.checked;
          await this.plugin.saveSettings();
          this.close();
          await this.processTagFiles(
            childTagsCheckbox.checked,
            excludedFoldersCheckbox.checked,
            excludedTagsCheckbox.checked,
            excludedPropsCheckbox.checked
          );
        };
      }
      async processTagFiles(includeChildTags, renameExcludedFolders, renameExcludedTags, renameExcludedProperties) {
        var _a;
        const filesToProcess = [];
        const allFiles = this.app.vault.getMarkdownFiles();
        for (const file of allFiles) {
          let hasMatchingTag = false;
          const cache = this.app.metadataCache.getFileCache(file);
          if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.tags) {
            const frontmatterTags = Array.isArray(cache.frontmatter.tags) ? cache.frontmatter.tags : [cache.frontmatter.tags];
            for (const tag of frontmatterTags) {
              const normalizedTag = tag.startsWith("#") ? tag.slice(1) : tag;
              if (normalizedTag === this.tag) {
                hasMatchingTag = true;
                break;
              }
              if (includeChildTags && normalizedTag.startsWith(`${this.tag}/`)) {
                hasMatchingTag = true;
                break;
              }
            }
          }
          if (!hasMatchingTag && (cache == null ? void 0 : cache.tags)) {
            for (const tagCache of cache.tags) {
              const normalizedTag = tagCache.tag.startsWith("#") ? tagCache.tag.slice(1) : tagCache.tag;
              if (normalizedTag === this.tag) {
                hasMatchingTag = true;
                break;
              }
              if (includeChildTags && normalizedTag.startsWith(`${this.tag}/`)) {
                hasMatchingTag = true;
                break;
              }
            }
          }
          if (!hasMatchingTag) {
            continue;
          }
          filesToProcess.push(file);
        }
        if (filesToProcess.length === 0) {
          verboseLog(this.plugin, `No notes found with ${this.tag}`);
          new import_obsidian2.Notice(`No notes found with #${this.tag}.`);
          return;
        }
        filesToProcess.sort((a, b) => a.stat.ctime - b.stat.ctime);
        verboseLog(this.plugin, `Renaming ${filesToProcess.length} files with tag ${this.tag}...`);
        const pleaseWaitNotice = new import_obsidian2.Notice(`Renaming ${filesToProcess.length} notes...`, 0);
        let renamedCount = 0;
        const exclusionOverrides = {
          ignoreFolder: renameExcludedFolders,
          ignoreTag: renameExcludedTags,
          ignoreProperty: renameExcludedProperties
        };
        try {
          for (const file of filesToProcess) {
            try {
              await this.plugin.renameEngine.processFile(file, true, true, void 0, true, exclusionOverrides);
              renamedCount++;
            } catch (error) {
              console.error(`Error processing ${file.path}`, error);
            }
          }
        } finally {
          if (this.plugin.cacheManager) {
            this.plugin.cacheManager.clearReservedPaths();
          }
          pleaseWaitNotice.hide();
          verboseLog(this.plugin, `Renamed ${renamedCount}/${filesToProcess.length} files with tag ${this.tag}`);
          new import_obsidian2.Notice(`Renamed ${renamedCount}/${filesToProcess.length} notes.`, 0);
        }
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    ClearSettingsModal = class extends import_obsidian2.Modal {
      constructor(app, plugin, onConfirm) {
        super(app);
        this.plugin = plugin;
        this.onConfirm = onConfirm;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        const heading = contentEl.createEl("h2", { text: "Warning", cls: "flit-modal-heading" });
        contentEl.createEl("p", {
          text: "This will reset all plugin settings to their default values and delete all custom rules. This cannot be undone."
        });
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container flit-modal-button-container" });
        const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
        cancelButton.onclick = () => this.close();
        const clearButton = buttonContainer.createEl("button", { text: "Clear settings" });
        clearButton.addClass("mod-warning");
        clearButton.onclick = async () => {
          this.close();
          await this.onConfirm();
        };
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    RenameModal = class extends import_obsidian2.Modal {
      constructor(app, plugin, files) {
        super(app);
        this.plugin = plugin;
        this.files = files;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        const heading = contentEl.createEl("h2", { text: "Caution", cls: "flit-modal-heading" });
        const count = this.files.length;
        const messagePara = contentEl.createEl("p");
        messagePara.appendText("This will process ");
        messagePara.createEl("strong", { text: `${count} ${count === 1 ? "note" : "notes"}` });
        messagePara.appendText(".");
        messagePara.createEl("br");
        messagePara.createEl("br");
        messagePara.appendText("Ensure your files are ");
        messagePara.createEl("a", { text: "backed up", href: "https://help.obsidian.md/backup" });
        messagePara.appendText(" in case of errors.");
        const optionsContainer = contentEl.createDiv({ cls: "flit-modal-options" });
        const excludedFoldersContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedFoldersCheckbox = excludedFoldersContainer.createEl("input", { type: "checkbox" });
        excludedFoldersCheckbox.id = "rename-excluded-folders";
        excludedFoldersCheckbox.checked = this.plugin.settings.modalCheckboxStates.searchRename.renameExcludedFolders;
        const excludedFoldersLabel = excludedFoldersContainer.createEl("label");
        excludedFoldersLabel.setAttribute("for", "rename-excluded-folders");
        excludedFoldersLabel.textContent = "Rename notes in excluded folders";
        const excludedTagsContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedTagsCheckbox = excludedTagsContainer.createEl("input", { type: "checkbox" });
        excludedTagsCheckbox.id = "rename-excluded-tags";
        excludedTagsCheckbox.checked = this.plugin.settings.modalCheckboxStates.searchRename.renameExcludedTags;
        const excludedTagsLabel = excludedTagsContainer.createEl("label");
        excludedTagsLabel.setAttribute("for", "rename-excluded-tags");
        excludedTagsLabel.textContent = "Rename notes with excluded tags";
        const excludedPropsContainer = optionsContainer.createDiv({ cls: "flit-checkbox-container" });
        const excludedPropsCheckbox = excludedPropsContainer.createEl("input", { type: "checkbox" });
        excludedPropsCheckbox.id = "rename-excluded-properties";
        excludedPropsCheckbox.checked = this.plugin.settings.modalCheckboxStates.searchRename.renameExcludedProperties;
        const excludedPropsLabel = excludedPropsContainer.createEl("label");
        excludedPropsLabel.setAttribute("for", "rename-excluded-properties");
        excludedPropsLabel.textContent = "Rename notes with excluded properties";
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container flit-modal-button-container" });
        const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
        cancelButton.onclick = () => this.close();
        const renameButton = buttonContainer.createEl("button", { text: "Rename" });
        renameButton.addClass("mod-cta");
        renameButton.onclick = async () => {
          this.plugin.settings.modalCheckboxStates.searchRename.renameExcludedFolders = excludedFoldersCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.searchRename.renameExcludedTags = excludedTagsCheckbox.checked;
          this.plugin.settings.modalCheckboxStates.searchRename.renameExcludedProperties = excludedPropsCheckbox.checked;
          await this.plugin.saveSettings();
          this.close();
          await this.renameFiles(
            excludedFoldersCheckbox.checked,
            excludedTagsCheckbox.checked,
            excludedPropsCheckbox.checked
          );
        };
      }
      async renameFiles(renameExcludedFolders, renameExcludedTags, renameExcludedProperties) {
        const filesToProcess = [...this.files];
        filesToProcess.sort((a, b) => a.stat.ctime - b.stat.ctime);
        verboseLog(this.plugin, `Renaming ${filesToProcess.length} notes...`);
        const pleaseWaitNotice = new import_obsidian2.Notice(`Renaming ${filesToProcess.length} notes...`, 0);
        const exclusionOverrides = {
          ignoreFolder: renameExcludedFolders,
          ignoreTag: renameExcludedTags,
          ignoreProperty: renameExcludedProperties
        };
        let renamedFileCount = 0;
        try {
          for (const file of filesToProcess) {
            try {
              await this.plugin.renameEngine.processFile(file, true, true, void 0, true, exclusionOverrides);
              renamedFileCount++;
            } catch (error) {
              console.error(`Error processing ${file.path}`, error);
            }
          }
        } finally {
          if (this.plugin.cacheManager) {
            this.plugin.cacheManager.clearReservedPaths();
          }
          pleaseWaitNotice.hide();
          verboseLog(this.plugin, `Renamed ${renamedFileCount}/${filesToProcess.length} notes.`);
          new import_obsidian2.Notice(`Renamed ${renamedFileCount}/${filesToProcess.length} notes.`, 0);
        }
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    DisableEnableModal = class extends import_obsidian2.Modal {
      constructor(app, plugin, files, action) {
        super(app);
        this.plugin = plugin;
        this.files = files;
        this.action = action;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        const heading = contentEl.createEl("h2", { text: "Caution", cls: "flit-modal-heading" });
        const key = this.plugin.settings.disableRenamingKey;
        const value = this.plugin.settings.disableRenamingValue;
        const count = this.files.length;
        const actionText = this.action === "disable" ? "add" : "remove";
        const messagePara = contentEl.createEl("p");
        messagePara.appendText(`This will ${actionText} the `);
        messagePara.createEl("strong", { text: `${key}:${value}` });
        messagePara.appendText(" property in ");
        messagePara.createEl("strong", { text: `${count} ${count === 1 ? "note" : "notes"}` });
        messagePara.appendText(".");
        messagePara.createEl("br");
        messagePara.createEl("br");
        messagePara.appendText("Ensure your files are ");
        messagePara.createEl("a", { text: "backed up", href: "https://help.obsidian.md/backup" });
        messagePara.appendText(" in case of errors.");
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container flit-modal-button-container" });
        const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
        cancelButton.onclick = () => this.close();
        const actionButton = buttonContainer.createEl("button", { text: this.action === "disable" ? "Disable" : "Enable" });
        actionButton.addClass("mod-cta");
        actionButton.onclick = async () => {
          this.close();
          await this.processFiles();
        };
      }
      async processFiles() {
        const filesToProcess = [...this.files];
        filesToProcess.sort((a, b) => a.stat.ctime - b.stat.ctime);
        if (this.action === "disable") {
          await this.plugin.propertyManager.ensurePropertyTypeIsCheckbox();
        }
        verboseLog(this.plugin, `Renaming ${filesToProcess.length} notes...`);
        const pleaseWaitNotice = new import_obsidian2.Notice(`Renaming ${filesToProcess.length} notes...`, 0);
        let processedCount = 0;
        const key = this.plugin.settings.disableRenamingKey;
        const value = this.plugin.settings.disableRenamingValue;
        try {
          for (const file of filesToProcess) {
            try {
              await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
                if (this.action === "disable") {
                  frontmatter[key] = value;
                } else {
                  delete frontmatter[key];
                }
              });
              processedCount++;
            } catch (error) {
              console.error(`Error processing ${file.path}`, error);
            }
          }
        } finally {
          pleaseWaitNotice.hide();
          const actionPast = this.action === "disable" ? "Disabled" : "Enabled";
          verboseLog(this.plugin, `${actionPast} renaming in ${processedCount} notes.`);
          new import_obsidian2.Notice(`${actionPast} renaming for ${processedCount} notes.`);
        }
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    InternalLinkModal = class extends import_obsidian2.Modal {
      constructor(app, plugin, onSubmit, withCaption = false) {
        super(app);
        this.plugin = plugin;
        this.onSubmit = onSubmit;
        this.withCaption = withCaption;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h3", { text: "Internal link", cls: "flit-modal-heading-left" });
        const inputContainer = contentEl.createDiv({ cls: "flit-input-container" });
        const textInput = inputContainer.createEl("input", {
          type: "text",
          placeholder: "Enter text...",
          cls: "flit-link-input-full"
        });
        textInput.focus();
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container flit-modal-button-container" });
        const addButton = buttonContainer.createEl("button", { text: "Add" });
        addButton.addClass("mod-cta");
        const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
        cancelButton.onclick = () => this.close();
        const handleSubmit = () => {
          const inputText = textInput.value.trim();
          if (inputText) {
            this.close();
            this.onSubmit(inputText, this.withCaption ? inputText : void 0);
          }
        };
        addButton.onclick = handleSubmit;
        textInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            handleSubmit();
          }
        });
        contentEl.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            e.preventDefault();
            this.close();
          }
        });
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FirstLineIsTitle
});
module.exports = __toCommonJS(main_exports);
var import_obsidian26 = require("obsidian");
init_constants();
init_utils();
init_modals();

// src/settings/settings-main.ts
var import_obsidian13 = require("obsidian");

// src/settings/tab-general.ts
var import_obsidian3 = require("obsidian");

// src/settings/settings-base.ts
init_constants();
init_utils();
var SettingsTabBase = class {
  constructor(plugin, containerEl) {
    this.plugin = plugin;
    this.containerEl = containerEl;
  }
  /**
   * Updates the interactive state of all elements within a container
   * @param container - The container element
   * @param enabled - Whether elements should be enabled (true) or disabled (false)
   */
  updateInteractiveState(container, enabled) {
    if (enabled) {
      container.classList.remove("flit-master-disabled");
      container.removeAttribute("inert");
      const interactiveElements = container.querySelectorAll("input, button, a, select, .dropdown, textarea");
      interactiveElements.forEach((el) => {
        if (el.getAttribute("data-original-tabindex") !== null) {
          const originalTabIndex = el.getAttribute("data-original-tabindex");
          if (originalTabIndex === "remove") {
            el.removeAttribute("tabindex");
          } else {
            el.tabIndex = parseInt(originalTabIndex || "0");
          }
          el.removeAttribute("data-original-tabindex");
        }
        el.removeAttribute("aria-disabled");
        el.style.pointerEvents = "";
      });
      this.updateDisabledRowsAccessibility(container);
    } else {
      container.classList.add("flit-master-disabled");
      container.setAttribute("inert", "");
      const interactiveElements = container.querySelectorAll("input, button, a, select, .dropdown, textarea");
      interactiveElements.forEach((el) => {
        if (el.hasAttribute("tabindex")) {
          el.setAttribute("data-original-tabindex", el.getAttribute("tabindex") || "0");
        } else {
          el.setAttribute("data-original-tabindex", "remove");
        }
        el.tabIndex = -1;
        el.setAttribute("aria-disabled", "true");
        el.style.pointerEvents = "none";
      });
    }
  }
  /**
   * Updates accessibility for disabled rows (removes them from tab order)
   * @param container - The container element to search for disabled rows
   */
  updateDisabledRowsAccessibility(container) {
    const disabledRows = container.querySelectorAll(".flit-row-disabled");
    disabledRows.forEach((row) => {
      const interactiveElements = row.querySelectorAll("input, button, a, select, .dropdown, textarea");
      interactiveElements.forEach((el) => {
        if (el.closest(".flit-enable-column") || el.closest(".flit-actions-column")) {
          return;
        }
        el.tabIndex = -1;
        el.setAttribute("aria-disabled", "true");
      });
    });
  }
  addForbiddenCharProtection(inputElement, forceWindowsAndroidProtection = false) {
    inputElement.addEventListener("input", (e) => {
      const inputEl = e.target;
      let value = inputEl.value;
      const universalForbidden = UNIVERSAL_FORBIDDEN_CHARS;
      const windowsAndroidForbidden = WINDOWS_ANDROID_CHARS;
      let forbiddenChars = [...universalForbidden];
      if (forceWindowsAndroidProtection) {
        forbiddenChars.push(...windowsAndroidForbidden);
      } else {
        const currentOS = detectOS();
        if (currentOS === "Windows") {
          forbiddenChars.push(...windowsAndroidForbidden);
        }
      }
      let filteredValue = "";
      for (let i = 0; i < value.length; i++) {
        const char = value[i];
        if (char === "." && i === 0) {
          continue;
        }
        if (forbiddenChars.includes(char)) {
          continue;
        }
        filteredValue += char;
      }
      if (filteredValue !== value) {
        inputEl.value = filteredValue;
        const cursorPos = Math.min(inputEl.selectionStart || 0, filteredValue.length);
        inputEl.setSelectionRange(cursorPos, cursorPos);
        inputEl.dispatchEvent(new Event("input", { bubbles: true }));
      }
    });
  }
};

// src/settings/tab-general.ts
init_modals();
var GeneralTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
  }
  render() {
    let renameOnFocusContainer;
    let placeCursorSetting;
    let waitForTemplateCursorSetting;
    const updateAutomaticRenameVisibility = () => {
      if (this.plugin.settings.renameNotes === "automatically") {
        renameOnFocusContainer.show();
        updateCursorOptionsVisibility();
      } else {
        renameOnFocusContainer.hide();
      }
    };
    const renameNotesSetting = new import_obsidian3.Setting(this.containerEl).setName("Rename notes").setDesc("");
    const renameNotesDesc = renameNotesSetting.descEl;
    renameNotesDesc.appendText("Set how notes should be processed.");
    renameNotesSetting.addDropdown(
      (dropdown) => dropdown.addOption("automatically", "Automatically when open and modified").addOption("manually", "Manually with command only").setValue(this.plugin.settings.renameNotes).onChange(async (value) => {
        var _a, _b;
        this.plugin.settings.renameNotes = value;
        this.plugin.debugLog("renameNotes", value);
        await this.plugin.saveSettings();
        updateAutomaticRenameVisibility();
        (_b = (_a = this.plugin).updateAutomaticRenameVisibility) == null ? void 0 : _b.call(_a);
      })
    );
    const automaticRenameContainer = this.containerEl.createDiv("flit-sub-settings");
    const renameOnFocusSetting = new import_obsidian3.Setting(automaticRenameContainer).setName("Rename on focus").setDesc("Also process notes when they get opened in the editor.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.renameOnFocus).onChange(async (value) => {
        this.plugin.settings.renameOnFocus = value;
        this.plugin.debugLog("renameOnFocus", value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(automaticRenameContainer).setName("Move cursor to first line").setDesc("Place the cursor in the first line when creating a new note unless in excluded note.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.moveCursorToFirstLine).onChange(async (value) => {
        this.plugin.settings.moveCursorToFirstLine = value;
        this.plugin.debugLog("moveCursorToFirstLine", value);
        await this.plugin.saveSettings();
        updateCursorOptionsVisibility();
      })
    );
    const cursorOptionsContainer = automaticRenameContainer.createDiv("flit-sub-settings");
    placeCursorSetting = new import_obsidian3.Setting(cursorOptionsContainer).setName("Place cursor at line end").setDesc("When moving the cursor to a first line with content, place it at the end of the line instead of the start.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.placeCursorAtLineEnd).onChange(async (value) => {
        this.plugin.settings.placeCursorAtLineEnd = value;
        this.plugin.debugLog("placeCursorAtLineEnd", value);
        await this.plugin.saveSettings();
      })
    );
    waitForTemplateCursorSetting = new import_obsidian3.Setting(cursorOptionsContainer).setName("Wait for template").setDesc("Move the cursor after a new note template is applied and it does not have an excluded tag or property.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.waitForCursorTemplate).onChange(async (value) => {
        this.plugin.settings.waitForCursorTemplate = value;
        this.plugin.debugLog("waitForCursorTemplate", value);
        await this.plugin.saveSettings();
      })
    );
    const updateCursorOptionsVisibility = () => {
      if (this.plugin.settings.moveCursorToFirstLine) {
        cursorOptionsContainer.show();
      } else {
        cursorOptionsContainer.hide();
      }
    };
    updateCursorOptionsVisibility();
    renameOnFocusContainer = automaticRenameContainer;
    updateAutomaticRenameVisibility();
    new import_obsidian3.Setting(this.containerEl).setName("What to put in title").setDesc("Set what first line content should be copied to filename.").addDropdown(
      (dropdown) => dropdown.addOption("any_first_line_content", "Any text").addOption("headings_only", "Headings only").setValue(this.plugin.settings.whatToPutInTitle).onChange(async (value) => {
        this.plugin.settings.whatToPutInTitle = value;
        this.plugin.debugLog("whatToPutInTitle", value);
        await this.plugin.saveSettings();
      })
    );
    let waitForTemplateContainer;
    const updateWaitForTemplateVisibility = () => {
      if (this.plugin.settings.insertTitleOnCreation) {
        waitForTemplateContainer.show();
      } else {
        waitForTemplateContainer.hide();
      }
    };
    const insertTitleSetting = new import_obsidian3.Setting(this.containerEl).setName("Insert title in first line on note creation").setDesc("");
    const insertTitleDesc = insertTitleSetting.descEl;
    insertTitleDesc.appendText("Place the filename in the first line when creating a new empty note (unless ");
    insertTitleDesc.createEl("em", { text: "Untitled" });
    insertTitleDesc.appendText("). Convert forbidden character replacements back to their original forms, as set in ");
    insertTitleDesc.createEl("em", { text: "Replace characters" });
    insertTitleDesc.appendText(".");
    insertTitleSetting.addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.insertTitleOnCreation).onChange(async (value) => {
        this.plugin.settings.insertTitleOnCreation = value;
        this.plugin.debugLog("insertTitleOnCreation", value);
        await this.plugin.saveSettings();
        updateWaitForTemplateVisibility();
      })
    );
    waitForTemplateContainer = this.containerEl.createDiv("flit-sub-settings");
    const waitForTemplateSetting = new import_obsidian3.Setting(waitForTemplateContainer).setName("Insert after template").setDesc("Let a new note template insert a Properties block before inserting the filename.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.waitForTemplate).onChange(async (value) => {
        this.plugin.settings.waitForTemplate = value;
        this.plugin.debugLog("waitForTemplate", value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(waitForTemplateContainer).setName("Format as heading").setDesc("Make the first line a heading.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.addHeadingToTitle).onChange(async (value) => {
        this.plugin.settings.addHeadingToTitle = value;
        this.plugin.debugLog("addHeadingToTitle", value);
        await this.plugin.saveSettings();
      })
    );
    updateWaitForTemplateVisibility();
    new import_obsidian3.Setting(this.containerEl).setName("Rename on save").setDesc("Rename notes on manual save (Ctrl/Cmd-S on desktop by default).").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.renameOnSave).onChange(async (value) => {
        this.plugin.settings.renameOnSave = value;
        this.plugin.debugLog("renameOnSave", value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(this.containerEl).setName("Rename all notes").setDesc("Process all notes in vault. Can also be run from the Command palette.").addButton(
      (button2) => button2.setButtonText("Rename").onClick(() => {
        new RenameAllFilesModal(this.plugin.app, this.plugin).open();
      })
    );
    const feedbackContainer = this.containerEl.createEl("div");
    feedbackContainer.style.cssText = `
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            margin: 20px 0;
            padding: 4px 0;
            overflow: visible;
        `;
    const button = feedbackContainer.createEl("button", {
      cls: "mod-cta flit-leave-feedback-button"
    });
    button.style.display = "flex";
    button.style.alignItems = "center";
    button.style.gap = "8px";
    button.addEventListener("click", () => {
      window.open("https://github.com/greetclammy/first-line-is-title/issues", "_blank");
    });
    const iconDiv = button.createEl("div");
    (0, import_obsidian3.setIcon)(iconDiv, "message-square-reply");
    button.appendText("Leave feedback");
  }
};

// src/settings/tab-exclusions.ts
var import_obsidian5 = require("obsidian");

// src/suggests.ts
var import_obsidian4 = require("obsidian");
var FolderSuggest = class extends import_obsidian4.AbstractInputSuggest {
  constructor(app, inputEl, onSelectCallback) {
    super(app, inputEl);
    this.inputEl = inputEl;
    this.onSelectCallback = onSelectCallback;
  }
  getSuggestions(query) {
    const folders = this.app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian4.TFolder);
    if (!query) {
      return folders.slice(0, 10);
    }
    const lowerQuery = query.toLowerCase();
    return folders.filter(
      (folder) => folder.path.toLowerCase().includes(lowerQuery)
    ).slice(0, 10);
  }
  renderSuggestion(folder, el) {
    el.setText(folder.path);
  }
  selectSuggestion(folder, evt) {
    this.onSelectCallback(folder.path);
    this.inputEl.value = folder.path;
    this.inputEl.trigger("input");
    this.close();
  }
};
var TagSuggest = class extends import_obsidian4.AbstractInputSuggest {
  constructor(app, inputEl, onSelectCallback) {
    super(app, inputEl);
    this.inputEl = inputEl;
    this.onSelectCallback = onSelectCallback;
  }
  getSuggestions(query) {
    const allTags = Object.keys(this.app.metadataCache.getTags());
    if (!query) {
      return allTags.slice(0, 10);
    }
    const lowerQuery = query.toLowerCase();
    return allTags.filter(
      (tag) => tag.toLowerCase().includes(lowerQuery)
    ).slice(0, 10);
  }
  renderSuggestion(tag, el) {
    el.setText(tag);
  }
  selectSuggestion(tag, evt) {
    this.onSelectCallback(tag);
    this.inputEl.value = tag;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/settings/tab-exclusions.ts
init_constants();
var IncludeExcludeTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
  }
  async render() {
    const tabDesc = this.containerEl.createEl("div", { cls: "setting-item-description" });
    tabDesc.createEl("strong", { text: "Set how notes should be excluded from processing." });
    tabDesc.style.marginBottom = "15px";
    const importantNote = this.containerEl.createEl("p", { cls: "setting-item-description" });
    importantNote.appendText("Note: rules don't override other rules. For example, a note in excluded folder but with included tag will not be processed.");
    importantNote.style.marginBottom = "15px";
    await this.checkFirstTimeExclusionsSetup();
    const foldersHeaderSetting = new import_obsidian5.Setting(this.containerEl).setName("Folders").setDesc("Set folders to match.");
    foldersHeaderSetting.settingEl.addClass("flit-master-toggle");
    const folderNote = this.containerEl.createEl("p", { cls: "setting-item-description" });
    folderNote.style.marginTop = "15px";
    folderNote.style.marginBottom = "15px";
    folderNote.textContent = "Renamed, moved or deleted folders are not reflected below. Update manually if paths change.";
    const subfolderSetting = new import_obsidian5.Setting(this.containerEl).setName("Match subfolders").setDesc("Also apply to all subfolders of folders listed below.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.excludeSubfolders).onChange(async (value) => {
        this.plugin.settings.excludeSubfolders = value;
        this.plugin.debugLog("excludeSubfolders", value);
        await this.plugin.saveSettings();
      })
    );
    subfolderSetting.settingEl.style.borderTop = "none";
    const folderModeSetting = new import_obsidian5.Setting(this.containerEl).setName("Exclusion mode").setDesc("Set how folders should be excluded.").addDropdown(
      (dropdown) => dropdown.addOption("Only exclude...", "Only exclude...").addOption("Exclude all except...", "Exclude all except...").setValue(this.plugin.settings.folderScopeStrategy).onChange(async (value) => {
        this.plugin.settings.folderScopeStrategy = value;
        this.plugin.debugLog("folderScopeStrategy", value);
        await this.plugin.saveSettings();
      })
    );
    const folderContainer = this.containerEl.createDiv();
    const renderExcludedFolders = () => {
      folderContainer.empty();
      let addButton;
      this.plugin.settings.excludedFolders.forEach((folder, index) => {
        const folderSetting = new import_obsidian5.Setting(folderContainer);
        let textInput;
        let removeButton;
        const updateButtonState = () => {
          const isLastEmptyEntry = this.plugin.settings.excludedFolders.length === 1 && this.plugin.settings.excludedFolders[0].trim() === "";
          if (isLastEmptyEntry) {
            removeButton.setDisabled(true);
            removeButton.extraSettingsEl.style.opacity = "0.5";
            removeButton.extraSettingsEl.style.pointerEvents = "none";
            removeButton.extraSettingsEl.removeAttribute("aria-label");
            removeButton.extraSettingsEl.title = "";
          } else {
            removeButton.setDisabled(false);
            removeButton.extraSettingsEl.style.opacity = "1";
            removeButton.extraSettingsEl.style.pointerEvents = "auto";
            removeButton.setTooltip("Remove");
          }
        };
        folderSetting.addText((text) => {
          textInput = text;
          text.setPlaceholder("Folder name").setValue(folder).onChange(async (value) => {
            this.plugin.settings.excludedFolders[index] = value;
            this.plugin.debugLog("excludedFolders", this.plugin.settings.excludedFolders);
            await this.plugin.saveSettings();
            updateButtonState();
          });
          text.inputEl.style.width = "100%";
          try {
            new FolderSuggest(this.plugin.app, text.inputEl, async (selectedPath) => {
              this.plugin.settings.excludedFolders[index] = selectedPath;
              this.plugin.debugLog("excludedFolders", this.plugin.settings.excludedFolders);
              await this.plugin.saveSettings();
              updateButtonState();
            });
          } catch (error) {
            console.error("Failed to create FolderSuggest:", error);
          }
        }).addExtraButton((button) => {
          removeButton = button;
          button.setIcon("x");
          button.onClick(async () => {
            const isLastEmptyEntry = this.plugin.settings.excludedFolders.length === 1 && this.plugin.settings.excludedFolders[0].trim() === "";
            if (!isLastEmptyEntry) {
              this.plugin.settings.excludedFolders.splice(index, 1);
              if (this.plugin.settings.excludedFolders.length === 0) {
                this.plugin.settings.excludedFolders.push("");
              }
              await this.plugin.saveSettings();
              renderExcludedFolders();
            }
          });
          updateButtonState();
        });
        folderSetting.settingEl.addClass("flit-excluded-folder-setting");
      });
      const addButtonSetting = new import_obsidian5.Setting(folderContainer).addButton((button) => {
        button.setButtonText("Add folder").onClick(async () => {
          const isBottomEntryEmpty = this.plugin.settings.excludedFolders.length > 0 && this.plugin.settings.excludedFolders[this.plugin.settings.excludedFolders.length - 1].trim() === "";
          if (isBottomEntryEmpty) {
            const textInputs = folderContainer.querySelectorAll('input[type="text"]');
            if (textInputs.length > 0) {
              const lastInput = textInputs[textInputs.length - 1];
              lastInput.focus();
            }
          } else {
            this.plugin.settings.excludedFolders.push("");
            await this.plugin.saveSettings();
            renderExcludedFolders();
            setTimeout(() => {
              const textInputs = folderContainer.querySelectorAll('input[type="text"]');
              if (textInputs.length > 0) {
                const lastInput = textInputs[textInputs.length - 1];
                lastInput.focus();
              }
            }, 0);
          }
        });
      });
      addButtonSetting.settingEl.addClass("flit-add-folder-button");
    };
    renderExcludedFolders();
    const tagsHeaderSetting = new import_obsidian5.Setting(this.containerEl).setName("Tags").setDesc("Set tags to match.");
    tagsHeaderSetting.settingEl.addClass("flit-master-toggle");
    const tagNotes = this.containerEl.createEl("div", { cls: "setting-item-description" });
    tagNotes.style.marginTop = "15px";
    tagNotes.style.marginBottom = "15px";
    const tagUl = tagNotes.createEl("ul");
    tagUl.style.margin = "0";
    tagUl.style.paddingLeft = "20px";
    const tagLi1 = tagUl.createEl("li");
    tagLi1.createEl("em", { text: "Exclude all except..." });
    tagLi1.appendText(" also excludes notes with no tags.");
    const tagLi2 = tagUl.createEl("li");
    tagLi2.appendText("Tags renamed with ");
    tagLi2.createEl("a", {
      text: "Tag Wrangler",
      href: "obsidian://show-plugin?id=tag-wrangler"
    });
    tagLi2.appendText(" are not reflected below. Update manually after renaming.");
    const tagMatchingSetting = new import_obsidian5.Setting(this.containerEl).setName("Match tags").setDesc("Set where tags should be matched.").addDropdown(
      (dropdown) => dropdown.addOption("In Properties and note body", "In Properties and note body").addOption("In Properties only", "In Properties only").addOption("In note body only", "In note body only").setValue(this.plugin.settings.tagMatchingMode).onChange(async (value) => {
        this.plugin.settings.tagMatchingMode = value;
        this.plugin.debugLog("tagMatchingMode", value);
        await this.plugin.saveSettings();
      })
    );
    tagMatchingSetting.settingEl.style.borderTop = "none";
    const childTagsSetting = new import_obsidian5.Setting(this.containerEl).setName("Match child tags").setDesc("For example, also match #parent/child if #parent is listed below.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.excludeChildTags).onChange(async (value) => {
        this.plugin.settings.excludeChildTags = value;
        this.plugin.debugLog("excludeChildTags", value);
        await this.plugin.saveSettings();
      })
    );
    const tagModeSetting = new import_obsidian5.Setting(this.containerEl).setName("Exclusion mode").setDesc("Set how tags should be excluded.").addDropdown(
      (dropdown) => dropdown.addOption("Only exclude...", "Only exclude...").addOption("Exclude all except...", "Exclude all except...").setValue(this.plugin.settings.tagScopeStrategy).onChange(async (value) => {
        this.plugin.settings.tagScopeStrategy = value;
        this.plugin.debugLog("tagScopeStrategy", value);
        await this.plugin.saveSettings();
      })
    );
    const tagContainer = this.containerEl.createDiv();
    const renderExcludedTags = () => {
      tagContainer.empty();
      let addTagButton;
      this.plugin.settings.excludedTags.forEach((tag, index) => {
        const tagSetting = new import_obsidian5.Setting(tagContainer);
        let textInput;
        let removeButton;
        const updateButtonState = () => {
          const isLastEmptyEntry = this.plugin.settings.excludedTags.length === 1 && this.plugin.settings.excludedTags[0].trim() === "";
          if (isLastEmptyEntry) {
            removeButton.setDisabled(true);
            removeButton.extraSettingsEl.style.opacity = "0.5";
            removeButton.extraSettingsEl.style.pointerEvents = "none";
            removeButton.extraSettingsEl.removeAttribute("aria-label");
            removeButton.extraSettingsEl.title = "";
          } else {
            removeButton.setDisabled(false);
            removeButton.extraSettingsEl.style.opacity = "1";
            removeButton.extraSettingsEl.style.pointerEvents = "auto";
            removeButton.setTooltip("Remove");
          }
        };
        tagSetting.addText((text) => {
          textInput = text;
          text.setPlaceholder("Tag name").setValue(tag).onChange(async (value) => {
            this.plugin.settings.excludedTags[index] = value;
            this.plugin.debugLog("excludedTags", this.plugin.settings.excludedTags);
            await this.plugin.saveSettings();
            updateButtonState();
          });
          text.inputEl.style.width = "100%";
          try {
            new TagSuggest(this.plugin.app, text.inputEl, async (selectedTag) => {
              this.plugin.settings.excludedTags[index] = selectedTag;
              this.plugin.debugLog("excludedTags", this.plugin.settings.excludedTags);
              await this.plugin.saveSettings();
              updateButtonState();
            });
          } catch (error) {
            console.error("Failed to create TagSuggest:", error);
          }
        }).addExtraButton((button) => {
          removeButton = button;
          button.setIcon("x");
          button.onClick(async () => {
            const isLastEmptyEntry = this.plugin.settings.excludedTags.length === 1 && this.plugin.settings.excludedTags[0].trim() === "";
            if (!isLastEmptyEntry) {
              this.plugin.settings.excludedTags.splice(index, 1);
              if (this.plugin.settings.excludedTags.length === 0) {
                this.plugin.settings.excludedTags.push("");
              }
              await this.plugin.saveSettings();
              renderExcludedTags();
            }
          });
          updateButtonState();
        });
        tagSetting.settingEl.addClass("flit-excluded-folder-setting");
      });
      const addTagButtonSetting = new import_obsidian5.Setting(tagContainer).addButton((button) => {
        button.setButtonText("Add tag").onClick(async () => {
          const isBottomEntryEmpty = this.plugin.settings.excludedTags.length > 0 && this.plugin.settings.excludedTags[this.plugin.settings.excludedTags.length - 1].trim() === "";
          if (isBottomEntryEmpty) {
            const textInputs = tagContainer.querySelectorAll('input[type="text"]');
            if (textInputs.length > 0) {
              const lastInput = textInputs[textInputs.length - 1];
              lastInput.focus();
            }
          } else {
            this.plugin.settings.excludedTags.push("");
            await this.plugin.saveSettings();
            renderExcludedTags();
            setTimeout(() => {
              const textInputs = tagContainer.querySelectorAll('input[type="text"]');
              if (textInputs.length > 0) {
                const lastInput = textInputs[textInputs.length - 1];
                lastInput.focus();
              }
            }, 0);
          }
        });
      });
      addTagButtonSetting.settingEl.addClass("flit-add-folder-button");
    };
    renderExcludedTags();
    const propertiesHeaderSetting = new import_obsidian5.Setting(this.containerEl).setName("Properties").setDesc("Set properties to match.");
    propertiesHeaderSetting.settingEl.addClass("flit-master-toggle");
    const propertyNotes = this.containerEl.createEl("div", { cls: "setting-item-description" });
    propertyNotes.style.marginTop = "15px";
    propertyNotes.style.marginBottom = "15px";
    const ul = propertyNotes.createEl("ul");
    ul.style.margin = "0";
    ul.style.paddingLeft = "20px";
    const li2 = ul.createEl("li");
    li2.appendText("Leave ");
    li2.createEl("em", { text: "value" });
    li2.appendText(" blank to match all notes with this property key.");
    ul.createEl("li", { text: "Case-insensitive." });
    const li3 = ul.createEl("li");
    li3.createEl("em", { text: "Exclude all except..." });
    li3.appendText(" also excludes notes with no properties.");
    ul.createEl("li", { text: "Renamed property keys aren't reflected below. Update manually after renaming." });
    const propertyModeSetting = new import_obsidian5.Setting(this.containerEl).setName("Exclusion mode").setDesc("Set how properties should be excluded.").addDropdown(
      (dropdown) => dropdown.addOption("Only exclude...", "Only exclude...").addOption("Exclude all except...", "Exclude all except...").setValue(this.plugin.settings.propertyScopeStrategy).onChange(async (value) => {
        this.plugin.settings.propertyScopeStrategy = value;
        this.plugin.debugLog("propertyScopeStrategy", value);
        await this.plugin.saveSettings();
      })
    );
    propertyModeSetting.settingEl.style.borderTop = "none";
    const propertyContainer = this.containerEl.createDiv();
    const renderExcludedProperties = () => {
      propertyContainer.empty();
      if (this.plugin.settings.excludedProperties.length === 0) {
        this.plugin.settings.excludedProperties.push({ key: "", value: "" });
      }
      let addPropertyButton;
      this.plugin.settings.excludedProperties.forEach((property, index) => {
        const propertySetting = new import_obsidian5.Setting(propertyContainer);
        let keyInput2;
        let valueInput2;
        let removeButton;
        const updateButtonState = () => {
          const isLastEmptyEntry = this.plugin.settings.excludedProperties.length === 1 && this.plugin.settings.excludedProperties[0].key.trim() === "" && this.plugin.settings.excludedProperties[0].value.trim() === "";
          if (isLastEmptyEntry) {
            removeButton.setDisabled(true);
            removeButton.extraSettingsEl.style.opacity = "0.5";
            removeButton.extraSettingsEl.style.pointerEvents = "none";
            removeButton.extraSettingsEl.removeAttribute("aria-label");
            removeButton.extraSettingsEl.title = "";
          } else {
            removeButton.setDisabled(false);
            removeButton.extraSettingsEl.style.opacity = "1";
            removeButton.extraSettingsEl.style.pointerEvents = "auto";
            removeButton.setTooltip("Remove");
          }
        };
        const propertyInputContainer2 = propertySetting.controlEl.createDiv({ cls: "flit-property-container" });
        propertyInputContainer2.style.display = "flex";
        propertyInputContainer2.style.gap = "10px";
        propertyInputContainer2.style.alignItems = "center";
        keyInput2 = propertyInputContainer2.createEl("input", { type: "text", cls: "flit-property-key-input" });
        keyInput2.placeholder = "key";
        keyInput2.value = property.key;
        const colonSpan2 = propertyInputContainer2.createEl("span", { text: ":", cls: "flit-colon-separator" });
        valueInput2 = propertyInputContainer2.createEl("input", { type: "text", cls: "flit-property-value-input" });
        valueInput2.placeholder = "value";
        valueInput2.value = property.value;
        keyInput2.addEventListener("input", async (e) => {
          this.plugin.settings.excludedProperties[index].key = e.target.value;
          this.plugin.debugLog("excludedProperties", this.plugin.settings.excludedProperties);
          await this.plugin.saveSettings();
          updateButtonState();
        });
        valueInput2.addEventListener("input", async (e) => {
          this.plugin.settings.excludedProperties[index].value = e.target.value;
          this.plugin.debugLog("excludedProperties", this.plugin.settings.excludedProperties);
          await this.plugin.saveSettings();
          updateButtonState();
        });
        propertySetting.addExtraButton((button) => {
          removeButton = button;
          button.setIcon("x");
          button.onClick(async () => {
            if (this.plugin.settings.excludedProperties.length === 1) {
              this.plugin.settings.excludedProperties[0] = { key: "", value: "" };
            } else {
              this.plugin.settings.excludedProperties.splice(index, 1);
            }
            await this.plugin.saveSettings();
            renderExcludedProperties();
          });
          updateButtonState();
        });
        propertySetting.settingEl.addClass("flit-excluded-folder-setting");
      });
      const addPropertyButtonSetting = new import_obsidian5.Setting(propertyContainer).addButton((button) => {
        button.setButtonText("Add property").onClick(async () => {
          const lastProperty = this.plugin.settings.excludedProperties[this.plugin.settings.excludedProperties.length - 1];
          const isBottomEntryEmpty = this.plugin.settings.excludedProperties.length > 0 && lastProperty.key.trim() === "" && lastProperty.value.trim() === "";
          if (isBottomEntryEmpty) {
            const keyInputs = propertyContainer.querySelectorAll(".flit-property-key-input");
            if (keyInputs.length > 0) {
              const lastInput = keyInputs[keyInputs.length - 1];
              lastInput.focus();
            }
          } else {
            this.plugin.settings.excludedProperties.push({ key: "", value: "" });
            await this.plugin.saveSettings();
            renderExcludedProperties();
            setTimeout(() => {
              const keyInputs = propertyContainer.querySelectorAll(".flit-property-key-input");
              if (keyInputs.length > 0) {
                const lastInput = keyInputs[keyInputs.length - 1];
                lastInput.focus();
              }
            }, 0);
          }
        });
      });
      addPropertyButtonSetting.settingEl.addClass("flit-add-folder-button");
    };
    renderExcludedProperties();
    const propertyDisableSetting = new import_obsidian5.Setting(this.containerEl).setName("Property to disable renaming").setDesc("");
    propertyDisableSetting.settingEl.addClass("flit-master-toggle");
    const propertyDesc = propertyDisableSetting.descEl;
    propertyDesc.appendText("Set the property to exclude notes from processing.");
    const propertyDisableNotes = this.containerEl.createEl("div", { cls: "setting-item-description" });
    propertyDisableNotes.style.marginTop = "15px";
    propertyDisableNotes.style.marginBottom = "15px";
    const disableUl = propertyDisableNotes.createEl("ul");
    disableUl.style.margin = "0";
    disableUl.style.paddingLeft = "20px";
    disableUl.createEl("li", { text: "Always respected \u2014 cannot get overridden by any command." });
    disableUl.createEl("li", { text: "Case-insensitive." });
    const disableLi3 = disableUl.createEl("li");
    disableLi3.appendText("Changing this will not automatically update properties that have been previously added. Update manually after change.");
    const propertyInputSetting = new import_obsidian5.Setting(this.containerEl);
    propertyInputSetting.settingEl.addClass("flit-excluded-folder-setting");
    propertyInputSetting.settingEl.style.borderTop = "none";
    const propertyControlWrapper = propertyInputSetting.controlEl.createDiv({
      cls: "flit-property-control-wrapper"
    });
    propertyControlWrapper.style.display = "flex";
    propertyControlWrapper.style.alignItems = "center";
    propertyControlWrapper.style.gap = "8px";
    propertyControlWrapper.style.width = "100%";
    const propertyRestoreButtonContainer = propertyControlWrapper.createDiv({
      cls: "flit-restore-button-container"
    });
    const propertyRestoreButton = propertyRestoreButtonContainer.createEl("button", {
      cls: "clickable-icon flit-restore-icon",
      attr: { "aria-label": "Restore default" }
    });
    (0, import_obsidian5.setIcon)(propertyRestoreButton, "rotate-ccw");
    const propertyInputContainer = propertyControlWrapper.createDiv({ cls: "flit-property-container" });
    propertyInputContainer.style.display = "flex";
    propertyInputContainer.style.gap = "10px";
    propertyInputContainer.style.alignItems = "center";
    const keyInput = propertyInputContainer.createEl("input", { type: "text", cls: "flit-property-key-input" });
    keyInput.placeholder = "key";
    keyInput.value = this.plugin.settings.disableRenamingKey;
    const colonSpan = propertyInputContainer.createEl("span", { text: ":", cls: "flit-colon-separator" });
    const valueInput = propertyInputContainer.createEl("input", { type: "text", cls: "flit-property-value-input" });
    valueInput.placeholder = "value";
    valueInput.value = this.plugin.settings.disableRenamingValue;
    keyInput.addEventListener("input", async (e) => {
      this.plugin.settings.disableRenamingKey = e.target.value;
      await this.plugin.saveSettings();
    });
    valueInput.addEventListener("input", async (e) => {
      this.plugin.settings.disableRenamingValue = e.target.value;
      await this.plugin.saveSettings();
    });
    propertyRestoreButton.addEventListener("click", async () => {
      this.plugin.settings.disableRenamingKey = DEFAULT_SETTINGS.disableRenamingKey;
      this.plugin.settings.disableRenamingValue = DEFAULT_SETTINGS.disableRenamingValue;
      keyInput.value = this.plugin.settings.disableRenamingKey;
      valueInput.value = this.plugin.settings.disableRenamingValue;
      await this.plugin.saveSettings();
    });
    const defaultTextContainer = this.containerEl.createEl("div", { cls: "setting-item-description" });
    defaultTextContainer.createEl("small").createEl("strong", { text: "Default: no rename:true" });
    defaultTextContainer.style.marginTop = "5px";
    defaultTextContainer.style.marginBottom = "20px";
    propertyDisableSetting.settingEl.style.marginBottom = "20px";
  }
  async checkFirstTimeExclusionsSetup() {
    if (this.plugin.settings.hasSetupExclusions) {
      return;
    }
    const excalidrawPlugin = this.plugin.app.plugins.getPlugin("obsidian-excalidraw-plugin");
    if (excalidrawPlugin && excalidrawPlugin._loaded) {
      const hasExcalidrawProperty = this.plugin.settings.excludedProperties.some(
        (prop) => prop.key === "excalidraw-plugin" && prop.value === "parsed"
      );
      if (!hasExcalidrawProperty) {
        this.plugin.settings.excludedProperties.push({
          key: "excalidraw-plugin",
          value: "parsed"
        });
        await this.plugin.saveSettings();
      }
    }
    console.debug("Checking for template plugin folders to auto-exclude");
    const adapter = this.plugin.app.vault.adapter;
    const configDir = this.plugin.app.vault.configDir;
    console.debug("Vault config directory is:", configDir);
    let templatesFolder = null;
    let templaterFolder = null;
    try {
      const corePluginsPath = `${configDir}/core-plugins.json`;
      console.debug("Reading core plugins configuration from:", corePluginsPath);
      const corePluginsData = await adapter.read(corePluginsPath);
      const corePlugins = JSON.parse(corePluginsData);
      console.debug("Core Templates plugin enabled status:", corePlugins.templates);
      if (corePlugins.templates === true) {
        console.debug("Core Templates plugin is enabled, checking for templates folder");
        const templatesDataPath = `${configDir}/templates.json`;
        console.debug("Reading templates configuration from:", templatesDataPath);
        const templatesData = await adapter.read(templatesDataPath);
        const templatesConfig = JSON.parse(templatesData);
        templatesFolder = templatesConfig.folder;
        console.debug("Core Templates folder configured as:", templatesFolder);
      } else {
        console.debug("Core Templates plugin is disabled, skipping");
      }
    } catch (error) {
      console.debug("Could not read core Templates plugin configuration:", error);
    }
    console.debug("Checking for Templater community plugin");
    const templaterPlugin = this.plugin.app.plugins.getPlugin("templater-obsidian");
    console.debug("Templater plugin found:", !!templaterPlugin, "| loaded:", templaterPlugin == null ? void 0 : templaterPlugin._loaded);
    if (templaterPlugin && templaterPlugin._loaded) {
      try {
        const templaterDataPath = `${configDir}/plugins/templater-obsidian/data.json`;
        console.debug("Reading Templater configuration from:", templaterDataPath);
        const templaterData = await adapter.read(templaterDataPath);
        const templaterConfig = JSON.parse(templaterData);
        templaterFolder = templaterConfig.templates_folder;
        console.debug("Templater folder configured as:", templaterFolder);
      } catch (error) {
        console.debug("Could not read Templater plugin configuration:", error);
      }
    } else {
      console.debug("Templater plugin not loaded, skipping");
    }
    const foldersToAdd = [];
    if (templatesFolder && templatesFolder.trim() !== "") {
      foldersToAdd.push(templatesFolder);
      console.debug("Queued core Templates folder for exclusion:", templatesFolder);
    } else {
      console.debug("No valid core Templates folder to add");
    }
    if (templaterFolder && templaterFolder.trim() !== "") {
      if (templaterFolder !== templatesFolder) {
        foldersToAdd.push(templaterFolder);
        console.debug("Queued Templater folder for exclusion:", templaterFolder);
      } else {
        console.debug("Templater folder matches core Templates folder (" + templaterFolder + "), will not add duplicate");
      }
    } else {
      console.debug("No valid Templater folder to add");
    }
    console.debug("Total folders to add to exclusions:", foldersToAdd);
    console.debug("Current excluded folders before processing:", this.plugin.settings.excludedFolders);
    for (const folder of foldersToAdd) {
      const hasFolderExcluded = this.plugin.settings.excludedFolders.some(
        (existingFolder) => existingFolder === folder
      );
      if (!hasFolderExcluded) {
        if (this.plugin.settings.excludedFolders.length === 1 && this.plugin.settings.excludedFolders[0].trim() === "") {
          this.plugin.settings.excludedFolders = [];
          console.debug("Removed default empty string entry from excluded folders");
        }
        this.plugin.settings.excludedFolders.push(folder);
        console.debug("Successfully added folder to exclusions:", folder);
      } else {
        console.debug("Folder already in exclusions list, skipping:", folder);
      }
    }
    if (foldersToAdd.length > 0) {
      await this.plugin.saveSettings();
      console.debug("Saved settings after adding template folders to exclusions");
    } else {
      console.debug("No folders were added, skipping settings save");
    }
    console.debug("Final excluded folders after processing:", this.plugin.settings.excludedFolders);
    this.plugin.settings.hasSetupExclusions = true;
    await this.plugin.saveSettings();
  }
};

// src/settings/tab-alias.ts
var import_obsidian6 = require("obsidian");
init_constants();
var PropertiesTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
  }
  render() {
    const updateAliasConditionalSettings = async () => {
      const customRulesEnabled = this.plugin.settings.enableCustomReplacements;
      applyCustomRulesInAliasSetting.components[0].setDisabled(!customRulesEnabled);
      if (customRulesEnabled) {
        applyCustomRulesInAliasSetting.settingEl.classList.remove("flit-row-disabled");
        applyCustomRulesToggle.toggleEl.tabIndex = 0;
        applyCustomRulesToggle.toggleEl.removeAttribute("aria-disabled");
        applyCustomRulesToggle.toggleEl.style.pointerEvents = "";
      } else {
        applyCustomRulesInAliasSetting.settingEl.classList.add("flit-row-disabled");
        applyCustomRulesToggle.toggleEl.tabIndex = -1;
        applyCustomRulesToggle.toggleEl.setAttribute("aria-disabled", "true");
        applyCustomRulesToggle.toggleEl.style.pointerEvents = "none";
        if (this.plugin.settings.applyCustomRulesInAlias) {
          this.plugin.settings.applyCustomRulesInAlias = false;
          await this.plugin.saveSettings();
          applyCustomRulesInAliasSetting.components[0].setValue(false);
        }
      }
      const stripMarkupEnabled = this.plugin.settings.enableStripMarkup;
      stripMarkupInAliasSetting.components[0].setDisabled(!stripMarkupEnabled);
      if (stripMarkupEnabled) {
        stripMarkupInAliasSetting.settingEl.classList.remove("flit-row-disabled");
        stripMarkupToggle.toggleEl.tabIndex = 0;
        stripMarkupToggle.toggleEl.removeAttribute("aria-disabled");
        stripMarkupToggle.toggleEl.style.pointerEvents = "";
      } else {
        stripMarkupInAliasSetting.settingEl.classList.add("flit-row-disabled");
        stripMarkupToggle.toggleEl.tabIndex = -1;
        stripMarkupToggle.toggleEl.setAttribute("aria-disabled", "true");
        stripMarkupToggle.toggleEl.style.pointerEvents = "none";
        if (this.plugin.settings.stripMarkupInAlias) {
          this.plugin.settings.stripMarkupInAlias = false;
          await this.plugin.saveSettings();
          stripMarkupInAliasSetting.components[0].setValue(false);
        }
      }
    };
    const aliasToggleSetting = new import_obsidian6.Setting(this.containerEl).setName("Add alias").setDesc("Always copy the first line to a property when renaming notes. Allows to make forbidden characters searchable.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableAliases).onChange(async (value) => {
        this.plugin.settings.enableAliases = value;
        this.plugin.debugLog("enableAliases", value);
        if (value && !this.plugin.settings.hasEnabledAliases) {
          this.plugin.settings.keepEmptyAliasProperty = true;
          if (this.plugin.settings.enableStripMarkup) {
            this.plugin.settings.stripMarkupInAlias = true;
          }
          if (this.plugin.settings.enableCustomReplacements) {
            this.plugin.settings.applyCustomRulesInAlias = true;
          }
          this.plugin.settings.hasEnabledAliases = true;
        }
        await this.plugin.saveSettings();
        renderAliasSettings();
      })
    );
    aliasToggleSetting.settingEl.addClass("flit-master-toggle");
    aliasToggleSetting.settingEl.addClass("flit-no-border");
    aliasToggleSetting.settingEl.style.marginBottom = "20px";
    const aliasContainer = this.containerEl.createDiv({ cls: "flit-alias-container" });
    let addAliasConditionalToggle;
    let truncateAliasToggle;
    let applyCustomRulesToggle;
    let stripMarkupToggle;
    let keepEmptyToggle;
    let hideInSidebarToggle;
    let suppressMergeToggle;
    const renderAliasSettings = () => {
      this.updateInteractiveState(aliasContainer, this.plugin.settings.enableAliases);
      this.updateDisabledRowsAccessibility(aliasContainer);
      const showActualState = this.plugin.settings.hasEnabledAliases;
      if (addAliasConditionalToggle) {
        addAliasConditionalToggle.setValue(showActualState ? this.plugin.settings.addAliasOnlyIfFirstLineDiffers : false);
      }
      if (truncateAliasToggle) {
        truncateAliasToggle.setValue(showActualState ? this.plugin.settings.truncateAlias : false);
      }
      if (applyCustomRulesToggle) {
        applyCustomRulesToggle.setValue(showActualState ? this.plugin.settings.applyCustomRulesInAlias : false);
      }
      if (stripMarkupToggle) {
        stripMarkupToggle.setValue(showActualState ? this.plugin.settings.stripMarkupInAlias : false);
      }
      if (keepEmptyToggle) {
        keepEmptyToggle.setValue(showActualState ? this.plugin.settings.keepEmptyAliasProperty : false);
      }
      if (hideInSidebarToggle) {
        hideInSidebarToggle.setValue(showActualState ? this.plugin.settings.hideAliasInSidebar : false);
      }
      if (suppressMergeToggle) {
        suppressMergeToggle.setValue(showActualState ? this.plugin.settings.suppressMergeNotifications : false);
      }
      updateAliasConditionalSettings();
    };
    const aliasPropertyKeySetting = new import_obsidian6.Setting(aliasContainer).setName("Alias property name").setDesc("");
    const aliasKeyDesc = aliasPropertyKeySetting.descEl;
    aliasKeyDesc.appendText("Set the property key in which to insert the alias.");
    const aliasNotesDesc = aliasKeyDesc.createEl("div");
    aliasNotesDesc.style.marginTop = "6px";
    aliasNotesDesc.style.marginBottom = "0px";
    const ul = aliasNotesDesc.createEl("ul");
    ul.style.margin = "0";
    ul.style.paddingLeft = "20px";
    ul.createEl("li", { text: "Use 'aliases' to make the alias searchable in the Quick switcher." });
    ul.createEl("li", { text: "To populate multiple properties, separate by comma (e.g., 'aliases, title')." });
    const li2 = ul.createEl("li");
    li2.appendText("This property can be set as note title in ");
    li2.createEl("a", {
      text: "Omnisearch",
      href: "obsidian://show-plugin?id=omnisearch"
    });
    li2.appendText(" and ");
    li2.createEl("a", {
      text: "Notebook Navigator",
      href: "obsidian://show-plugin?id=notebook-navigator"
    });
    li2.appendText(".");
    aliasKeyDesc.createEl("br");
    aliasKeyDesc.createEl("small").createEl("strong", { text: "Default: aliases" });
    const aliasPropertyKeyContainer = aliasPropertyKeySetting.controlEl.createDiv({ cls: "flit-char-text-input-container" });
    const aliasPropertyKeyRestoreButton = aliasPropertyKeyContainer.createEl("button", {
      cls: "clickable-icon flit-restore-icon",
      attr: { "aria-label": "Restore default" }
    });
    (0, import_obsidian6.setIcon)(aliasPropertyKeyRestoreButton, "rotate-ccw");
    const aliasPropertyKeyTextInput = aliasPropertyKeyContainer.createEl("input", { type: "text", cls: "flit-char-text-input" });
    aliasPropertyKeyTextInput.placeholder = "Empty";
    aliasPropertyKeyTextInput.style.width = "120px";
    aliasPropertyKeyTextInput.value = this.plugin.settings.aliasPropertyKey;
    aliasPropertyKeyRestoreButton.addEventListener("click", async () => {
      this.plugin.settings.aliasPropertyKey = DEFAULT_SETTINGS.aliasPropertyKey;
      aliasPropertyKeyTextInput.value = DEFAULT_SETTINGS.aliasPropertyKey;
      this.plugin.debugLog("aliasPropertyKey", this.plugin.settings.aliasPropertyKey);
      await this.plugin.saveSettings();
    });
    aliasPropertyKeyTextInput.addEventListener("input", async (e) => {
      const value = e.target.value;
      this.plugin.settings.aliasPropertyKey = value.trim() || "aliases";
      this.plugin.debugLog("aliasPropertyKey", this.plugin.settings.aliasPropertyKey);
      await this.plugin.saveSettings();
    });
    const addAliasConditionalSetting = new import_obsidian6.Setting(aliasContainer).setName("Only add alias if first line differs from title").setDesc("For example, if the filename was truncated, or some characters have been omitted or replaced.").addToggle((toggle) => {
      addAliasConditionalToggle = toggle;
      toggle.setValue(this.plugin.settings.hasEnabledAliases ? this.plugin.settings.addAliasOnlyIfFirstLineDiffers : false).onChange(async (value) => {
        this.plugin.settings.addAliasOnlyIfFirstLineDiffers = value;
        this.plugin.debugLog("addAliasOnlyIfFirstLineDiffers", value);
        await this.plugin.saveSettings();
      });
    });
    const truncateAliasSetting = new import_obsidian6.Setting(aliasContainer).setName("Truncate alias").setDesc("");
    const truncateDesc = truncateAliasSetting.descEl;
    truncateDesc.appendText("In accordance with the ");
    truncateDesc.createEl("em", { text: "Character count" });
    truncateDesc.appendText(" value in ");
    truncateDesc.createEl("em", { text: "General" });
    truncateDesc.appendText(" settings.");
    truncateAliasSetting.addToggle((toggle) => {
      truncateAliasToggle = toggle;
      toggle.setValue(this.plugin.settings.hasEnabledAliases ? this.plugin.settings.truncateAlias : false).onChange(async (value) => {
        this.plugin.settings.truncateAlias = value;
        this.plugin.debugLog("truncateAlias", value);
        await this.plugin.saveSettings();
      });
    });
    const applyCustomRulesInAliasSetting = new import_obsidian6.Setting(aliasContainer).setName("Apply custom rules").setDesc("");
    const customRulesDesc = applyCustomRulesInAliasSetting.descEl;
    customRulesDesc.appendText("Apply custom text replacements to alias, as set in ");
    customRulesDesc.createEl("em", { text: "Custom rules" });
    customRulesDesc.appendText(" settings.");
    applyCustomRulesInAliasSetting.addToggle((toggle) => {
      applyCustomRulesToggle = toggle;
      toggle.setValue(this.plugin.settings.hasEnabledAliases ? this.plugin.settings.applyCustomRulesInAlias : false).setDisabled(!this.plugin.settings.enableCustomReplacements).onChange(async (value) => {
        this.plugin.settings.applyCustomRulesInAlias = value;
        this.plugin.debugLog("applyCustomRulesInAlias", value);
        await this.plugin.saveSettings();
      });
      if (!this.plugin.settings.enableCustomReplacements) {
        toggle.toggleEl.tabIndex = -1;
        toggle.toggleEl.setAttribute("aria-disabled", "true");
        toggle.toggleEl.style.pointerEvents = "none";
      }
    });
    const stripMarkupInAliasSetting = new import_obsidian6.Setting(aliasContainer).setName("Strip markup").setDesc("");
    const stripMarkupDesc = stripMarkupInAliasSetting.descEl;
    stripMarkupDesc.appendText("Omit markup syntax in alias, as set in ");
    stripMarkupDesc.createEl("em", { text: "Strip markup" });
    stripMarkupDesc.appendText(" settings.");
    stripMarkupInAliasSetting.addToggle((toggle) => {
      stripMarkupToggle = toggle;
      toggle.setValue(this.plugin.settings.hasEnabledAliases ? this.plugin.settings.stripMarkupInAlias : false).setDisabled(!this.plugin.settings.enableStripMarkup).onChange(async (value) => {
        this.plugin.settings.stripMarkupInAlias = value;
        this.plugin.debugLog("stripMarkupInAlias", value);
        await this.plugin.saveSettings();
      });
      if (!this.plugin.settings.enableStripMarkup) {
        toggle.toggleEl.tabIndex = -1;
        toggle.toggleEl.setAttribute("aria-disabled", "true");
        toggle.toggleEl.style.pointerEvents = "none";
      }
    });
    const keepEmptyAliasPropertySetting = new import_obsidian6.Setting(aliasContainer).setName("Keep empty alias property").setDesc("When the plugin removes the first line alias and no other aliases remain, keep the empty property rather than delete it.").addToggle((toggle) => {
      keepEmptyToggle = toggle;
      toggle.setValue(this.plugin.settings.hasEnabledAliases ? this.plugin.settings.keepEmptyAliasProperty : false).onChange(async (value) => {
        this.plugin.settings.keepEmptyAliasProperty = value;
        this.plugin.debugLog("keepEmptyAliasProperty", value);
        await this.plugin.saveSettings();
      });
    });
    const hideAliasPropertySetting = new import_obsidian6.Setting(aliasContainer).setName("Hide alias property").setDesc("Hide the alias property in Reading view and Live Preview. Will always remain visible in Source view.").addDropdown(
      (dropdown) => dropdown.addOption("never", "Never").addOption("when_empty", "Only when empty").addOption("always", "Always").setValue(this.plugin.settings.hideAliasProperty).onChange(async (value) => {
        this.plugin.settings.hideAliasProperty = value;
        this.plugin.debugLog("hideAliasProperty", value);
        await this.plugin.saveSettings();
        this.updatePropertyVisibility();
        hideInSidebarSetting.settingEl.style.display = value === "when_empty" || value === "always" ? "" : "none";
      })
    );
    const hideInSidebarContainer = aliasContainer.createDiv("flit-sub-settings");
    const hideInSidebarSetting = new import_obsidian6.Setting(hideInSidebarContainer).setName("Hide in sidebar").setDesc("Also hide the property in the properties sidebar.").addToggle((toggle) => {
      hideInSidebarToggle = toggle;
      toggle.setValue(this.plugin.settings.hasEnabledAliases ? this.plugin.settings.hideAliasInSidebar : false).onChange(async (value) => {
        this.plugin.settings.hideAliasInSidebar = value;
        this.plugin.debugLog("hideAliasInSidebar", value);
        await this.plugin.saveSettings();
        this.updatePropertyVisibility();
      });
    });
    hideInSidebarSetting.settingEl.style.display = this.plugin.settings.hideAliasProperty === "when_empty" || this.plugin.settings.hideAliasProperty === "always" ? "" : "none";
    const suppressMergeNotificationsSetting = new import_obsidian6.Setting(aliasContainer).setName("Hide merge notifications").setDesc("Suppress notifications about files being modified externally and merged automatically.").addToggle((toggle) => {
      suppressMergeToggle = toggle;
      toggle.setValue(this.plugin.settings.hasEnabledAliases ? this.plugin.settings.suppressMergeNotifications : false).onChange(async (value) => {
        this.plugin.settings.suppressMergeNotifications = value;
        this.plugin.debugLog("suppressMergeNotifications", value);
        await this.plugin.saveSettings();
      });
    });
    if (!import_obsidian6.Platform.isMobile) {
      const limitationsSetting = new import_obsidian6.Setting(aliasContainer).setName("Limitations").setDesc("");
      limitationsSetting.settingEl.addClass("flit-section-header");
      const limitationsContainer = aliasContainer.createDiv();
      const limitationsDesc = limitationsContainer.createEl("p", { cls: "setting-item-description" });
      limitationsDesc.style.marginTop = "12px";
      limitationsDesc.appendText("First line alias can be unreliable if editing in a page preview. Using ");
      limitationsDesc.createEl("a", {
        text: "Hover Editor",
        href: "obsidian://show-plugin?id=obsidian-hover-editor"
      });
      limitationsDesc.appendText(" is recommended.");
    }
    renderAliasSettings();
    updateAliasConditionalSettings();
    this.plugin.updateAliasConditionalSettings = updateAliasConditionalSettings;
  }
  updatePropertyVisibility() {
    var _a, _b;
    (_b = (_a = this.plugin).updatePropertyVisibility) == null ? void 0 : _b.call(_a);
  }
};

// src/settings/tab-replace-characters.ts
var import_obsidian7 = require("obsidian");
init_utils();
init_constants();
var ForbiddenCharsTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
  }
  render() {
    const headerToggleSetting = new import_obsidian7.Setting(this.containerEl).setName("Replace forbidden characters").setDesc("").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableForbiddenCharReplacements).onChange(async (value) => {
        this.plugin.settings.enableForbiddenCharReplacements = value;
        this.plugin.debugLog("enableForbiddenCharReplacements", value);
        if (value && !this.plugin.settings.hasEnabledForbiddenChars) {
          const allOSesKeys = ["leftBracket", "rightBracket", "hash", "caret", "pipe", "slash", "colon"];
          allOSesKeys.forEach((key) => {
            this.plugin.settings.charReplacementEnabled[key] = true;
          });
          this.plugin.settings.hasEnabledForbiddenChars = true;
          const currentOS = detectOS();
          if (currentOS === "Windows" && !this.plugin.settings.hasEnabledWindowsAndroid) {
            this.plugin.settings.windowsAndroidEnabled = true;
            const windowsAndroidKeys = ["asterisk", "quote", "lessThan", "greaterThan", "question"];
            windowsAndroidKeys.forEach((key) => {
              this.plugin.settings.charReplacementEnabled[key] = true;
            });
            this.plugin.settings.hasEnabledWindowsAndroid = true;
          }
        }
        await this.plugin.saveSettings();
        updateCharacterSettings();
        updateCharacterReplacementUI();
        updateWindowsAndroidUI();
        if (windowsAndroidToggleComponent) {
          windowsAndroidToggleComponent.setDisabled(!value);
          if (value) {
            windowsAndroidToggleComponent.toggleEl.style.pointerEvents = "";
            windowsAndroidToggleComponent.toggleEl.style.opacity = "";
            windowsAndroidToggleComponent.toggleEl.tabIndex = 0;
            windowsAndroidToggleComponent.toggleEl.removeAttribute("aria-disabled");
          } else {
            windowsAndroidToggleComponent.toggleEl.style.pointerEvents = "none";
            windowsAndroidToggleComponent.toggleEl.style.opacity = "0.5";
            windowsAndroidToggleComponent.toggleEl.tabIndex = -1;
            windowsAndroidToggleComponent.toggleEl.setAttribute("aria-disabled", "true");
          }
        }
      });
    });
    headerToggleSetting.settingEl.addClass("flit-master-toggle");
    headerToggleSetting.settingEl.addClass("flit-no-border");
    const charDescEl = this.containerEl.createEl("div", { cls: "setting-item-description" });
    const updateCharDescriptionContent = () => {
      charDescEl.setText("Set replacements for characters which are not allowed in filenames. Forbidden characters are omitted entirely if disabled.");
    };
    updateCharDescriptionContent();
    this.containerEl.createEl("br");
    this.containerEl.createEl("br");
    const charSettingsContainer = this.containerEl.createDiv({ cls: "flit-char-settings-container" });
    const updateCharacterReplacementUI = () => {
      this.updateInteractiveState(
        charSettingsContainer,
        this.plugin.settings.enableForbiddenCharReplacements
      );
      this.updateDisabledRowsAccessibility(charSettingsContainer);
      const tableContainers = charSettingsContainer.querySelectorAll(".flit-table-container");
      tableContainers.forEach((container) => {
        if (this.plugin.settings.enableForbiddenCharReplacements) {
          container.classList.remove("flit-master-disabled");
        } else {
          container.classList.add("flit-master-disabled");
        }
      });
    };
    const primaryCharSettings = [
      { key: "leftBracket", name: "Left bracket [", char: "[" },
      { key: "rightBracket", name: "Right bracket ]", char: "]" },
      { key: "hash", name: "Hash #", char: "#" },
      { key: "caret", name: "Caret ^", char: "^" },
      { key: "pipe", name: "Pipe |", char: "|" },
      { key: "backslash", name: "Backslash \\", char: String.fromCharCode(92) },
      { key: "slash", name: "Forward slash /", char: "/" },
      { key: "colon", name: "Colon :", char: ":" },
      { key: "dot", name: "Dot .", char: ".", description: "Note: the dot is forbidden at filename start only." }
    ];
    const windowsAndroidChars = [
      { key: "asterisk", name: "Asterisk *", char: "*" },
      { key: "quote", name: 'Quote "', char: '"' },
      { key: "lessThan", name: "Less than <", char: "<" },
      { key: "greaterThan", name: "Greater than >", char: ">" },
      { key: "question", name: "Question mark ?", char: "?" }
    ];
    let windowsAndroidTableContainer;
    let windowsAndroidToggleComponent;
    const updateCharacterSettings = () => {
      charSettingsContainer.empty();
      const allOSesHeaderSetting = new import_obsidian7.Setting(charSettingsContainer).setName("All OSes").setDesc("Replace characters that are forbidden in Obsidian filenames on all OSes.");
      allOSesHeaderSetting.settingEl.addClass("flit-master-toggle");
      charSettingsContainer.createEl("br");
      const allOSesTableContainer = charSettingsContainer.createEl("div", { cls: "flit-table-container" });
      const allOSesTableWrapper = allOSesTableContainer.createEl("div", { cls: "flit-table-wrapper" });
      const headerRow = allOSesTableWrapper.createEl("div", { cls: "flit-char-replacement-header" });
      const enableHeader = headerRow.createDiv({ cls: "flit-enable-column" });
      enableHeader.textContent = "Enable";
      const charNameHeader = headerRow.createDiv({ cls: "flit-char-name-column" });
      charNameHeader.textContent = "Character";
      const inputHeader = headerRow.createDiv({ cls: "flit-char-text-input-container" });
      inputHeader.textContent = "Replace with";
      const trimLeftHeader = headerRow.createDiv({ cls: "flit-toggle-column center" });
      const trimLeftLine1 = trimLeftHeader.createDiv();
      trimLeftLine1.textContent = "Trim left";
      const trimRightHeader = headerRow.createDiv({ cls: "flit-toggle-column center" });
      const trimRightLine1 = trimRightHeader.createDiv();
      trimRightLine1.textContent = "Trim right";
      primaryCharSettings.forEach((setting) => {
        const rowEl = allOSesTableWrapper.createEl("div", { cls: "flit-char-replacement-setting" });
        const toggleContainer = rowEl.createDiv({ cls: "flit-enable-column" });
        const toggleSetting = new import_obsidian7.Setting(document.createElement("div"));
        toggleSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledForbiddenChars ? this.plugin.settings.charReplacementEnabled[setting.key] : false).onChange(async (value) => {
            this.plugin.settings.charReplacementEnabled[setting.key] = value;
            this.plugin.debugLog(`charReplacementEnabled.${setting.key}`, value);
            await this.plugin.saveSettings();
            updateRowAppearance();
          });
          toggle.toggleEl.style.margin = "0";
          toggleContainer.appendChild(toggle.toggleEl);
        });
        const updateRowAppearance = () => {
          if (this.plugin.settings.charReplacementEnabled[setting.key]) {
            rowEl.classList.remove("flit-row-disabled");
          } else {
            rowEl.classList.add("flit-row-disabled");
          }
        };
        const nameContainer = rowEl.createEl("div", { cls: "flit-char-name-column" });
        const nameEl = nameContainer.createEl("div", { text: setting.name, cls: "setting-item-name" });
        if (setting.description) {
          const descEl = nameContainer.createEl("div", { cls: "setting-item-description" });
          descEl.textContent = setting.description;
        }
        const inputContainer = rowEl.createDiv({ cls: "flit-char-text-input-container" });
        const restoreButton = inputContainer.createEl("button", {
          cls: "clickable-icon flit-restore-icon",
          attr: { "aria-label": "Restore default" }
        });
        (0, import_obsidian7.setIcon)(restoreButton, "rotate-ccw");
        restoreButton.addEventListener("click", async () => {
          this.plugin.settings.charReplacements[setting.key] = DEFAULT_SETTINGS.charReplacements[setting.key];
          textInput.value = DEFAULT_SETTINGS.charReplacements[setting.key];
          await this.plugin.saveSettings();
        });
        const textInput = inputContainer.createEl("input", { type: "text", cls: "flit-char-text-input" });
        textInput.placeholder = "Empty";
        textInput.value = this.plugin.settings.charReplacements[setting.key];
        textInput.style.width = "120px";
        textInput.addEventListener("input", async (e) => {
          this.plugin.settings.charReplacements[setting.key] = e.target.value;
          this.plugin.debugLog(`charReplacements[${setting.key}]`, this.plugin.settings.charReplacements[setting.key]);
          await this.plugin.saveSettings();
        });
        this.addForbiddenCharProtection(textInput);
        const trimLeftContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const trimLeftSetting = new import_obsidian7.Setting(document.createElement("div"));
        trimLeftSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledForbiddenChars ? this.plugin.settings.charReplacementTrimLeft[setting.key] : false).onChange(async (value) => {
            this.plugin.settings.charReplacementTrimLeft[setting.key] = value;
            this.plugin.debugLog(`charReplacementTrimLeft.${setting.key}`, value);
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          trimLeftContainer.appendChild(toggle.toggleEl);
        });
        const trimRightContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const trimRightSetting = new import_obsidian7.Setting(document.createElement("div"));
        trimRightSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledForbiddenChars ? this.plugin.settings.charReplacementTrimRight[setting.key] : false).onChange(async (value) => {
            this.plugin.settings.charReplacementTrimRight[setting.key] = value;
            this.plugin.debugLog(`charReplacementTrimRight.${setting.key}`, value);
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          trimRightContainer.appendChild(toggle.toggleEl);
        });
        updateRowAppearance();
      });
      const windowsAndroidHeaderSetting = new import_obsidian7.Setting(charSettingsContainer).setName("Windows/Android").setDesc("Replace characters that are forbidden in Obsidian filenames on Windows and Android only.").addToggle((toggle) => {
        windowsAndroidToggleComponent = toggle;
        toggle.setValue(this.plugin.settings.windowsAndroidEnabled).setDisabled(!this.plugin.settings.enableForbiddenCharReplacements).onChange(async (value) => {
          this.plugin.settings.windowsAndroidEnabled = value;
          this.plugin.debugLog("windowsAndroidEnabled", value);
          if (value && !this.plugin.settings.hasEnabledWindowsAndroid) {
            windowsAndroidChars.forEach((setting) => {
              this.plugin.settings.charReplacementEnabled[setting.key] = true;
            });
            this.plugin.settings.hasEnabledWindowsAndroid = true;
          }
          await this.plugin.saveSettings();
          updateWindowsAndroidUI();
        });
        if (!this.plugin.settings.enableForbiddenCharReplacements) {
          toggle.toggleEl.style.pointerEvents = "none";
          toggle.toggleEl.style.opacity = "0.5";
          toggle.toggleEl.tabIndex = -1;
          toggle.toggleEl.setAttribute("aria-disabled", "true");
        }
      });
      windowsAndroidHeaderSetting.settingEl.addClass("flit-master-toggle");
      windowsAndroidHeaderSetting.settingEl.addClass("flit-windows-android-header");
      charSettingsContainer.createEl("br");
      windowsAndroidTableContainer = charSettingsContainer.createEl("div", { cls: "flit-table-container flit-windows-android-table" });
      const windowsAndroidTableWrapper = windowsAndroidTableContainer.createEl("div", { cls: "flit-table-wrapper" });
      const winAndroidHeaderRow = windowsAndroidTableWrapper.createEl("div", { cls: "flit-char-replacement-header" });
      const winEnableHeader = winAndroidHeaderRow.createDiv({ cls: "flit-enable-column" });
      winEnableHeader.textContent = "Enable";
      const winCharNameHeader = winAndroidHeaderRow.createDiv({ cls: "flit-char-name-column" });
      winCharNameHeader.textContent = "Character";
      const winInputHeader = winAndroidHeaderRow.createDiv({ cls: "flit-char-text-input-container" });
      winInputHeader.textContent = "Replace with";
      const winTrimLeftHeader = winAndroidHeaderRow.createDiv({ cls: "flit-toggle-column center" });
      const winTrimLeftLine1 = winTrimLeftHeader.createDiv();
      winTrimLeftLine1.textContent = "Trim left";
      const winTrimRightHeader = winAndroidHeaderRow.createDiv({ cls: "flit-toggle-column center" });
      const winTrimRightLine1 = winTrimRightHeader.createDiv();
      winTrimRightLine1.textContent = "Trim right";
      windowsAndroidChars.forEach((setting) => {
        const rowEl = windowsAndroidTableWrapper.createEl("div", { cls: "flit-char-replacement-setting" });
        const toggleContainer = rowEl.createDiv({ cls: "flit-enable-column" });
        const toggleSetting = new import_obsidian7.Setting(document.createElement("div"));
        toggleSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledForbiddenChars && this.plugin.settings.hasEnabledWindowsAndroid ? this.plugin.settings.charReplacementEnabled[setting.key] : false).onChange(async (value) => {
            this.plugin.settings.charReplacementEnabled[setting.key] = value;
            this.plugin.debugLog(`charReplacementEnabled.${setting.key}`, value);
            await this.plugin.saveSettings();
            updateRowAppearance();
          });
          toggle.toggleEl.style.margin = "0";
          toggleContainer.appendChild(toggle.toggleEl);
        });
        const updateRowAppearance = () => {
          if (this.plugin.settings.charReplacementEnabled[setting.key]) {
            rowEl.classList.remove("flit-row-disabled");
          } else {
            rowEl.classList.add("flit-row-disabled");
          }
        };
        const nameContainer = rowEl.createEl("div", { cls: "flit-char-name-column" });
        const nameEl = nameContainer.createEl("div", { text: setting.name, cls: "setting-item-name" });
        const inputContainer = rowEl.createDiv({ cls: "flit-char-text-input-container" });
        const restoreButton = inputContainer.createEl("button", {
          cls: "clickable-icon flit-restore-icon",
          attr: { "aria-label": "Restore default" }
        });
        (0, import_obsidian7.setIcon)(restoreButton, "rotate-ccw");
        restoreButton.addEventListener("click", async () => {
          this.plugin.settings.charReplacements[setting.key] = DEFAULT_SETTINGS.charReplacements[setting.key];
          textInput.value = DEFAULT_SETTINGS.charReplacements[setting.key];
          await this.plugin.saveSettings();
        });
        const textInput = inputContainer.createEl("input", { type: "text", cls: "flit-char-text-input" });
        textInput.placeholder = "Empty";
        textInput.value = this.plugin.settings.charReplacements[setting.key];
        textInput.style.width = "120px";
        textInput.addEventListener("input", async (e) => {
          this.plugin.settings.charReplacements[setting.key] = e.target.value;
          this.plugin.debugLog(`charReplacements[${setting.key}]`, this.plugin.settings.charReplacements[setting.key]);
          await this.plugin.saveSettings();
        });
        this.addForbiddenCharProtection(textInput, true);
        const trimLeftContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const trimLeftSetting = new import_obsidian7.Setting(document.createElement("div"));
        trimLeftSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledForbiddenChars && this.plugin.settings.hasEnabledWindowsAndroid ? this.plugin.settings.charReplacementTrimLeft[setting.key] : false).onChange(async (value) => {
            this.plugin.settings.charReplacementTrimLeft[setting.key] = value;
            this.plugin.debugLog(`charReplacementTrimLeft.${setting.key}`, value);
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          trimLeftContainer.appendChild(toggle.toggleEl);
        });
        const trimRightContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const trimRightSetting = new import_obsidian7.Setting(document.createElement("div"));
        trimRightSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledForbiddenChars && this.plugin.settings.hasEnabledWindowsAndroid ? this.plugin.settings.charReplacementTrimRight[setting.key] : false).onChange(async (value) => {
            this.plugin.settings.charReplacementTrimRight[setting.key] = value;
            this.plugin.debugLog(`charReplacementTrimRight.${setting.key}`, value);
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          trimRightContainer.appendChild(toggle.toggleEl);
        });
        updateRowAppearance();
      });
    };
    const updateWindowsAndroidUI = () => {
      if (this.plugin.settings.windowsAndroidEnabled) {
        windowsAndroidTableContainer.show();
      } else {
        windowsAndroidTableContainer.hide();
      }
    };
    updateCharacterSettings();
    updateCharacterReplacementUI();
    updateWindowsAndroidUI();
  }
};

// src/settings/tab-strip-markup.ts
var import_obsidian8 = require("obsidian");
var StripMarkupTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
  }
  render() {
    const masterToggleSetting = new import_obsidian8.Setting(this.containerEl).setName("Strip markup").setDesc("Set markup syntax to omit in filenames.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableStripMarkup).onChange(async (value) => {
        var _a, _b;
        this.plugin.settings.enableStripMarkup = value;
        this.plugin.debugLog("enableStripMarkup", value);
        if (!value) {
          if (this.plugin.settings.stripMarkupInAlias) {
            this.plugin.settings.stripMarkupInAlias = false;
          }
        }
        await this.plugin.saveSettings();
        updateStripMarkupUI();
        (_b = (_a = this.plugin).updateAliasConditionalSettings) == null ? void 0 : _b.call(_a);
      });
    });
    masterToggleSetting.settingEl.addClass("flit-master-toggle");
    masterToggleSetting.settingEl.addClass("flit-no-border");
    masterToggleSetting.settingEl.style.marginBottom = "20px";
    const stripMarkupContainer = this.containerEl.createDiv({ cls: "flit-strip-markup-container" });
    const updateStripMarkupUI = () => {
      this.updateInteractiveState(stripMarkupContainer, this.plugin.settings.enableStripMarkup);
      this.updateDisabledRowsAccessibility(stripMarkupContainer);
    };
    const markupToggles = [
      { key: "headings", name: "Strip heading markup", desc: "For example, turn ### Hello into Hello." },
      { key: "bold", name: "Strip bold markup", desc: "For example, turn **Hello** or __Hello__ into Hello." },
      { key: "italic", name: "Strip italic markup", desc: "For example, turn *Hello* or _Hello_ into Hello." },
      { key: "strikethrough", name: "Strip strikethrough markup", desc: "For example, turn ~~Hello~~ into Hello." },
      { key: "highlight", name: "Strip highlight markup", desc: "For example, turn ==Hello== into Hello." },
      { key: "wikilinks", name: "Strip wikilink markup", desc: "For example, turn [[Hello]] or [[Hi|Hello]] into Hello." },
      { key: "markdownLinks", name: "Strip markdown link markup", desc: "For example, turn [Hello](https://example.org) into Hello." },
      { key: "quote", name: "Strip quote markup", desc: "For example, turn >Hello into Hello." },
      { key: "callouts", name: "Strip callout markup", desc: "For example, turn >[!info] Hello into Hello." },
      { key: "unorderedLists", name: "Strip unordered list markup", desc: "For example, turn - Hello or * Hello into Hello." },
      { key: "orderedLists", name: "Strip ordered list markup", desc: "For example, turn 1. Hello into Hello." },
      { key: "taskLists", name: "Strip task list markup", desc: "For example, turn - [x] Hello into Hello." },
      { key: "code", name: "Strip inline code markup", desc: "For example, turn `Hello` into Hello." },
      { key: "codeBlocks", name: "Strip code block markup", desc: "Instead, put the first line within code block in title." },
      { key: "footnotes", name: "Strip footnote markup", desc: "For example, turn Hello[^1] or Hello^[note] into Hello." },
      { key: "comments", name: "Strip comment markup", desc: "For example, turn %%Hello%% or <!--Hello--> into Hello." },
      { key: "htmlTags", name: "Strip HTML tags", desc: "For example, turn <u>Hello</u> into Hello." }
    ];
    let stripCommentsEntirelyContainer;
    const updateStripCommentsEntirelyVisibility = () => {
      if (this.plugin.settings.stripMarkupSettings.comments) {
        stripCommentsEntirelyContainer.show();
      } else {
        stripCommentsEntirelyContainer.hide();
      }
    };
    markupToggles.forEach((toggle) => {
      new import_obsidian8.Setting(stripMarkupContainer).setName(toggle.name).setDesc(toggle.desc).addToggle(
        (toggleControl) => toggleControl.setValue(this.plugin.settings.stripMarkupSettings[toggle.key]).onChange(async (value) => {
          this.plugin.settings.stripMarkupSettings[toggle.key] = value;
          this.plugin.debugLog(`stripMarkupSettings.${toggle.key}`, value);
          await this.plugin.saveSettings();
          if (toggle.key === "comments") {
            updateStripCommentsEntirelyVisibility();
          }
        })
      );
      if (toggle.key === "comments") {
        const stripCommentsEntirelySetting = new import_obsidian8.Setting(stripMarkupContainer).setName("Strip comments entirely").setDesc("Also strip comment content in title.").addToggle(
          (toggle2) => toggle2.setValue(this.plugin.settings.stripCommentsEntirely).onChange(async (value) => {
            this.plugin.settings.stripCommentsEntirely = value;
            this.plugin.debugLog("stripCommentsEntirely", value);
            await this.plugin.saveSettings();
          })
        );
        stripCommentsEntirelyContainer = stripMarkupContainer.createDiv("flit-sub-settings");
        stripCommentsEntirelyContainer.appendChild(stripCommentsEntirelySetting.settingEl);
        updateStripCommentsEntirelyVisibility();
      }
    });
    const templaterSetting = new import_obsidian8.Setting(stripMarkupContainer).setName("Strip Templater syntax").setDesc("");
    const templaterDesc = templaterSetting.descEl;
    templaterDesc.appendText("Omit ");
    templaterDesc.createEl("a", {
      text: "Templater",
      href: "obsidian://show-plugin?id=templater-obsidian"
    });
    templaterDesc.appendText(" syntax like ");
    templaterDesc.createEl("code", { text: "<% tp.file.cursor() %>" });
    templaterDesc.appendText(".");
    templaterSetting.addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.stripTemplaterSyntax).onChange(async (value) => {
        this.plugin.settings.stripTemplaterSyntax = value;
        this.plugin.debugLog("stripTemplaterSyntax", value);
        await this.plugin.saveSettings();
      })
    );
    updateStripMarkupUI();
  }
};

// src/settings/tab-custom-rules.ts
var import_obsidian9 = require("obsidian");
var CustomReplacementsTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
  }
  render() {
    const customHeaderToggleSetting = new import_obsidian9.Setting(this.containerEl).setName("Enable custom rules").setDesc("").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableCustomReplacements).onChange(async (value) => {
        var _a, _b;
        this.plugin.settings.enableCustomReplacements = value;
        this.plugin.debugLog("enableCustomReplacements", value);
        if (value && !this.plugin.settings.hasEnabledCustomReplacements) {
          this.plugin.settings.customReplacements.forEach((replacement) => {
            replacement.enabled = true;
          });
          this.plugin.settings.hasEnabledCustomReplacements = true;
        }
        if (!value) {
          if (this.plugin.settings.applyCustomRulesInAlias) {
            this.plugin.settings.applyCustomRulesInAlias = false;
          }
        }
        await this.plugin.saveSettings();
        updateCustomReplacementUI();
        renderCustomReplacements();
        (_b = (_a = this.plugin).updateAliasConditionalSettings) == null ? void 0 : _b.call(_a);
      });
    });
    customHeaderToggleSetting.settingEl.addClass("flit-master-toggle");
    customHeaderToggleSetting.settingEl.addClass("flit-no-border");
    const customDescEl = this.containerEl.createEl("div", { cls: "setting-item-description" });
    const customBulletListEl = this.containerEl.createEl("div", { cls: "setting-item-description" });
    const updateCustomDescriptionContent = () => {
      customDescEl.empty();
      customBulletListEl.empty();
      customDescEl.createEl("span", { text: "Set custom text replacements." });
      customDescEl.createEl("br");
      customDescEl.createEl("br");
      const ul = customBulletListEl.createEl("ul");
      ul.style.margin = "0";
      ul.style.paddingLeft = "20px";
      const li1 = ul.createEl("li", { text: "Rules are applied sequentially from top to bottom." });
      const li3 = ul.createEl("li", { text: "Whitespace preserved." });
      const li4 = ul.createEl("li");
      li4.appendText("Leave ");
      li4.createEl("em", { text: "Replace with" });
      li4.appendText(" blank to omit text entirely.");
      const li5 = ul.createEl("li");
      li5.appendText("If ");
      li5.createEl("em", { text: "Replace with" });
      li5.appendText(" is blank and ");
      li5.createEl("em", { text: "Text to replace" });
      li5.appendText(" matches whole line, filename becomes ");
      li5.createEl("em", { text: "Untitled" });
      li5.appendText(".");
    };
    updateCustomDescriptionContent();
    this.containerEl.createEl("br");
    const customReplacementsContainer = this.containerEl.createDiv({ cls: "flit-custom-replacements-container" });
    let processingOrderContainer;
    let globalProcessingHeaderSetting;
    let markupToggleContainer;
    let markupToggleSetting;
    let markupToggle;
    const updateCustomReplacementUI = () => {
      const enabled = this.plugin.settings.enableCustomReplacements;
      this.updateInteractiveState(customBulletListEl, enabled);
      this.updateInteractiveState(customReplacementsContainer, enabled);
      if (processingOrderContainer) {
        this.updateInteractiveState(processingOrderContainer, enabled);
      }
      if (globalProcessingHeaderSetting) {
        if (enabled) {
          globalProcessingHeaderSetting.settingEl.classList.remove("flit-master-disabled");
        } else {
          globalProcessingHeaderSetting.settingEl.classList.add("flit-master-disabled");
        }
      }
      if (markupToggleContainer) {
        markupToggleContainer.style.opacity = "";
      }
      if (markupToggleSetting) {
        updateMarkupToggleVisibility();
      }
      this.updateDisabledRowsAccessibility(customReplacementsContainer);
      const tableContainers = customReplacementsContainer.querySelectorAll(".flit-table-container");
      tableContainers.forEach((container) => {
        if (enabled) {
          container.classList.remove("flit-master-disabled");
        } else {
          container.classList.add("flit-master-disabled");
        }
      });
    };
    const renderCustomReplacements = () => {
      customReplacementsContainer.empty();
      const existingAddButton = this.containerEl.querySelector(".flit-add-replacement-button");
      if (existingAddButton) existingAddButton.remove();
      const tableContainer = customReplacementsContainer.createEl("div", { cls: "flit-table-container flit-custom-table-container" });
      const tableWrapper = tableContainer.createEl("div", { cls: "flit-table-wrapper" });
      const headerRow = tableWrapper.createEl("div", { cls: "flit-custom-replacement-header" });
      const enableHeader = headerRow.createDiv({ cls: "flit-enable-column" });
      enableHeader.textContent = "Enable";
      const textToReplaceHeader = headerRow.createDiv({ cls: "flit-text-column" });
      textToReplaceHeader.textContent = "Text to replace";
      const replaceWithHeader = headerRow.createDiv({ cls: "flit-text-column" });
      replaceWithHeader.textContent = "Replace with";
      const startOnlyHeader = headerRow.createDiv({ cls: "flit-toggle-column" });
      const startLine1 = startOnlyHeader.createDiv();
      startLine1.textContent = "Only match";
      const startLine2 = startOnlyHeader.createDiv();
      startLine2.textContent = "line start";
      const wholeLineHeader = headerRow.createDiv({ cls: "flit-toggle-column" });
      const wholeLine1 = wholeLineHeader.createDiv();
      wholeLine1.textContent = "Only match";
      const wholeLine2 = wholeLineHeader.createDiv();
      wholeLine2.textContent = "whole line";
      const actionsHeader = headerRow.createDiv({ cls: "flit-actions-column" });
      actionsHeader.textContent = "";
      this.plugin.settings.customReplacements.forEach((replacement, index) => {
        const rowEl = tableWrapper.createEl("div", { cls: "flit-custom-replacement-setting" });
        let deleteButton;
        let updateButtonState;
        const toggleContainer = rowEl.createDiv({ cls: "flit-enable-column" });
        const individualToggleSetting = new import_obsidian9.Setting(document.createElement("div"));
        individualToggleSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledCustomReplacements ? replacement.enabled : false).onChange(async (value) => {
            this.plugin.settings.customReplacements[index].enabled = value;
            this.plugin.debugLog(`customReplacements[${index}].enabled`, value);
            await this.plugin.saveSettings();
            updateRowAppearance();
          });
          toggle.toggleEl.style.margin = "0";
          toggleContainer.appendChild(toggle.toggleEl);
        });
        const updateRowAppearance = () => {
          const isRowEnabled = this.plugin.settings.customReplacements[index].enabled;
          const masterEnabled = this.plugin.settings.enableCustomReplacements;
          const shouldApplyInlineOpacity = masterEnabled;
          if (isRowEnabled) {
            rowEl.classList.remove("flit-row-disabled");
            input1.style.opacity = "";
            input1.style.pointerEvents = "";
            input1.disabled = false;
            input1.tabIndex = 0;
            input1.removeAttribute("aria-disabled");
            input2.style.opacity = "";
            input2.style.pointerEvents = "";
            input2.disabled = false;
            input2.tabIndex = 0;
            input2.removeAttribute("aria-disabled");
            startToggleContainer.style.opacity = "";
            startToggleContainer.style.pointerEvents = "";
            wholeToggleContainer.style.opacity = "";
            wholeToggleContainer.style.pointerEvents = "";
            [startToggleContainer, wholeToggleContainer].forEach((container) => {
              const toggleEls = container.querySelectorAll('input[type="checkbox"]');
              toggleEls.forEach((el) => {
                el.tabIndex = 0;
                el.removeAttribute("aria-disabled");
              });
            });
          } else {
            rowEl.classList.add("flit-row-disabled");
            input1.style.opacity = shouldApplyInlineOpacity ? "0.5" : "";
            input1.style.pointerEvents = "none";
            input1.disabled = true;
            input1.tabIndex = -1;
            input1.setAttribute("aria-disabled", "true");
            input2.style.opacity = shouldApplyInlineOpacity ? "0.5" : "";
            input2.style.pointerEvents = "none";
            input2.disabled = true;
            input2.tabIndex = -1;
            input2.setAttribute("aria-disabled", "true");
            startToggleContainer.style.opacity = shouldApplyInlineOpacity ? "0.5" : "";
            startToggleContainer.style.pointerEvents = "none";
            wholeToggleContainer.style.opacity = shouldApplyInlineOpacity ? "0.5" : "";
            wholeToggleContainer.style.pointerEvents = "none";
            [startToggleContainer, wholeToggleContainer].forEach((container) => {
              const toggleEls = container.querySelectorAll('input[type="checkbox"]');
              toggleEls.forEach((el) => {
                el.tabIndex = -1;
                el.setAttribute("aria-disabled", "true");
              });
            });
          }
        };
        const input1Container = rowEl.createDiv({ cls: "flit-text-column" });
        const input1 = input1Container.createEl("input", { type: "text" });
        input1.placeholder = "Empty";
        input1.value = replacement.searchText;
        input1.addEventListener("input", async (e) => {
          this.plugin.settings.customReplacements[index].searchText = e.target.value;
          this.plugin.debugLog(`customReplacements[${index}].searchText`, this.plugin.settings.customReplacements[index].searchText);
          await this.plugin.saveSettings();
          updateButtonState();
        });
        this.addForbiddenCharProtection(input1);
        const input2Container = rowEl.createDiv({ cls: "flit-text-column" });
        const input2 = input2Container.createEl("input", { type: "text" });
        input2.placeholder = "Empty";
        input2.value = replacement.replaceText;
        input2.addEventListener("input", async (e) => {
          this.plugin.settings.customReplacements[index].replaceText = e.target.value;
          this.plugin.debugLog(`customReplacements[${index}].replaceText`, this.plugin.settings.customReplacements[index].replaceText);
          await this.plugin.saveSettings();
          updateButtonState();
        });
        this.addForbiddenCharProtection(input2);
        const startToggleContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const startToggleSetting = new import_obsidian9.Setting(document.createElement("div"));
        startToggleSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledCustomReplacements ? replacement.onlyAtStart : false).onChange(async (value) => {
            this.plugin.settings.customReplacements[index].onlyAtStart = value;
            this.plugin.debugLog(`customReplacements[${index}].onlyAtStart`, value);
            if (value) {
              this.plugin.settings.customReplacements[index].onlyWholeLine = false;
            }
            await this.plugin.saveSettings();
            renderCustomReplacements();
          });
          toggle.toggleEl.style.margin = "0";
          if (replacement.onlyWholeLine) {
            toggle.setDisabled(true);
            toggle.toggleEl.style.opacity = "0.5";
            toggle.toggleEl.style.pointerEvents = "none";
          }
          startToggleContainer.appendChild(toggle.toggleEl);
        });
        const wholeToggleContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const wholeToggleSetting = new import_obsidian9.Setting(document.createElement("div"));
        wholeToggleSetting.addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.hasEnabledCustomReplacements ? replacement.onlyWholeLine : false).onChange(async (value) => {
            this.plugin.settings.customReplacements[index].onlyWholeLine = value;
            this.plugin.debugLog(`customReplacements[${index}].onlyWholeLine`, value);
            if (value) {
              this.plugin.settings.customReplacements[index].onlyAtStart = false;
            }
            await this.plugin.saveSettings();
            renderCustomReplacements();
          });
          toggle.toggleEl.style.margin = "0";
          if (replacement.onlyAtStart) {
            toggle.setDisabled(true);
            toggle.toggleEl.style.opacity = "0.5";
            toggle.toggleEl.style.pointerEvents = "none";
          }
          wholeToggleContainer.appendChild(toggle.toggleEl);
        });
        const buttonContainer = rowEl.createDiv({ cls: "flit-actions-column flit-button-container" });
        const upButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-nav-button",
          attr: { "aria-label": "Move up" }
        });
        if (index === 0) {
          upButton.classList.add("disabled");
        }
        (0, import_obsidian9.setIcon)(upButton, "chevron-up");
        if (index > 0) {
          upButton.addEventListener("click", async () => {
            const temp = this.plugin.settings.customReplacements[index];
            this.plugin.settings.customReplacements[index] = this.plugin.settings.customReplacements[index - 1];
            this.plugin.settings.customReplacements[index - 1] = temp;
            await this.plugin.saveSettings();
            renderCustomReplacements();
          });
        }
        const downButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-nav-button",
          attr: { "aria-label": "Move down" }
        });
        if (index === this.plugin.settings.customReplacements.length - 1) {
          downButton.classList.add("disabled");
        }
        (0, import_obsidian9.setIcon)(downButton, "chevron-down");
        if (index < this.plugin.settings.customReplacements.length - 1) {
          downButton.addEventListener("click", async () => {
            const temp = this.plugin.settings.customReplacements[index];
            this.plugin.settings.customReplacements[index] = this.plugin.settings.customReplacements[index + 1];
            this.plugin.settings.customReplacements[index + 1] = temp;
            await this.plugin.saveSettings();
            renderCustomReplacements();
          });
        }
        deleteButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-delete-button",
          attr: { "aria-label": "Delete", "type": "button" }
        });
        (0, import_obsidian9.setIcon)(deleteButton, "x");
        deleteButton.addEventListener("click", async () => {
          if (this.plugin.settings.customReplacements.length === 1) {
            this.plugin.settings.customReplacements[0] = {
              searchText: "",
              replaceText: "",
              enabled: true,
              onlyAtStart: false,
              onlyWholeLine: false
            };
          } else {
            this.plugin.settings.customReplacements.splice(index, 1);
          }
          await this.plugin.saveSettings();
          renderCustomReplacements();
        });
        updateButtonState = () => {
          const isLastEmptyEntry = this.plugin.settings.customReplacements.length === 1 && this.plugin.settings.customReplacements[0].searchText.trim() === "" && this.plugin.settings.customReplacements[0].replaceText.trim() === "";
          if (isLastEmptyEntry) {
            deleteButton.classList.add("disabled");
            deleteButton.removeAttribute("aria-label");
            deleteButton.title = "";
          } else {
            deleteButton.classList.remove("disabled");
            deleteButton.setAttribute("aria-label", "Remove");
            deleteButton.title = "Remove";
          }
          if (index === 0 || isLastEmptyEntry) {
            upButton.classList.add("disabled");
          } else {
            upButton.classList.remove("disabled");
          }
          if (index === this.plugin.settings.customReplacements.length - 1 || isLastEmptyEntry) {
            downButton.classList.add("disabled");
          } else {
            downButton.classList.remove("disabled");
          }
        };
        updateButtonState();
        updateRowAppearance();
      });
      const addButtonSetting = new import_obsidian9.Setting(customReplacementsContainer).addButton((button) => {
        button.setButtonText("Add replacement").onClick(async () => {
          const lastIndex = this.plugin.settings.customReplacements.length - 1;
          const lastEntry = this.plugin.settings.customReplacements[lastIndex];
          if (lastEntry.searchText.trim() === "" && lastEntry.replaceText.trim() === "") {
            if (!lastEntry.enabled) {
              this.plugin.settings.customReplacements[lastIndex].enabled = true;
              await this.plugin.saveSettings();
              renderCustomReplacements();
              setTimeout(() => {
                const textInputs = customReplacementsContainer.querySelectorAll('input[type="text"]:not([disabled])');
                if (textInputs.length >= 2) {
                  textInputs[textInputs.length - 2].focus();
                }
              }, 50);
            } else {
              const textInputs = customReplacementsContainer.querySelectorAll('input[type="text"]:not([disabled])');
              if (textInputs.length >= 2) {
                textInputs[textInputs.length - 2].focus();
              }
            }
            return;
          }
          this.plugin.settings.customReplacements.push({
            searchText: "",
            replaceText: "",
            onlyAtStart: false,
            onlyWholeLine: false,
            enabled: true
          });
          await this.plugin.saveSettings();
          renderCustomReplacements();
          setTimeout(() => {
            const textInputs = customReplacementsContainer.querySelectorAll('input[type="text"]:not([disabled])');
            if (textInputs.length >= 2) {
              textInputs[textInputs.length - 2].focus();
            }
          }, 50);
        });
      });
      addButtonSetting.settingEl.addClass("flit-add-replacement-button");
      addButtonSetting.settingEl.addClass("flit-master-disable-target");
      updateCustomReplacementUI();
    };
    renderCustomReplacements();
    this.containerEl.createEl("br");
    globalProcessingHeaderSetting = new import_obsidian9.Setting(this.containerEl).setName("Processing order").setDesc("");
    globalProcessingHeaderSetting.settingEl.addClass("flit-section-header");
    processingOrderContainer = this.containerEl.createDiv({ cls: "flit-processing-order-container" });
    const applyAfterForbiddenSetting = new import_obsidian9.Setting(processingOrderContainer).setName("Apply after stripping or replacing forbidden characters").setDesc("");
    const applyAfterForbiddenDesc = applyAfterForbiddenSetting.descEl;
    applyAfterForbiddenDesc.appendText("As set in ");
    applyAfterForbiddenDesc.createEl("em", { text: "Replace characters" });
    applyAfterForbiddenDesc.appendText(".");
    applyAfterForbiddenSetting.addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.applyCustomRulesAfterForbiddenChars).onChange(async (value) => {
        this.plugin.settings.applyCustomRulesAfterForbiddenChars = value;
        this.plugin.debugLog("applyCustomRulesAfterForbiddenChars", value);
        await this.plugin.saveSettings();
      })
    );
    const updateMarkupToggleVisibility = () => {
      if (this.plugin.settings.enableStripMarkup) {
        markupToggleContainer.style.opacity = "";
        markupToggleContainer.style.pointerEvents = "auto";
        markupToggleSetting.setDisabled(false);
        if (markupToggle) {
          markupToggle.toggleEl.tabIndex = 0;
          markupToggle.toggleEl.removeAttribute("aria-disabled");
          markupToggle.toggleEl.style.pointerEvents = "";
        }
      } else {
        if (!processingOrderContainer.classList.contains("flit-master-disabled")) {
          markupToggleContainer.style.opacity = "0.5";
        } else {
          markupToggleContainer.style.opacity = "";
        }
        markupToggleContainer.style.pointerEvents = "none";
        markupToggleSetting.setDisabled(true);
        if (markupToggle) {
          markupToggle.toggleEl.tabIndex = -1;
          markupToggle.toggleEl.setAttribute("aria-disabled", "true");
          markupToggle.toggleEl.style.pointerEvents = "none";
        }
      }
    };
    markupToggleSetting = new import_obsidian9.Setting(processingOrderContainer).setName("Apply after markup stripping").setDesc("");
    const applyAfterMarkupDesc = markupToggleSetting.descEl;
    applyAfterMarkupDesc.appendText("As set in ");
    applyAfterMarkupDesc.createEl("em", { text: "Strip markup" });
    applyAfterMarkupDesc.appendText(".");
    markupToggleSetting.addToggle((toggle) => {
      markupToggle = toggle;
      toggle.setValue(this.plugin.settings.applyCustomRulesAfterMarkupStripping).onChange(async (value) => {
        this.plugin.settings.applyCustomRulesAfterMarkupStripping = value;
        this.plugin.debugLog("applyCustomRulesAfterMarkupStripping", value);
        await this.plugin.saveSettings();
      });
      if (!this.plugin.settings.enableStripMarkup) {
        toggle.toggleEl.tabIndex = -1;
        toggle.toggleEl.setAttribute("aria-disabled", "true");
        toggle.toggleEl.style.pointerEvents = "none";
      }
    });
    markupToggleContainer = markupToggleSetting.settingEl;
    updateMarkupToggleVisibility();
    updateCustomReplacementUI();
  }
};

// src/settings/tab-safewords.ts
var import_obsidian10 = require("obsidian");
init_constants();
var SafewordsTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
  }
  render() {
    const safewordsHeaderToggleSetting = new import_obsidian10.Setting(this.containerEl).setName("Enable safewords").setDesc("").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableSafewords).onChange(async (value) => {
        this.plugin.settings.enableSafewords = value;
        this.plugin.debugLog("enableSafewords", value);
        if (value && !this.plugin.settings.hasEnabledSafewords) {
          this.plugin.settings.safewords.forEach((safeword) => {
            safeword.enabled = true;
          });
          this.plugin.settings.hasEnabledSafewords = true;
        }
        await this.plugin.saveSettings();
        updateSafewordsUI();
        renderSafewords();
      });
    });
    safewordsHeaderToggleSetting.settingEl.addClass("flit-master-toggle");
    safewordsHeaderToggleSetting.settingEl.addClass("flit-no-border");
    const safewordsDescEl = this.containerEl.createEl("div", { cls: "setting-item-description" });
    const updateSafewordsDescriptionContent = () => {
      safewordsDescEl.empty();
      safewordsDescEl.createEl("span", { text: "Specify text that prevents renaming if matched in filename." });
    };
    updateSafewordsDescriptionContent();
    this.containerEl.createEl("br");
    const safewordsContainer = this.containerEl.createDiv({ cls: "flit-safewords-container" });
    const updateSafewordsUI = () => {
      this.updateInteractiveState(safewordsContainer, this.plugin.settings.enableSafewords);
      this.updateDisabledRowsAccessibility(safewordsContainer);
      const tableContainers = safewordsContainer.querySelectorAll(".flit-table-container");
      tableContainers.forEach((container) => {
        if (this.plugin.settings.enableSafewords) {
          container.classList.remove("flit-master-disabled");
        } else {
          container.classList.add("flit-master-disabled");
        }
      });
    };
    const renderSafewords = () => {
      safewordsContainer.empty();
      const existingAddButton = this.containerEl.querySelector(".flit-add-safeword-button");
      if (existingAddButton) existingAddButton.remove();
      const tableContainer = safewordsContainer.createEl("div", { cls: "flit-table-container flit-safeword-table-container" });
      const tableWrapper = tableContainer.createEl("div", { cls: "flit-table-wrapper" });
      const headerRow = tableWrapper.createEl("div", { cls: "flit-safeword-header" });
      const enableHeader = headerRow.createDiv({ cls: "flit-enable-column" });
      enableHeader.textContent = "Enable";
      const safewordHeader = headerRow.createDiv({ cls: "flit-text-column flit-safeword-input" });
      safewordHeader.textContent = "Safeword";
      const startOnlyHeader = headerRow.createDiv({ cls: "flit-toggle-column" });
      const startLine1 = startOnlyHeader.createDiv();
      startLine1.textContent = "Only match";
      const startLine2 = startOnlyHeader.createDiv();
      startLine2.textContent = "filename start";
      const wholeLineHeader = headerRow.createDiv({ cls: "flit-toggle-column" });
      const wholeLine1 = wholeLineHeader.createDiv();
      wholeLine1.textContent = "Only match";
      const wholeLine2 = wholeLineHeader.createDiv();
      wholeLine2.textContent = "whole";
      const wholeLine3 = wholeLineHeader.createDiv();
      wholeLine3.textContent = "filename";
      const caseSensitiveHeader = headerRow.createDiv({ cls: "flit-toggle-column" });
      const caseLine1 = caseSensitiveHeader.createDiv();
      caseLine1.textContent = "Case-";
      const caseLine2 = caseSensitiveHeader.createDiv();
      caseLine2.textContent = "sensitive";
      const actionsHeader = headerRow.createDiv({ cls: "flit-actions-column" });
      actionsHeader.textContent = "";
      this.plugin.settings.safewords.forEach((safeword, index) => {
        const rowEl = tableWrapper.createEl("div", { cls: "flit-safeword-setting" });
        let deleteButton;
        let updateButtonState;
        const toggleContainer = rowEl.createDiv({ cls: "flit-enable-column" });
        const individualToggleSetting = new import_obsidian10.Setting(document.createElement("div"));
        individualToggleSetting.addToggle((toggle) => {
          toggle.setValue(safeword.enabled).onChange(async (value) => {
            this.plugin.settings.safewords[index].enabled = value;
            this.plugin.debugLog(`safewords[${index}].enabled`, value);
            await this.plugin.saveSettings();
            updateRowAppearance();
          });
          toggle.toggleEl.style.margin = "0";
          toggleContainer.appendChild(toggle.toggleEl);
        });
        const updateRowAppearance = () => {
          const isEnabled = this.plugin.settings.safewords[index].enabled;
          const masterEnabled = this.plugin.settings.enableSafewords;
          const shouldApplyInlineOpacity = masterEnabled;
          if (isEnabled) {
            rowEl.classList.remove("flit-row-disabled");
            input.style.opacity = "";
            input.style.pointerEvents = "";
            input.disabled = false;
            input.tabIndex = 0;
            input.removeAttribute("aria-disabled");
            startToggleContainer.style.opacity = "";
            startToggleContainer.style.pointerEvents = "";
            wholeToggleContainer.style.opacity = "";
            wholeToggleContainer.style.pointerEvents = "";
            caseToggleContainer.style.opacity = "";
            caseToggleContainer.style.pointerEvents = "";
            [startToggleContainer, wholeToggleContainer, caseToggleContainer].forEach((container) => {
              const toggleEls = container.querySelectorAll('input[type="checkbox"]');
              toggleEls.forEach((el) => {
                el.tabIndex = 0;
                el.removeAttribute("aria-disabled");
              });
            });
          } else {
            rowEl.classList.add("flit-row-disabled");
            input.style.opacity = shouldApplyInlineOpacity ? "0.5" : "";
            input.style.pointerEvents = "none";
            input.disabled = true;
            input.tabIndex = -1;
            input.setAttribute("aria-disabled", "true");
            startToggleContainer.style.opacity = shouldApplyInlineOpacity ? "0.5" : "";
            startToggleContainer.style.pointerEvents = "none";
            wholeToggleContainer.style.opacity = shouldApplyInlineOpacity ? "0.5" : "";
            wholeToggleContainer.style.pointerEvents = "none";
            caseToggleContainer.style.opacity = shouldApplyInlineOpacity ? "0.5" : "";
            caseToggleContainer.style.pointerEvents = "none";
            [startToggleContainer, wholeToggleContainer, caseToggleContainer].forEach((container) => {
              const toggleEls = container.querySelectorAll('input[type="checkbox"]');
              toggleEls.forEach((el) => {
                el.tabIndex = -1;
                el.setAttribute("aria-disabled", "true");
              });
            });
          }
        };
        const inputContainer = rowEl.createDiv({ cls: "flit-text-column flit-safeword-input" });
        const input = inputContainer.createEl("input", { type: "text" });
        input.placeholder = "Empty";
        input.value = safeword.text;
        input.addEventListener("input", async (e) => {
          const inputEl = e.target;
          let value = inputEl.value;
          const universalForbidden = UNIVERSAL_FORBIDDEN_CHARS;
          const windowsAndroidForbidden = WINDOWS_ANDROID_CHARS;
          let forbiddenChars = [...universalForbidden];
          if (this.plugin.settings.osPreset === "Windows") {
            forbiddenChars.push(...windowsAndroidForbidden);
          }
          let filteredValue = "";
          for (let i = 0; i < value.length; i++) {
            const char = value[i];
            if (char === "." && i === 0) {
              continue;
            }
            if (forbiddenChars.includes(char)) {
              continue;
            }
            filteredValue += char;
          }
          if (filteredValue !== value) {
            inputEl.value = filteredValue;
            const cursorPos = Math.min(inputEl.selectionStart || 0, filteredValue.length);
            inputEl.setSelectionRange(cursorPos, cursorPos);
          }
          this.plugin.settings.safewords[index].text = filteredValue;
          this.plugin.debugLog(`safewords[${index}].text`, this.plugin.settings.safewords[index].text);
          await this.plugin.saveSettings();
          updateButtonState();
        });
        const startToggleContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const startToggleSetting = new import_obsidian10.Setting(document.createElement("div"));
        startToggleSetting.addToggle((toggle) => {
          toggle.setValue(safeword.onlyAtStart).onChange(async (value) => {
            this.plugin.settings.safewords[index].onlyAtStart = value;
            this.plugin.debugLog(`safewords[${index}].onlyAtStart`, value);
            if (value) {
              this.plugin.settings.safewords[index].onlyWholeLine = false;
            }
            await this.plugin.saveSettings();
            renderSafewords();
          });
          toggle.toggleEl.style.margin = "0";
          if (safeword.onlyWholeLine) {
            toggle.setDisabled(true);
            toggle.toggleEl.style.opacity = "0.5";
            toggle.toggleEl.style.pointerEvents = "none";
          }
          startToggleContainer.appendChild(toggle.toggleEl);
        });
        const wholeToggleContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const wholeToggleSetting = new import_obsidian10.Setting(document.createElement("div"));
        wholeToggleSetting.addToggle((toggle) => {
          toggle.setValue(safeword.onlyWholeLine).onChange(async (value) => {
            this.plugin.settings.safewords[index].onlyWholeLine = value;
            this.plugin.debugLog(`safewords[${index}].onlyWholeLine`, value);
            if (value) {
              this.plugin.settings.safewords[index].onlyAtStart = false;
            }
            await this.plugin.saveSettings();
            renderSafewords();
          });
          toggle.toggleEl.style.margin = "0";
          if (safeword.onlyAtStart) {
            toggle.setDisabled(true);
            toggle.toggleEl.style.opacity = "0.5";
            toggle.toggleEl.style.pointerEvents = "none";
          }
          wholeToggleContainer.appendChild(toggle.toggleEl);
        });
        const caseToggleContainer = rowEl.createDiv({ cls: "flit-toggle-column center" });
        const caseToggleSetting = new import_obsidian10.Setting(document.createElement("div"));
        caseToggleSetting.addToggle((toggle) => {
          toggle.setValue(safeword.caseSensitive).onChange(async (value) => {
            this.plugin.settings.safewords[index].caseSensitive = value;
            this.plugin.debugLog(`safewords[${index}].caseSensitive`, value);
            await this.plugin.saveSettings();
          });
          toggle.toggleEl.style.margin = "0";
          caseToggleContainer.appendChild(toggle.toggleEl);
        });
        const buttonContainer = rowEl.createDiv({ cls: "flit-actions-column flit-button-container" });
        const upButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-nav-button",
          attr: { "aria-label": "Move up" }
        });
        if (index === 0) {
          upButton.classList.add("disabled");
        }
        (0, import_obsidian10.setIcon)(upButton, "chevron-up");
        if (index > 0) {
          upButton.addEventListener("click", async () => {
            const temp = this.plugin.settings.safewords[index];
            this.plugin.settings.safewords[index] = this.plugin.settings.safewords[index - 1];
            this.plugin.settings.safewords[index - 1] = temp;
            await this.plugin.saveSettings();
            renderSafewords();
          });
        }
        const downButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-nav-button",
          attr: { "aria-label": "Move down" }
        });
        if (index === this.plugin.settings.safewords.length - 1) {
          downButton.classList.add("disabled");
        }
        (0, import_obsidian10.setIcon)(downButton, "chevron-down");
        if (index < this.plugin.settings.safewords.length - 1) {
          downButton.addEventListener("click", async () => {
            const temp = this.plugin.settings.safewords[index];
            this.plugin.settings.safewords[index] = this.plugin.settings.safewords[index + 1];
            this.plugin.settings.safewords[index + 1] = temp;
            await this.plugin.saveSettings();
            renderSafewords();
          });
        }
        deleteButton = buttonContainer.createEl("button", {
          cls: "clickable-icon flit-delete-button",
          attr: { "aria-label": "Delete", "type": "button" }
        });
        (0, import_obsidian10.setIcon)(deleteButton, "x");
        deleteButton.addEventListener("click", async () => {
          if (this.plugin.settings.safewords.length === 1) {
            this.plugin.settings.safewords[0] = {
              text: "",
              enabled: true,
              onlyAtStart: false,
              onlyWholeLine: false,
              caseSensitive: false
            };
          } else {
            this.plugin.settings.safewords.splice(index, 1);
          }
          await this.plugin.saveSettings();
          renderSafewords();
        });
        updateButtonState = () => {
          const isLastEmptyEntry = this.plugin.settings.safewords.length === 1 && this.plugin.settings.safewords[0].text.trim() === "";
          if (isLastEmptyEntry) {
            deleteButton.classList.add("disabled");
            deleteButton.removeAttribute("aria-label");
            deleteButton.title = "";
          } else {
            deleteButton.classList.remove("disabled");
            deleteButton.setAttribute("aria-label", "Remove");
            deleteButton.title = "Remove";
          }
          if (index === 0 || isLastEmptyEntry) {
            upButton.classList.add("disabled");
          } else {
            upButton.classList.remove("disabled");
          }
          if (index === this.plugin.settings.safewords.length - 1 || isLastEmptyEntry) {
            downButton.classList.add("disabled");
          } else {
            downButton.classList.remove("disabled");
          }
        };
        updateButtonState();
        updateRowAppearance();
      });
      const addButtonSetting = new import_obsidian10.Setting(safewordsContainer).addButton(
        (button) => button.setButtonText("Add safeword").onClick(async () => {
          const lastIndex = this.plugin.settings.safewords.length - 1;
          const lastEntry = this.plugin.settings.safewords[lastIndex];
          if (lastEntry.text.trim() === "") {
            if (!lastEntry.enabled) {
              this.plugin.settings.safewords[lastIndex].enabled = true;
              await this.plugin.saveSettings();
              renderSafewords();
              setTimeout(() => {
                const textInputs = safewordsContainer.querySelectorAll('input[type="text"]');
                if (textInputs.length > 0) {
                  textInputs[textInputs.length - 1].focus();
                }
              }, 0);
            } else {
              const textInputs = safewordsContainer.querySelectorAll('input[type="text"]');
              if (textInputs.length > 0) {
                textInputs[textInputs.length - 1].focus();
              }
            }
            return;
          }
          this.plugin.settings.safewords.push({
            text: "",
            onlyAtStart: false,
            onlyWholeLine: false,
            enabled: true,
            caseSensitive: false
          });
          await this.plugin.saveSettings();
          renderSafewords();
          setTimeout(() => {
            const textInputs = safewordsContainer.querySelectorAll('input[type="text"]');
            if (textInputs.length > 0) {
              textInputs[textInputs.length - 1].focus();
            }
          }, 0);
        })
      );
      addButtonSetting.settingEl.addClass("flit-add-safeword-button");
      updateSafewordsUI();
    };
    renderSafewords();
  }
};

// src/settings/tab-commands.ts
var import_obsidian11 = require("obsidian");
var CommandsTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
  }
  render() {
    const ribbonHeaderSetting = new import_obsidian11.Setting(this.containerEl).setName("Ribbon commands").setDesc("Control which commands appear in the ribbon menu. Reload plugin or Obsidian to apply.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableRibbon).onChange(async (value) => {
        this.plugin.settings.enableRibbon = value;
        this.plugin.debugLog("enableRibbon", value);
        await this.plugin.saveSettings();
        updateRibbonUI();
      });
    });
    ribbonHeaderSetting.settingEl.addClass("flit-master-toggle");
    this.containerEl.createEl("br");
    const ribbonContainer = this.containerEl.createDiv();
    const updateRibbonUI = () => {
      if (this.plugin.settings.enableRibbon) {
        ribbonContainer.show();
      } else {
        ribbonContainer.hide();
      }
    };
    const ribbonCurrentSetting = new import_obsidian11.Setting(ribbonContainer).setName("Put first line in title").setDesc("Rename active note, even if in excluded folder or with excluded tag.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.ribbonVisibility.renameCurrentFile).onChange(async (value) => {
        this.plugin.settings.ribbonVisibility.renameCurrentFile = value;
        this.plugin.debugLog("ribbonVisibility.renameCurrentFile", value);
        await this.plugin.saveSettings();
      });
    });
    const ribbonCurrentIcon = ribbonCurrentSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(ribbonCurrentIcon, "file-pen");
    ribbonCurrentSetting.nameEl.insertBefore(ribbonCurrentIcon, ribbonCurrentSetting.nameEl.firstChild);
    const ribbonBulkSetting = new import_obsidian11.Setting(ribbonContainer).setName("Put first line in title in all notes").setDesc("Rename all notes in vault except if in excluded folder or with excluded tag.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.ribbonVisibility.renameAllNotes).onChange(async (value) => {
        this.plugin.settings.ribbonVisibility.renameAllNotes = value;
        this.plugin.debugLog("ribbonVisibility.renameAllNotes", value);
        await this.plugin.saveSettings();
      });
    });
    const ribbonBulkIcon = ribbonBulkSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(ribbonBulkIcon, "files");
    ribbonBulkSetting.nameEl.insertBefore(ribbonBulkIcon, ribbonBulkSetting.nameEl.firstChild);
    const ribbonToggleSetting = new import_obsidian11.Setting(ribbonContainer).setName("Toggle automatic renaming").setDesc("");
    const ribbonToggleDesc = ribbonToggleSetting.descEl;
    ribbonToggleDesc.appendText("Toggle the ");
    ribbonToggleDesc.createEl("em", { text: "Rename notes" });
    ribbonToggleDesc.appendText(" setting between ");
    ribbonToggleDesc.createEl("em", { text: "Automatically" });
    ribbonToggleDesc.appendText(" and ");
    ribbonToggleDesc.createEl("em", { text: "Manually" });
    ribbonToggleDesc.appendText(".");
    ribbonToggleSetting.addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.ribbonVisibility.toggleAutomaticRenaming).onChange(async (value) => {
        this.plugin.settings.ribbonVisibility.toggleAutomaticRenaming = value;
        this.plugin.debugLog("ribbonVisibility.toggleAutomaticRenaming", value);
        await this.plugin.saveSettings();
      });
    });
    const ribbonToggleIcon = ribbonToggleSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(ribbonToggleIcon, "file-cog");
    ribbonToggleSetting.nameEl.insertBefore(ribbonToggleIcon, ribbonToggleSetting.nameEl.firstChild);
    updateRibbonUI();
    const commandPaletteHeaderSetting = new import_obsidian11.Setting(this.containerEl).setName("Command palette commands").setDesc("Control which commands appear in the Command palette (Ctrl/Cmd-P on desktop by default). Reload plugin or Obsidian to apply.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableCommandPalette).onChange(async (value) => {
        this.plugin.settings.enableCommandPalette = value;
        this.plugin.debugLog("enableCommandPalette", value);
        await this.plugin.saveSettings();
        updateCommandPaletteUI();
      });
    });
    commandPaletteHeaderSetting.settingEl.addClass("flit-master-toggle");
    this.containerEl.createEl("br");
    const commandPaletteContainer = this.containerEl.createDiv();
    commandPaletteContainer.addClass("flit-master-disable-target");
    const updateCommandPaletteUI = () => {
      if (this.plugin.settings.enableCommandPalette) {
        commandPaletteContainer.show();
      } else {
        commandPaletteContainer.hide();
      }
    };
    const setting1 = new import_obsidian11.Setting(commandPaletteContainer).setName("Put first line in title").setDesc("Rename active note, even if in excluded folder or with excluded tag.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandPaletteVisibility.renameCurrentFile).onChange(async (value) => {
        this.plugin.settings.commandPaletteVisibility.renameCurrentFile = value;
        this.plugin.debugLog("commandPaletteVisibility.renameCurrentFile", value);
        await this.plugin.saveSettings();
      })
    );
    const icon1 = setting1.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(icon1, "file-pen");
    setting1.nameEl.insertBefore(icon1, setting1.nameEl.firstChild);
    const setting2 = new import_obsidian11.Setting(commandPaletteContainer).setName("Put first line in title (unless excluded)").setDesc("Rename active note except if in excluded folder or with excluded tag.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandPaletteVisibility.renameCurrentFileUnlessExcluded).onChange(async (value) => {
        this.plugin.settings.commandPaletteVisibility.renameCurrentFileUnlessExcluded = value;
        this.plugin.debugLog("commandPaletteVisibility.renameCurrentFileUnlessExcluded", value);
        await this.plugin.saveSettings();
      })
    );
    const icon2 = setting2.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(icon2, "file-pen");
    setting2.nameEl.insertBefore(icon2, setting2.nameEl.firstChild);
    const setting3 = new import_obsidian11.Setting(commandPaletteContainer).setName("Put first line in title in all notes").setDesc("Rename all notes in vault except if in excluded folder or with excluded tag.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandPaletteVisibility.renameAllFiles).onChange(async (value) => {
        this.plugin.settings.commandPaletteVisibility.renameAllFiles = value;
        this.plugin.debugLog("commandPaletteVisibility.renameAllFiles", value);
        await this.plugin.saveSettings();
      })
    );
    const icon3 = setting3.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(icon3, "files");
    setting3.nameEl.insertBefore(icon3, setting3.nameEl.firstChild);
    const setting8 = new import_obsidian11.Setting(commandPaletteContainer).setName("Toggle automatic renaming").setDesc("");
    const toggleDesc = setting8.descEl;
    toggleDesc.appendText("Toggle the ");
    toggleDesc.createEl("em", { text: "Rename notes" });
    toggleDesc.appendText(" setting between ");
    toggleDesc.createEl("em", { text: "Automatically" });
    toggleDesc.appendText(" and ");
    toggleDesc.createEl("em", { text: "Manually" });
    toggleDesc.appendText(".");
    setting8.addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandPaletteVisibility.toggleAutomaticRenaming).onChange(async (value) => {
        this.plugin.settings.commandPaletteVisibility.toggleAutomaticRenaming = value;
        this.plugin.debugLog("commandPaletteVisibility.toggleAutomaticRenaming", value);
        await this.plugin.saveSettings();
      })
    );
    const icon8 = setting8.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(icon8, "file-cog");
    setting8.nameEl.insertBefore(icon8, setting8.nameEl.firstChild);
    const setting4 = new import_obsidian11.Setting(commandPaletteContainer).setName("Disable renaming for note").setDesc("Exclude active note from renaming.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandPaletteVisibility.disableRenaming).onChange(async (value) => {
        this.plugin.settings.commandPaletteVisibility.disableRenaming = value;
        this.plugin.debugLog("commandPaletteVisibility.disableRenaming", value);
        await this.plugin.saveSettings();
      })
    );
    const icon4 = setting4.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(icon4, "square-x");
    setting4.nameEl.insertBefore(icon4, setting4.nameEl.firstChild);
    const setting5 = new import_obsidian11.Setting(commandPaletteContainer).setName("Enable renaming for note").setDesc("Stop excluding active note from renaming.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandPaletteVisibility.enableRenaming).onChange(async (value) => {
        this.plugin.settings.commandPaletteVisibility.enableRenaming = value;
        this.plugin.debugLog("commandPaletteVisibility.enableRenaming", value);
        await this.plugin.saveSettings();
      })
    );
    const icon5 = setting5.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(icon5, "square-check");
    setting5.nameEl.insertBefore(icon5, setting5.nameEl.firstChild);
    const setting6 = new import_obsidian11.Setting(commandPaletteContainer).setName("Add safe internal link").setDesc("Create internal link with forbidden characters handled according to plugin settings.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.addSafeInternalLink).onChange(async (value) => {
        this.plugin.settings.commandVisibility.addSafeInternalLink = value;
        this.plugin.debugLog("commandVisibility.addSafeInternalLink", value);
        await this.plugin.saveSettings();
      })
    );
    const icon6 = setting6.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(icon6, "link");
    setting6.nameEl.insertBefore(icon6, setting6.nameEl.firstChild);
    const setting7 = new import_obsidian11.Setting(commandPaletteContainer).setName("Add safe internal link with selection as caption").setDesc("Create internal link with safe target and original text as caption.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.addSafeInternalLinkWithCaption).onChange(async (value) => {
        this.plugin.settings.commandVisibility.addSafeInternalLinkWithCaption = value;
        this.plugin.debugLog("commandVisibility.addSafeInternalLinkWithCaption", value);
        await this.plugin.saveSettings();
      })
    );
    const icon7 = setting7.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(icon7, "link");
    setting7.nameEl.insertBefore(icon7, setting7.nameEl.firstChild);
    updateCommandPaletteUI();
    let fileCommandsExpanded = true;
    let folderCommandsExpanded = true;
    let tagCommandsExpanded = true;
    let vaultSearchCommandsExpanded = true;
    const fileHeaderSetting = new import_obsidian11.Setting(this.containerEl).setName("File commands").setDesc("Control which commands appear in the file context menu.").addToggle((toggle) => {
      toggle.setValue(fileCommandsExpanded).onChange(async (value) => {
        fileCommandsExpanded = value;
        updateFileUI();
      });
    });
    fileHeaderSetting.settingEl.addClass("flit-master-toggle");
    this.containerEl.createEl("br");
    const fileContainer = this.containerEl.createDiv();
    fileContainer.addClass("flit-master-disable-target");
    const updateFileUI = () => {
      if (fileCommandsExpanded) {
        fileContainer.show();
      } else {
        fileContainer.hide();
      }
    };
    const filePutFirstLineSetting = new import_obsidian11.Setting(fileContainer).setName("Put first line in title").setDesc("Rename note, even if in excluded folder or with excluded tag.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.filePutFirstLineInTitle).onChange(async (value) => {
        this.plugin.settings.commandVisibility.filePutFirstLineInTitle = value;
        this.plugin.debugLog("commandVisibility.filePutFirstLineInTitle", value);
        await this.plugin.saveSettings();
      })
    );
    const fileIcon = filePutFirstLineSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(fileIcon, "file-pen");
    filePutFirstLineSetting.nameEl.insertBefore(fileIcon, filePutFirstLineSetting.nameEl.firstChild);
    const fileDisableSetting = new import_obsidian11.Setting(fileContainer).setName("Disable renaming for note").setDesc("Exclude note from renaming.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.fileExclude).onChange(async (value) => {
        this.plugin.settings.commandVisibility.fileExclude = value;
        this.plugin.debugLog("commandVisibility.fileExclude", value);
        await this.plugin.saveSettings();
      })
    );
    const fileDisableIcon = fileDisableSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(fileDisableIcon, "square-x");
    fileDisableSetting.nameEl.insertBefore(fileDisableIcon, fileDisableSetting.nameEl.firstChild);
    const fileEnableSetting = new import_obsidian11.Setting(fileContainer).setName("Enable renaming for note").setDesc("Stop excluding note from renaming.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.fileStopExcluding).onChange(async (value) => {
        this.plugin.settings.commandVisibility.fileStopExcluding = value;
        this.plugin.debugLog("commandVisibility.fileStopExcluding", value);
        await this.plugin.saveSettings();
      })
    );
    const fileEnableIcon = fileEnableSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(fileEnableIcon, "square-check");
    fileEnableSetting.nameEl.insertBefore(fileEnableIcon, fileEnableSetting.nameEl.firstChild);
    const folderHeaderSetting = new import_obsidian11.Setting(this.containerEl).setName("Folder commands").setDesc("Control which commands appear in the folder context menu.").addToggle((toggle) => {
      toggle.setValue(folderCommandsExpanded).onChange(async (value) => {
        folderCommandsExpanded = value;
        updateFolderUI();
      });
    });
    folderHeaderSetting.settingEl.addClass("flit-master-toggle");
    this.containerEl.createEl("br");
    const folderContainer = this.containerEl.createDiv();
    folderContainer.addClass("flit-master-disable-target");
    const updateFolderUI = () => {
      if (folderCommandsExpanded) {
        folderContainer.show();
      } else {
        folderContainer.hide();
      }
    };
    const folderPutFirstLineSetting = new import_obsidian11.Setting(folderContainer).setName("Put first line in title").setDesc("Rename all notes in folder.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.folderPutFirstLineInTitle).onChange(async (value) => {
        this.plugin.settings.commandVisibility.folderPutFirstLineInTitle = value;
        this.plugin.debugLog("commandVisibility.folderPutFirstLineInTitle", value);
        await this.plugin.saveSettings();
      })
    );
    const folderIcon = folderPutFirstLineSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(folderIcon, "folder-pen");
    folderPutFirstLineSetting.nameEl.insertBefore(folderIcon, folderPutFirstLineSetting.nameEl.firstChild);
    const folderDisableSetting = new import_obsidian11.Setting(folderContainer).setName("Disable renaming in folder").setDesc("Exclude folder from renaming.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.folderExclude).onChange(async (value) => {
        this.plugin.settings.commandVisibility.folderExclude = value;
        this.plugin.debugLog("commandVisibility.folderExclude", value);
        await this.plugin.saveSettings();
      })
    );
    const folderDisableIcon = folderDisableSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(folderDisableIcon, "square-x");
    folderDisableSetting.nameEl.insertBefore(folderDisableIcon, folderDisableSetting.nameEl.firstChild);
    const folderEnableSetting = new import_obsidian11.Setting(folderContainer).setName("Enable renaming in folder").setDesc("Stop excluding folder from renaming.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.folderStopExcluding).onChange(async (value) => {
        this.plugin.settings.commandVisibility.folderStopExcluding = value;
        this.plugin.debugLog("commandVisibility.folderStopExcluding", value);
        await this.plugin.saveSettings();
      })
    );
    const folderEnableIcon = folderEnableSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(folderEnableIcon, "square-check");
    folderEnableSetting.nameEl.insertBefore(folderEnableIcon, folderEnableSetting.nameEl.firstChild);
    const tagHeaderSetting = new import_obsidian11.Setting(this.containerEl).setName("Tag commands").setDesc("Control which commands appear in the tag context menu.").addToggle((toggle) => {
      toggle.setValue(tagCommandsExpanded).onChange(async (value) => {
        tagCommandsExpanded = value;
        updateTagUI();
      });
    });
    tagHeaderSetting.settingEl.addClass("flit-master-toggle");
    this.containerEl.createEl("br");
    const tagContainer = this.containerEl.createDiv();
    tagContainer.addClass("flit-master-disable-target");
    const updateTagUI = () => {
      if (tagCommandsExpanded) {
        tagContainer.show();
      } else {
        tagContainer.hide();
      }
    };
    const tagPutFirstLineSetting = new import_obsidian11.Setting(tagContainer).setName("Put first line in title").setDesc("Rename all notes with tag.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.tagPutFirstLineInTitle).onChange(async (value) => {
        this.plugin.settings.commandVisibility.tagPutFirstLineInTitle = value;
        this.plugin.debugLog("commandVisibility.tagPutFirstLineInTitle", value);
        await this.plugin.saveSettings();
      })
    );
    const tagIcon = tagPutFirstLineSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(tagIcon, "file-pen");
    tagPutFirstLineSetting.nameEl.insertBefore(tagIcon, tagPutFirstLineSetting.nameEl.firstChild);
    const tagDisableSetting = new import_obsidian11.Setting(tagContainer).setName("Disable renaming for tag").setDesc("Exclude tag from renaming.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.tagExclude).onChange(async (value) => {
        this.plugin.settings.commandVisibility.tagExclude = value;
        this.plugin.debugLog("commandVisibility.tagExclude", value);
        await this.plugin.saveSettings();
      })
    );
    const tagDisableIcon = tagDisableSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(tagDisableIcon, "square-x");
    tagDisableSetting.nameEl.insertBefore(tagDisableIcon, tagDisableSetting.nameEl.firstChild);
    const tagEnableSetting = new import_obsidian11.Setting(tagContainer).setName("Enable renaming for tag").setDesc("Stop excluding tag from renaming.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.commandVisibility.tagStopExcluding).onChange(async (value) => {
        this.plugin.settings.commandVisibility.tagStopExcluding = value;
        this.plugin.debugLog("commandVisibility.tagStopExcluding", value);
        await this.plugin.saveSettings();
      })
    );
    const tagEnableIcon = tagEnableSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(tagEnableIcon, "square-check");
    tagEnableSetting.nameEl.insertBefore(tagEnableIcon, tagEnableSetting.nameEl.firstChild);
    const vaultSearchHeaderSetting = new import_obsidian11.Setting(this.containerEl).setName("Vault search commands").setDesc("Control which commands appear in the context menu for search results.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableVaultSearchContextMenu).onChange(async (value) => {
        this.plugin.settings.enableVaultSearchContextMenu = value;
        this.plugin.debugLog("enableVaultSearchContextMenu", value);
        await this.plugin.saveSettings();
        updateVaultSearchUI();
      });
    });
    vaultSearchHeaderSetting.settingEl.addClass("flit-master-toggle");
    this.containerEl.createEl("br");
    const vaultSearchContainer = this.containerEl.createDiv({ cls: "flit-vault-search-container" });
    vaultSearchContainer.addClass("flit-master-disable-target");
    const updateVaultSearchUI = () => {
      if (this.plugin.settings.enableVaultSearchContextMenu) {
        vaultSearchContainer.show();
      } else {
        vaultSearchContainer.hide();
      }
    };
    const vaultSearchPutFirstLineSetting = new import_obsidian11.Setting(vaultSearchContainer).setName("Put first line in title").setDesc("Rename all notes in search results.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.vaultSearchContextMenuVisibility.putFirstLineInTitle).onChange(async (value) => {
        this.plugin.settings.vaultSearchContextMenuVisibility.putFirstLineInTitle = value;
        this.plugin.debugLog("vaultSearchContextMenuVisibility.putFirstLineInTitle", value);
        await this.plugin.saveSettings();
      })
    );
    const vaultSearchIcon = vaultSearchPutFirstLineSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(vaultSearchIcon, "file-pen");
    vaultSearchPutFirstLineSetting.nameEl.insertBefore(vaultSearchIcon, vaultSearchPutFirstLineSetting.nameEl.firstChild);
    const vaultSearchDisableSetting = new import_obsidian11.Setting(vaultSearchContainer).setName("Disable renaming for notes").setDesc("Exclude all notes in search results.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.vaultSearchContextMenuVisibility.disable).onChange(async (value) => {
        this.plugin.settings.vaultSearchContextMenuVisibility.disable = value;
        this.plugin.debugLog("vaultSearchContextMenuVisibility.disable", value);
        await this.plugin.saveSettings();
      })
    );
    const vaultSearchDisableIcon = vaultSearchDisableSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(vaultSearchDisableIcon, "square-x");
    vaultSearchDisableSetting.nameEl.insertBefore(vaultSearchDisableIcon, vaultSearchDisableSetting.nameEl.firstChild);
    const vaultSearchEnableSetting = new import_obsidian11.Setting(vaultSearchContainer).setName("Enable renaming for notes").setDesc("Stop excluding all notes in search results from renaming.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.vaultSearchContextMenuVisibility.enable).onChange(async (value) => {
        this.plugin.settings.vaultSearchContextMenuVisibility.enable = value;
        this.plugin.debugLog("vaultSearchContextMenuVisibility.enable", value);
        await this.plugin.saveSettings();
      })
    );
    const vaultSearchEnableIcon = vaultSearchEnableSetting.nameEl.createDiv({ cls: "setting-item-icon" });
    (0, import_obsidian11.setIcon)(vaultSearchEnableIcon, "square-check");
    vaultSearchEnableSetting.nameEl.insertBefore(vaultSearchEnableIcon, vaultSearchEnableSetting.nameEl.firstChild);
    updateFileUI();
    updateFolderUI();
    updateTagUI();
    updateVaultSearchUI();
  }
};

// src/settings/tab-miscellaneous.ts
var import_obsidian12 = require("obsidian");
init_constants();
init_modals();
init_utils();
var MiscellaneousTab = class extends SettingsTabBase {
  constructor(plugin, containerEl) {
    super(plugin, containerEl);
    this.conditionalSettings = [];
    this.plugin.updateAutomaticRenameVisibility = this.updateAutomaticRenameVisibility.bind(this);
  }
  render() {
    const charCountSetting = new import_obsidian12.Setting(this.containerEl).setName("Character count").setDesc("");
    const charCountDesc = charCountSetting.descEl;
    charCountDesc.appendText("The maximum number of characters to put in filename.");
    charCountDesc.createEl("br");
    charCountDesc.createEl("small").createEl("strong", { text: "Default: 100" });
    const charCountContainer = charCountSetting.controlEl.createDiv({ cls: "flit-char-text-input-container" });
    const charCountRestoreButton = charCountContainer.createEl("button", {
      cls: "clickable-icon flit-restore-icon",
      attr: { "aria-label": "Restore default" }
    });
    (0, import_obsidian12.setIcon)(charCountRestoreButton, "rotate-ccw");
    const sliderDiv = charCountContainer.createDiv();
    charCountSetting.addSlider((slider) => {
      slider.setLimits(1, 255, 1).setValue(this.plugin.settings.charCount).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.charCount = value;
        this.plugin.debugLog("charCount", value);
        await this.plugin.saveSettings();
      });
      sliderDiv.appendChild(slider.sliderEl);
    });
    charCountRestoreButton.addEventListener("click", async () => {
      this.plugin.settings.charCount = DEFAULT_SETTINGS.charCount;
      this.plugin.debugLog("charCount", this.plugin.settings.charCount);
      await this.plugin.saveSettings();
      const sliderInput = sliderDiv.querySelector('input[type="range"]');
      if (sliderInput) {
        sliderInput.value = String(DEFAULT_SETTINGS.charCount);
        sliderInput.dispatchEvent(new Event("input", { bubbles: true }));
      }
    });
    const notificationSetting = new import_obsidian12.Setting(this.containerEl).setName("Show notification when renaming manually").setDesc("");
    const notificationDesc = notificationSetting.descEl;
    notificationDesc.appendText("Set when to show notifications for the ");
    notificationDesc.createEl("em", { text: "Put first line in title" });
    notificationDesc.appendText(" commands.");
    notificationSetting.addDropdown(
      (dropdown2) => dropdown2.addOption("Always", "Always").addOption("On title change", "On title change").addOption("Never", "Never").setValue(this.plugin.settings.manualNotificationMode).onChange(async (value) => {
        this.plugin.settings.manualNotificationMode = value;
        this.plugin.debugLog("manualNotificationMode", value);
        await this.plugin.saveSettings();
      })
    );
    const cardLinkSetting = new import_obsidian12.Setting(this.containerEl).setName("Grab title from card link");
    const cardLinkDesc = cardLinkSetting.descEl;
    cardLinkDesc.appendText("If a note starts with a card link created with ");
    cardLinkDesc.createEl("a", {
      text: "Auto Card Link",
      href: "obsidian://show-plugin?id=auto-card-link"
    });
    cardLinkDesc.appendText(" or ");
    cardLinkDesc.createEl("a", {
      text: "Link Embed",
      href: "obsidian://show-plugin?id=obsidian-link-embed"
    });
    cardLinkDesc.appendText(", the card link title will be put in title.");
    cardLinkSetting.addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.grabTitleFromCardLink).onChange(async (value) => {
        this.plugin.settings.grabTitleFromCardLink = value;
        this.plugin.debugLog("grabTitleFromCardLink", value);
        await this.plugin.saveSettings();
      })
    );
    const newNoteDelaySetting = new import_obsidian12.Setting(this.containerEl).setName("New note delay").setDesc("");
    const newNoteDelayDesc = newNoteDelaySetting.descEl;
    newNoteDelayDesc.appendText("Delay operations on new notes by this amount in milliseconds. May resolve issues on note creation.");
    newNoteDelayDesc.createEl("br");
    newNoteDelayDesc.createEl("small").createEl("strong", { text: "Default: 0" });
    const newNoteDelayContainer = newNoteDelaySetting.controlEl.createDiv({ cls: "flit-char-text-input-container" });
    const newNoteDelayRestoreButton = newNoteDelayContainer.createEl("button", {
      cls: "clickable-icon flit-restore-icon",
      attr: { "aria-label": "Restore default" }
    });
    (0, import_obsidian12.setIcon)(newNoteDelayRestoreButton, "rotate-ccw");
    const newNoteDelaySliderDiv = newNoteDelayContainer.createDiv();
    newNoteDelaySetting.addSlider((slider) => {
      slider.setLimits(0, 5e3, 50).setValue(this.plugin.settings.newNoteDelay).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.newNoteDelay = value;
        this.plugin.debugLog("newNoteDelay", value);
        await this.plugin.saveSettings();
      });
      newNoteDelaySliderDiv.appendChild(slider.sliderEl);
    });
    newNoteDelayRestoreButton.addEventListener("click", async () => {
      this.plugin.settings.newNoteDelay = DEFAULT_SETTINGS.newNoteDelay;
      this.plugin.debugLog("newNoteDelay", this.plugin.settings.newNoteDelay);
      await this.plugin.saveSettings();
      const sliderInput = newNoteDelaySliderDiv.querySelector('input[type="range"]');
      if (sliderInput) {
        sliderInput.value = String(DEFAULT_SETTINGS.newNoteDelay);
        sliderInput.dispatchEvent(new Event("input", { bubbles: true }));
      }
    });
    const contentReadMethodSetting = new import_obsidian12.Setting(this.containerEl).setName("Content read method").setDesc("");
    const contentReadDesc = contentReadMethodSetting.descEl;
    contentReadDesc.appendText("Cache or file read may resolve issues but will be slower.");
    contentReadDesc.createEl("br");
    contentReadDesc.createEl("small").createEl("strong", { text: "Default: Editor" });
    const contentReadContainer = contentReadMethodSetting.controlEl.createDiv({ cls: "flit-content-read-container" });
    contentReadContainer.style.display = "flex";
    contentReadContainer.style.gap = "10px";
    const contentReadRestoreButton = contentReadContainer.createEl("button", {
      attr: { "aria-label": "Restore default content read method" },
      cls: "clickable-icon flit-restore-button"
    });
    (0, import_obsidian12.setIcon)(contentReadRestoreButton, "rotate-ccw");
    const dropdown = contentReadContainer.createEl("select", { cls: "dropdown" });
    dropdown.createEl("option", { value: "Editor", text: "Editor" });
    dropdown.createEl("option", { value: "Cache", text: "Cache" });
    dropdown.createEl("option", { value: "File", text: "File" });
    dropdown.value = this.plugin.settings.fileReadMethod;
    contentReadRestoreButton.addEventListener("click", async () => {
      dropdown.value = DEFAULT_SETTINGS.fileReadMethod;
      this.plugin.switchFileReadMode(DEFAULT_SETTINGS.fileReadMethod);
      this.plugin.debugLog("fileReadMethod", this.plugin.settings.fileReadMethod);
      await this.plugin.saveSettings();
      updateCheckIntervalVisibility();
    });
    dropdown.addEventListener("change", async (e) => {
      const newMode = e.target.value;
      this.plugin.switchFileReadMode(newMode);
      this.plugin.debugLog("fileReadMethod", this.plugin.settings.fileReadMethod);
      await this.plugin.saveSettings();
      updateCheckIntervalVisibility();
    });
    const contentReadSubSettingsContainer = this.containerEl.createDiv("flit-sub-settings");
    const updateCheckIntervalVisibility = () => {
      const isEditorMethod = this.plugin.settings.fileReadMethod === "Editor";
      contentReadSubSettingsContainer.style.display = isEditorMethod ? "" : "none";
    };
    const checkIntervalSetting = new import_obsidian12.Setting(contentReadSubSettingsContainer).setName("Check interval").setDesc("");
    const delayDesc = checkIntervalSetting.descEl;
    delayDesc.appendText("Interval in milliseconds for checking first-line changes.  Increase in case of issues.");
    delayDesc.createEl("br");
    delayDesc.createEl("small").createEl("strong", { text: "Default: 0" });
    const checkIntervalContainer = checkIntervalSetting.controlEl.createDiv({ cls: "flit-char-text-input-container" });
    const checkIntervalRestoreButton = checkIntervalContainer.createEl("button", {
      cls: "clickable-icon flit-restore-icon",
      attr: { "aria-label": "Restore default" }
    });
    (0, import_obsidian12.setIcon)(checkIntervalRestoreButton, "rotate-ccw");
    const checkIntervalTextInput = checkIntervalContainer.createEl("input", { type: "text", cls: "flit-char-text-input" });
    checkIntervalTextInput.placeholder = "Empty";
    checkIntervalTextInput.style.width = "120px";
    checkIntervalTextInput.value = String(this.plugin.settings.checkInterval);
    checkIntervalRestoreButton.addEventListener("click", async () => {
      var _a, _b;
      this.plugin.settings.checkInterval = DEFAULT_SETTINGS.checkInterval;
      checkIntervalTextInput.value = String(DEFAULT_SETTINGS.checkInterval);
      this.plugin.debugLog("checkInterval", this.plugin.settings.checkInterval);
      await this.plugin.saveSettings();
      (_b = (_a = this.plugin).initializeCheckingSystem) == null ? void 0 : _b.call(_a);
    });
    checkIntervalTextInput.addEventListener("input", async (e) => {
      var _a, _b, _c, _d;
      const input = e.target;
      let value = input.value;
      value = value.replace(/\D/g, "");
      if (value.length > 4) {
        value = value.slice(0, 4);
      }
      if (value === "") {
        input.value = "";
        this.plugin.settings.checkInterval = DEFAULT_SETTINGS.checkInterval;
        this.plugin.debugLog("checkInterval", this.plugin.settings.checkInterval);
        await this.plugin.saveSettings();
        (_b = (_a = this.plugin).initializeCheckingSystem) == null ? void 0 : _b.call(_a);
        return;
      }
      const numValue = parseInt(value);
      input.value = String(numValue);
      this.plugin.settings.checkInterval = numValue;
      this.plugin.debugLog("checkInterval", this.plugin.settings.checkInterval);
      await this.plugin.saveSettings();
      (_d = (_c = this.plugin).initializeCheckingSystem) == null ? void 0 : _d.call(_c);
    });
    updateCheckIntervalVisibility();
    this.conditionalSettings = [
      checkIntervalSetting
    ];
    let debugSubSettingsContainer;
    const updateDebugSubOptionVisibility = () => {
      if (this.plugin.settings.verboseLogging) {
        debugSubSettingsContainer.style.display = "";
      } else {
        debugSubSettingsContainer.style.display = "none";
      }
    };
    new import_obsidian12.Setting(this.containerEl).setName("Debug").setDesc("Log all of the plugin's activity to the developer console.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.verboseLogging).onChange(async (value) => {
        this.plugin.settings.verboseLogging = value;
        if (value) {
          this.plugin.settings.debugEnabledTimestamp = this.plugin.getCurrentTimestamp();
        }
        this.plugin.debugLog("verboseLogging", value);
        await this.plugin.saveSettings();
        updateDebugSubOptionVisibility();
        if (value) {
          this.plugin.outputAllSettings();
        }
      })
    );
    debugSubSettingsContainer = this.containerEl.createDiv("flit-sub-settings");
    const debugContentSetting = new import_obsidian12.Setting(debugSubSettingsContainer).setName("Output full file content in console").setDesc("Log the complete content of files (including YAML frontmatter) whenever they are modified.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.debugOutputFullContent).onChange(async (value) => {
        this.plugin.settings.debugOutputFullContent = value;
        this.plugin.debugLog("debugOutputFullContent", value);
        await this.plugin.saveSettings();
      })
    );
    updateDebugSubOptionVisibility();
    new import_obsidian12.Setting(this.containerEl).setName("Clear settings").setDesc("Reset all plugin settings to their default values.").addButton((button) => {
      button.setButtonText("Clear").setWarning().onClick(async () => {
        new ClearSettingsModal(this.plugin.app, this.plugin, async () => {
          this.plugin.settings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
          this.plugin.settings.scopeStrategy = "Don't rename in...";
          this.plugin.settings.hasShownFirstTimeNotice = true;
          this.plugin.settings.lastUsageDate = this.plugin.getTodayDateString();
          await this.plugin.saveSettings();
          verboseLog(this.plugin, `Showing notice: Settings have been cleared.`);
          new import_obsidian12.Notice("Settings have been cleared.");
          const settingsTab = this.plugin.settingsTab;
          if (settingsTab && settingsTab.display) {
            settingsTab.display();
          } else {
            this.containerEl.empty();
            this.render();
          }
        }).open();
      });
    });
    this.updateAutomaticRenameVisibility();
  }
  updateAutomaticRenameVisibility() {
    if (this.conditionalSettings.length === 0) return;
    const shouldShow = this.plugin.settings.renameNotes === "automatically";
    this.conditionalSettings.forEach((setting) => {
      if (shouldShow) {
        setting.settingEl.style.display = "";
      } else {
        setting.settingEl.style.display = "none";
      }
    });
  }
};

// src/settings/settings-main.ts
var FirstLineIsTitleSettings = class extends import_obsidian13.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.settingsPage = null;
    this.TABS = {
      GENERAL: { id: "general", name: "General", class: GeneralTab },
      INCLUDE_EXCLUDE: { id: "include-exclude", name: "Exclusions", class: IncludeExcludeTab },
      FORBIDDEN_CHARS: { id: "forbidden-chars", name: "Replace characters", class: ForbiddenCharsTab },
      CUSTOM_REPLACEMENTS: { id: "custom-replacements", name: "Custom rules", class: CustomReplacementsTab },
      SAFEWORDS: { id: "safewords", name: "Safewords", class: SafewordsTab },
      STRIP_MARKUP: { id: "strip-markup", name: "Strip markup", class: StripMarkupTab },
      PROPERTIES: { id: "properties", name: "Alias", class: PropertiesTab },
      COMMANDS: { id: "commands", name: "Commands", class: CommandsTab },
      MISCELLANEOUS: { id: "miscellaneous", name: "Miscellaneous", class: MiscellaneousTab }
    };
    this.plugin = plugin;
  }
  display() {
    this.containerEl.empty();
    const tabBar = this.containerEl.createEl("nav", { cls: "flit-settings-tab-bar" });
    tabBar.setAttribute("role", "tablist");
    const tabElements = [];
    const activateTab = (tabEl, tabInfo) => {
      for (const child of tabBar.children) {
        child.removeClass("flit-settings-tab-active");
        child.setAttribute("aria-selected", "false");
        child.setAttribute("tabindex", "-1");
      }
      tabEl.addClass("flit-settings-tab-active");
      tabEl.setAttribute("aria-selected", "true");
      tabEl.setAttribute("tabindex", "0");
      this.plugin.settings.currentSettingsTab = tabInfo.id;
      this.plugin.saveSettings();
      this.renderTab(tabInfo.id);
    };
    for (const [tabKey, tabInfo] of Object.entries(this.TABS)) {
      const tabEl = tabBar.createEl("div", { cls: "flit-settings-tab" });
      tabEl.setAttribute("data-tab-id", tabInfo.id);
      tabEl.setAttribute("role", "tab");
      const isActive = this.plugin.settings.currentSettingsTab === tabInfo.id;
      tabEl.setAttribute("tabindex", isActive ? "0" : "-1");
      tabEl.setAttribute("aria-selected", isActive ? "true" : "false");
      const tabNameEl = tabEl.createEl("div", { cls: "flit-settings-tab-name", text: tabInfo.name });
      if (isActive) {
        tabEl.addClass("flit-settings-tab-active");
      }
      tabEl.addEventListener("click", () => {
        activateTab(tabEl, tabInfo);
      });
      tabEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          activateTab(tabEl, tabInfo);
        } else if (e.key === "ArrowRight" || e.key === "ArrowLeft" || e.key === "ArrowUp" || e.key === "ArrowDown") {
          e.preventDefault();
          const currentIndex = tabElements.indexOf(tabEl);
          const rows = [];
          let currentRow = [];
          let lastTop = -1;
          tabElements.forEach((tab) => {
            const rect = tab.getBoundingClientRect();
            if (lastTop === -1 || Math.abs(rect.top - lastTop) < 5) {
              currentRow.push(tab);
              lastTop = rect.top;
            } else {
              if (currentRow.length > 0) {
                rows.push(currentRow);
              }
              currentRow = [tab];
              lastTop = rect.top;
            }
          });
          if (currentRow.length > 0) {
            rows.push(currentRow);
          }
          let currentRowIndex = 0;
          let currentColIndex = 0;
          for (let r = 0; r < rows.length; r++) {
            const colIndex = rows[r].indexOf(tabEl);
            if (colIndex !== -1) {
              currentRowIndex = r;
              currentColIndex = colIndex;
              break;
            }
          }
          let nextTab = null;
          if (e.key === "ArrowRight") {
            const nextCol = currentColIndex + 1;
            if (nextCol < rows[currentRowIndex].length) {
              nextTab = rows[currentRowIndex][nextCol];
            } else {
              const nextRow = (currentRowIndex + 1) % rows.length;
              nextTab = rows[nextRow][0];
            }
          } else if (e.key === "ArrowLeft") {
            const prevCol = currentColIndex - 1;
            if (prevCol >= 0) {
              nextTab = rows[currentRowIndex][prevCol];
            } else {
              const prevRow = (currentRowIndex - 1 + rows.length) % rows.length;
              nextTab = rows[prevRow][rows[prevRow].length - 1];
            }
          } else if (e.key === "ArrowDown") {
            const nextRow = currentRowIndex + 1;
            if (nextRow < rows.length) {
              const targetCol = Math.min(currentColIndex, rows[nextRow].length - 1);
              nextTab = rows[nextRow][targetCol];
            } else {
              const targetCol = Math.min(currentColIndex, rows[0].length - 1);
              nextTab = rows[0][targetCol];
            }
          } else if (e.key === "ArrowUp") {
            const prevRow = currentRowIndex - 1;
            if (prevRow >= 0) {
              const targetCol = Math.min(currentColIndex, rows[prevRow].length - 1);
              nextTab = rows[prevRow][targetCol];
            } else {
              const lastRow = rows.length - 1;
              const targetCol = Math.min(currentColIndex, rows[lastRow].length - 1);
              nextTab = rows[lastRow][targetCol];
            }
          }
          if (nextTab) {
            nextTab.focus();
          }
        } else if (e.key === "Home") {
          e.preventDefault();
          tabElements[0].focus();
        } else if (e.key === "End") {
          e.preventDefault();
          tabElements[tabElements.length - 1].focus();
        }
      });
      tabElements.push(tabEl);
    }
    this.settingsPage = this.containerEl.createDiv({ cls: "flit-settings-page" });
    this.renderTab(this.plugin.settings.currentSettingsTab);
    setTimeout(() => {
      if (document.activeElement instanceof HTMLElement) {
        document.activeElement.blur();
      }
    }, 0);
    let hasHandledFirstTab = false;
    const handleFirstTab = (e) => {
      if (e.key === "Tab" && !hasHandledFirstTab) {
        const focusedElement = document.activeElement;
        const isOnTab = focusedElement && focusedElement.classList.contains("flit-settings-tab");
        if (!isOnTab) {
          hasHandledFirstTab = true;
          const activeTab = tabBar.querySelector(".flit-settings-tab-active");
          if (activeTab) {
            e.preventDefault();
            activeTab.focus();
          }
        }
      }
    };
    this.containerEl.addEventListener("keydown", handleFirstTab);
  }
  async renderTab(tabId) {
    if (!this.settingsPage) return;
    this.settingsPage.empty();
    const tabConfig = Object.values(this.TABS).find((tab) => tab.id === tabId);
    if (tabConfig) {
      const tabInstance = new tabConfig.class(this.plugin, this.settingsPage);
      await tabInstance.render();
    } else {
      const generalTab = new GeneralTab(this.plugin, this.settingsPage);
      await generalTab.render();
    }
  }
};

// src/core/rename-engine.ts
var import_obsidian14 = require("obsidian");
init_constants();
init_utils();
var RenameEngine = class {
  constructor(plugin) {
    this.lastProcessedContent = /* @__PURE__ */ new Map();
    this.filesCurrentlyProcessing = /* @__PURE__ */ new Set();
    // Track by file.stat.ctime (stable across renames)
    this.filesNeedingRecheck = /* @__PURE__ */ new Set();
    // Track files that had edits blocked during processing
    this.fileTimeTracker = /* @__PURE__ */ new Map();
    this.globalOperationTracker = { timestamp: Date.now(), count: 0 };
    this.lastSelfRefNotice = /* @__PURE__ */ new Map();
    this.plugin = plugin;
  }
  checkFileTimeLimit(file) {
    const now = Date.now();
    const windowMs = 500;
    const maxOpsPerFile = 15;
    const key = file.path;
    const tracker = this.fileTimeTracker.get(key);
    if (!tracker || now - tracker.timestamp > windowMs) {
      this.fileTimeTracker.set(key, { timestamp: now, count: 1 });
      return true;
    }
    if (tracker.count >= maxOpsPerFile) {
      console.log(`Per-file rate limit hit for ${file.path} - ${tracker.count} operations in ${now - tracker.timestamp}ms`);
      return false;
    }
    tracker.count++;
    return true;
  }
  checkGlobalRateLimit() {
    const now = Date.now();
    const windowMs = 500;
    const maxGlobalOps = 30;
    if (now - this.globalOperationTracker.timestamp > windowMs) {
      this.globalOperationTracker = { timestamp: now, count: 1 };
      return true;
    }
    if (this.globalOperationTracker.count >= maxGlobalOps) {
      console.log(`Global rate limit hit - ${this.globalOperationTracker.count} operations in ${now - this.globalOperationTracker.timestamp}ms`);
      return false;
    }
    this.globalOperationTracker.count++;
    return true;
  }
  async processEditorChangeOptimal(editor, file) {
    this.plugin.trackUsage();
    const startTime = Date.now();
    try {
      const fileId = file.stat.ctime;
      if (this.filesCurrentlyProcessing.has(fileId)) {
        verboseLog(this.plugin, `Editor change ignored - file already processing (ID ${fileId}): ${file.path}`);
        this.filesNeedingRecheck.add(fileId);
        return;
      }
      if (this.plugin.aliasManager.isAliasUpdateInProgress(file.path)) {
        verboseLog(this.plugin, `Editor change ignored - alias update in progress: ${file.path}`);
        return;
      }
      const currentContent = editor.getValue();
      const lines = currentContent.split("\n");
      let firstLineIndex = 0;
      if (lines.length > 0 && lines[0].trim() === "---") {
        for (let i = 1; i < lines.length; i++) {
          if (lines[i].trim() === "---") {
            firstLineIndex = i + 1;
            break;
          }
        }
      }
      const metadata = this.plugin.app.metadataCache.getFileCache(file);
      let firstLine = "";
      for (let i = firstLineIndex; i < lines.length; i++) {
        const line = lines[i];
        if (line.trim() !== "") {
          firstLine = line;
          break;
        }
      }
      let trackingContent = firstLine;
      const contentWithoutFrontmatter = lines.slice(firstLineIndex).join("\n");
      const trimmedFirstLine = firstLine.trim();
      if (this.plugin.settings.grabTitleFromCardLink && trimmedFirstLine.match(/^```(embed|cardlink)$/)) {
        const allLines = contentWithoutFrontmatter.split("\n");
        let nonEmptyCount = 0;
        for (let i = 0; i < allLines.length; i++) {
          const line = allLines[i].trim();
          if (line === "") continue;
          nonEmptyCount++;
          if (nonEmptyCount === 1) continue;
          if (nonEmptyCount > 10) break;
          if (line.startsWith("title:")) {
            let title = line.substring(6).trim();
            if (title.startsWith('"') && title.endsWith('"') || title.startsWith("'") && title.endsWith("'")) {
              title = title.substring(1, title.length - 1);
            }
            trackingContent = title;
            break;
          }
          if (line.startsWith("```")) {
            trackingContent = "Untitled";
            break;
          }
        }
      } else if (trimmedFirstLine.startsWith("```") && !trimmedFirstLine.match(/^```(embed|cardlink)$/)) {
        const contentLines = contentWithoutFrontmatter.split("\n");
        let extractedLines = [];
        for (const line of contentLines) {
          if (line.trim() !== "") {
            extractedLines.push(line);
            if (extractedLines.length >= 2) break;
          }
        }
        trackingContent = extractTitle(extractedLines.join("\n"), this.plugin.settings);
      } else {
        trackingContent = extractTitle(firstLine, this.plugin.settings);
      }
      const lastContent = this.lastProcessedContent.get(file.path);
      if (trackingContent !== lastContent) {
        const timeSinceStart = Date.now() - startTime;
        verboseLog(this.plugin, `[TIMING] KEYSTROKE: ${file.path} - "${lastContent}" -> "${trackingContent}" (processed in ${timeSinceStart}ms)`);
        this.lastProcessedContent.set(file.path, trackingContent);
        this.plugin.editorLifecycle.updateLastFirstLine(file.path, trackingContent);
        this.filesCurrentlyProcessing.add(fileId);
        try {
          await this.processFileImmediate(file, currentContent, metadata);
        } finally {
          this.filesCurrentlyProcessing.delete(fileId);
          if (this.filesNeedingRecheck.has(fileId)) {
            this.filesNeedingRecheck.delete(fileId);
            const currentEditorContent = editor.getValue();
            const recheckLines = currentEditorContent.split("\n");
            let recheckFirstLine = "";
            let recheckFirstLineIndex = 0;
            if (recheckLines.length > 0 && recheckLines[0].trim() === "---") {
              for (let i = 1; i < recheckLines.length; i++) {
                if (recheckLines[i].trim() === "---") {
                  recheckFirstLineIndex = i + 1;
                  break;
                }
              }
            }
            for (let i = recheckFirstLineIndex; i < recheckLines.length; i++) {
              if (recheckLines[i].trim() !== "") {
                recheckFirstLine = recheckLines[i];
                break;
              }
            }
            const recheckContent = extractTitle(recheckFirstLine, this.plugin.settings);
            const currentlyProcessed = this.lastProcessedContent.get(file.path);
            if (recheckContent !== currentlyProcessed) {
              verboseLog(this.plugin, `RECHECK: Content changed during processing, triggering final check: ${file.path}`);
              setTimeout(() => this.processEditorChangeOptimal(editor, file), 0);
            }
          }
        }
      } else {
        verboseLog(this.plugin, `Editor change ignored - no first line change: ${file.path}`);
      }
    } catch (error) {
      console.error(`Error in optimal editor-change processing for ${file.path}:`, error);
    }
  }
  async processFileImmediate(file, content, metadata) {
    if (file.extension !== "md") {
      return;
    }
    if (!shouldProcessFile(file, this.plugin.settings, this.plugin.app, content)) {
      return;
    }
    verboseLog(this.plugin, `PROCESS: Starting immediate processFile for ${file.path}`);
    try {
      await this.processFile(file, true, false, content);
    } catch (error) {
      console.error(`Error in immediate process for ${file.path}:`, error);
    }
  }
  stripFrontmatterFromContent(content, file) {
    if (!content) return "";
    const lines = content.split("\n");
    if (lines.length > 0 && lines[0].trim() === "---") {
      for (let i = 1; i < lines.length; i++) {
        if (lines[i].trim() === "---") {
          const strippedContent = lines.slice(i + 1).join("\n");
          verboseLog(this.plugin, `Stripped frontmatter from ${file.path} (lines 0-${i} removed)`);
          return strippedContent;
        }
      }
    }
    return content;
  }
  async processFile(file, noDelay = false, showNotices = false, providedContent, isBatchOperation = false, exclusionOverrides, isManualCommand = false) {
    var _a, _b, _c;
    this.plugin.trackUsage();
    verboseLog(this.plugin, `Processing file: ${file.path}`, { noDelay });
    const currentFile = this.plugin.app.vault.getAbstractFileByPath(file.path);
    if (!currentFile || !(currentFile instanceof import_obsidian14.TFile)) {
      verboseLog(this.plugin, `Skipping processing - file no longer exists or is not a TFile: ${file.path}`);
      return { success: false, reason: "file-not-found" };
    }
    file = currentFile;
    if (file.extension !== "md") {
      verboseLog(this.plugin, `Skipping non-markdown file: ${file.path}`);
      return { success: false, reason: "not-markdown" };
    }
    if (await hasDisablePropertyInFile(file, this.plugin.app, this.plugin.settings.disableRenamingKey, this.plugin.settings.disableRenamingValue)) {
      verboseLog(this.plugin, `ABSOLUTE BLOCK: Skipping file with disable property: ${file.path}`);
      if (showNotices && !isBatchOperation) {
        new import_obsidian14.Notice("Property to disable renaming prevents rename.");
      }
      return { success: false, reason: "property-disabled" };
    }
    let contentForRateLimit;
    if (providedContent) {
      contentForRateLimit = providedContent;
    } else {
      try {
        contentForRateLimit = await this.plugin.app.vault.read(file);
      } catch (error) {
        console.error(`Error reading file for rate limit check: ${file.path}`, error);
        return { success: false, reason: "read-error" };
      }
    }
    if (!this.checkFileTimeLimit(file)) {
      return { success: false, reason: "time-rate-limited" };
    }
    if (!isBatchOperation) {
      if (!this.checkGlobalRateLimit()) {
        return { success: false, reason: "global-rate-limited" };
      }
    }
    let initialContent;
    try {
      initialContent = await this.plugin.app.vault.read(file);
    } catch (error) {
    }
    if (!shouldProcessFile(file, this.plugin.settings, this.plugin.app, initialContent, exclusionOverrides)) {
      verboseLog(this.plugin, `Skipping file based on include/exclude strategy: ${file.path}`);
      return { success: false, reason: "excluded" };
    }
    const startTime = Date.now();
    verboseLog(this.plugin, `RENAME: Starting renameFile for ${file.name}`);
    const cacheManager = this.plugin.cacheManager;
    const previousFileContent = cacheManager == null ? void 0 : cacheManager.getContent(file.path);
    let content;
    try {
      if (this.plugin.settings.fileReadMethod === "Editor") {
        if (typeof providedContent === "string" && providedContent !== "") {
          content = providedContent;
          verboseLog(this.plugin, `Using provided editor content for ${file.path} (${content.length} chars)`);
        } else {
          content = await this.plugin.app.vault.cachedRead(file);
          verboseLog(this.plugin, `Editor method fallback to cached read for ${file.path} (${content.length} chars)`);
        }
      } else if (this.plugin.settings.fileReadMethod === "Cache") {
        content = await this.plugin.app.vault.cachedRead(file);
        verboseLog(this.plugin, `Cached read content from ${file.path} (${content.length} chars)`);
      } else if (this.plugin.settings.fileReadMethod === "File") {
        content = await this.plugin.app.vault.read(file);
        verboseLog(this.plugin, `Direct read content from ${file.path} (${content.length} chars)`);
      } else {
        content = await this.plugin.app.vault.cachedRead(file);
        verboseLog(this.plugin, `Unknown method, fallback to cached read for ${file.path} (${content.length} chars)`);
      }
    } catch (error) {
      console.error(`Failed to read file ${file.path}:`, error);
      throw new Error(`Failed to read file: ${error.message}`);
    }
    if (containsSafeword(file.name, this.plugin.settings)) {
      verboseLog(this.plugin, `Skipping file with safeword: ${file.path}`);
      return { success: false, reason: "safeword" };
    }
    const currentName = file.basename;
    const contentWithoutFrontmatter = this.stripFrontmatterFromContent(content, file);
    const lines = contentWithoutFrontmatter.split("\n");
    let firstLine = "";
    for (const line of lines) {
      if (line.trim() !== "") {
        firstLine = line;
        break;
      }
    }
    if (firstLine === "") {
      const previousContentWithoutFrontmatter = previousFileContent ? this.stripFrontmatterFromContent(previousFileContent, file) : "";
      const hadPreviousContent = previousContentWithoutFrontmatter.trim() !== "";
      if (hadPreviousContent) {
        verboseLog(this.plugin, `Content became empty - renaming to Untitled: ${file.path}`);
        firstLine = "Untitled";
      } else {
        cacheManager == null ? void 0 : cacheManager.setContent(file.path, content);
        verboseLog(this.plugin, `Skipping rename for empty file - retaining current filename: ${file.path}`);
        return { success: false, reason: "empty-content-retained" };
      }
    }
    if (this.plugin.settings.whatToPutInTitle === "headings_only") {
      if (!isValidHeading(firstLine)) {
        verboseLog(this.plugin, `Skipping file - first line is not a valid heading: ${file.path}`);
        return { success: false, reason: "not-heading" };
      }
    }
    if (this.plugin.settings.grabTitleFromCardLink) {
      const cardLinkMatch = firstLine.trim().match(/^```(embed|cardlink)$/);
      if (cardLinkMatch) {
        const allLines = contentWithoutFrontmatter.split("\n");
        let foundTitle = false;
        let nonEmptyCount = 0;
        for (let i = 0; i < allLines.length; i++) {
          const line = allLines[i].trim();
          if (line === "") continue;
          nonEmptyCount++;
          if (nonEmptyCount === 1) continue;
          if (nonEmptyCount > 10) break;
          if (line.startsWith("title:")) {
            let title = line.substring(6).trim();
            if (title.startsWith('"') && title.endsWith('"') || title.startsWith("'") && title.endsWith("'")) {
              title = title.substring(1, title.length - 1);
            }
            firstLine = title;
            foundTitle = true;
            verboseLog(this.plugin, `Found ${cardLinkMatch[1]} card link in ${file.path}`, { title: firstLine });
            break;
          }
          if (line.startsWith("```")) {
            firstLine = "Untitled";
            verboseLog(this.plugin, `Card link in ${file.path} has no title, using Untitled`);
            break;
          }
        }
        if (!foundTitle && firstLine !== "Untitled") {
          firstLine = "Untitled";
        }
      }
    }
    const contentBecameEmpty = contentWithoutFrontmatter.trim() === "" && firstLine === "Untitled";
    if (!contentBecameEmpty) {
      cacheManager == null ? void 0 : cacheManager.setContent(file.path, content);
    }
    const originalContentWithFrontmatter = content;
    content = contentWithoutFrontmatter;
    const escapedName = currentName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const pathWithoutExt = file.path.replace(/\.md$/, "");
    const escapedPath = pathWithoutExt.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const wikiLinkRegex = new RegExp(`\\[\\[(${escapedName}|${escapedPath})(#[^\\]|]*?)?(\\|.*?)?\\]\\]`);
    const markdownLinkRegex = /\[([^\]]*)\]\(([^)]+)\)/g;
    let isSelfReferencing = false;
    if (wikiLinkRegex.test(firstLine)) {
      isSelfReferencing = true;
      verboseLog(this.plugin, `Found self-referencing wikilink in ${file.path} before custom replacements`);
    }
    let match;
    while ((match = markdownLinkRegex.exec(firstLine)) !== null) {
      const url = match[2];
      let decodedUrl = url;
      try {
        decodedUrl = decodeURIComponent(url);
      } catch (e) {
      }
      if (url.startsWith("#")) {
        isSelfReferencing = true;
        verboseLog(this.plugin, `Found self-referencing markdown link (fragment) in ${file.path} before custom replacements`);
        break;
      }
      const urlWithoutFragment = decodedUrl.split("#")[0];
      if (urlWithoutFragment && (urlWithoutFragment === `${currentName}.md` || urlWithoutFragment === currentName || urlWithoutFragment === `${pathWithoutExt}.md` || urlWithoutFragment === pathWithoutExt)) {
        isSelfReferencing = true;
        verboseLog(this.plugin, `Found self-referencing markdown link (percent-encoded) in ${file.path} before custom replacements`);
        break;
      }
    }
    let processedTitle = firstLine;
    verboseLog(this.plugin, `Custom replacements enabled: ${this.plugin.settings.enableCustomReplacements}, count: ${((_a = this.plugin.settings.customReplacements) == null ? void 0 : _a.length) || 0}`);
    if (this.plugin.settings.enableCustomReplacements) {
      for (const replacement of this.plugin.settings.customReplacements) {
        if (replacement.searchText === "" || !replacement.enabled) continue;
        verboseLog(this.plugin, `Checking custom replacement:`, {
          searchText: replacement.searchText,
          replaceText: replacement.replaceText,
          onlyWholeLine: replacement.onlyWholeLine,
          onlyAtStart: replacement.onlyAtStart,
          enabled: replacement.enabled,
          currentLine: processedTitle
        });
        let tempLine = processedTitle;
        if (replacement.onlyWholeLine) {
          if (processedTitle.trim() === replacement.searchText.trim()) {
            tempLine = replacement.replaceText;
            verboseLog(this.plugin, `Applied whole line replacement:`, { from: processedTitle, to: tempLine });
          }
        } else if (replacement.onlyAtStart) {
          if (tempLine.startsWith(replacement.searchText)) {
            tempLine = replacement.replaceText + tempLine.slice(replacement.searchText.length);
            verboseLog(this.plugin, `Applied start replacement:`, { from: processedTitle, to: tempLine });
          }
        } else {
          const beforeReplace = tempLine;
          tempLine = tempLine.replaceAll(replacement.searchText, replacement.replaceText);
          if (beforeReplace !== tempLine) {
            verboseLog(this.plugin, `Applied general replacement:`, { from: beforeReplace, to: tempLine });
          }
        }
        processedTitle = tempLine;
      }
    }
    if (processedTitle.trim() === "") {
      processedTitle = "Untitled";
    }
    verboseLog(this.plugin, isSelfReferencing ? `Self-reference found in ${file.path}` : `No self-reference found in ${file.path}`);
    let contentForExtraction = processedTitle;
    const trimmedFirstLine = firstLine.trim();
    if (trimmedFirstLine.startsWith("```") && !trimmedFirstLine.match(/^```(embed|cardlink)$/)) {
      const contentLines = contentWithoutFrontmatter.split("\n");
      let extractedLines = [];
      for (const line of contentLines) {
        if (line.trim() !== "") {
          extractedLines.push(line);
          if (extractedLines.length >= 2) break;
        }
      }
      contentForExtraction = extractedLines.join("\n");
    }
    const extractedTitle = extractTitle(contentForExtraction, this.plugin.settings);
    verboseLog(this.plugin, `Extracted title from ${file.path}`, { original: firstLine, afterCustomReplacements: processedTitle, extracted: extractedTitle });
    const charMap = {
      "/": this.plugin.settings.charReplacements.slash,
      ":": this.plugin.settings.charReplacements.colon,
      "|": this.plugin.settings.charReplacements.pipe,
      "#": this.plugin.settings.charReplacements.hash,
      "[": this.plugin.settings.charReplacements.leftBracket,
      "]": this.plugin.settings.charReplacements.rightBracket,
      "^": this.plugin.settings.charReplacements.caret,
      "*": this.plugin.settings.charReplacements.asterisk,
      "?": this.plugin.settings.charReplacements.question,
      "<": this.plugin.settings.charReplacements.lessThan,
      ">": this.plugin.settings.charReplacements.greaterThan,
      '"': this.plugin.settings.charReplacements.quote,
      [String.fromCharCode(92)]: this.plugin.settings.charReplacements.backslash,
      ".": this.plugin.settings.charReplacements.dot
    };
    const universalForbiddenChars = UNIVERSAL_FORBIDDEN_CHARS;
    const windowsAndroidChars = WINDOWS_ANDROID_CHARS;
    const allForbiddenChars = [...universalForbiddenChars];
    const currentOS = detectOS();
    if (currentOS === "Windows" || this.plugin.settings.windowsAndroidEnabled) {
      allForbiddenChars.push(...windowsAndroidChars);
    }
    const forbiddenChars = [...new Set(allForbiddenChars)].join("");
    const forbiddenNames = [
      "CON",
      "PRN",
      "AUX",
      "NUL",
      "COM1",
      "COM2",
      "COM3",
      "COM4",
      "COM5",
      "COM6",
      "COM7",
      "COM8",
      "COM9",
      "COM0",
      "LPT1",
      "LPT2",
      "LPT3",
      "LPT4",
      "LPT5",
      "LPT6",
      "LPT7",
      "LPT8",
      "LPT9",
      "LPT0"
    ];
    let newFileName = "";
    for (let i = 0; i < extractedTitle.length; i++) {
      if (newFileName.length >= this.plugin.settings.charCount - 1) {
        newFileName = newFileName.trimEnd();
        newFileName += "\u2026";
        break;
      }
      let char = extractedTitle[i];
      if (char === ".") {
        if (newFileName === "") {
          if (this.plugin.settings.enableForbiddenCharReplacements && this.plugin.settings.charReplacementEnabled.dot) {
            const replacement = charMap["."] || "";
            if (replacement !== "") {
              if (this.plugin.settings.charReplacementTrimRight.dot) {
                while (i + 1 < extractedTitle.length && /\s/.test(extractedTitle[i + 1])) {
                  i++;
                }
              }
              newFileName += replacement;
              verboseLog(this.plugin, `Replaced leading dot with \`${replacement}\` in ${file.path}`);
            }
          }
        } else {
          newFileName += ".";
        }
      } else if (forbiddenChars.includes(char)) {
        let shouldReplace = false;
        let replacement = "";
        if (this.plugin.settings.enableForbiddenCharReplacements) {
          let settingKey = null;
          switch (char) {
            case "/":
              settingKey = "slash";
              break;
            case String.fromCharCode(92):
              settingKey = "backslash";
              break;
            case ":":
              settingKey = "colon";
              break;
            case "|":
              settingKey = "pipe";
              break;
            case "#":
              settingKey = "hash";
              break;
            case "[":
              settingKey = "leftBracket";
              break;
            case "]":
              settingKey = "rightBracket";
              break;
            case "^":
              settingKey = "caret";
              break;
            case "*":
              settingKey = "asterisk";
              break;
            case "?":
              settingKey = "question";
              break;
            case "<":
              settingKey = "lessThan";
              break;
            case ">":
              settingKey = "greaterThan";
              break;
            case '"':
              settingKey = "quote";
              break;
          }
          const isWindowsAndroidChar = WINDOWS_ANDROID_CHARS.includes(char);
          const canReplace = isWindowsAndroidChar ? this.plugin.settings.windowsAndroidEnabled && settingKey && this.plugin.settings.charReplacementEnabled[settingKey] : settingKey && this.plugin.settings.charReplacementEnabled[settingKey];
          if (canReplace && settingKey) {
            shouldReplace = true;
            replacement = charMap[char] || "";
            if (replacement !== "") {
              if (this.plugin.settings.charReplacementTrimLeft[settingKey]) {
                newFileName = newFileName.trimEnd();
              }
              if (this.plugin.settings.charReplacementTrimRight[settingKey]) {
                while (i + 1 < extractedTitle.length && /\s/.test(extractedTitle[i + 1])) {
                  i++;
                }
              }
            }
          }
        }
        if (shouldReplace && replacement !== "") {
          newFileName += replacement;
          verboseLog(this.plugin, `Replaced forbidden char \`${char}\` with \`${replacement}\` in ${file.path}`);
        }
      } else {
        newFileName += char;
      }
    }
    newFileName = newFileName.trim().replace(/\s+/g, " ");
    const isForbiddenName = newFileName === "" || forbiddenNames.includes(newFileName.toUpperCase());
    if (isForbiddenName) {
      newFileName = "Untitled";
      verboseLog(this.plugin, `Using fallback name \`Untitled\` for ${file.path}`);
    }
    const parentPath = ((_b = file.parent) == null ? void 0 : _b.path) === "/" ? "" : ((_c = file.parent) == null ? void 0 : _c.path) + "/";
    let newPath = `${parentPath}${newFileName}.md`;
    verboseLog(this.plugin, `Initial target path: ${newPath} for file: ${file.path}`);
    if (file.path === newPath) {
      verboseLog(this.plugin, `No rename needed for ${file.path} - already has correct name`);
      if (isManualCommand) {
        console.log(`Renamed to: ${currentName}
Original filename: ${currentName}`);
      }
      if (this.plugin.settings.enableAliases) {
        await this.plugin.aliasManager.updateAliasIfNeeded(file, originalContentWithFrontmatter);
      }
      verboseLog(this.plugin, `Notification check (no rename): showNotices=${showNotices}, isBatchOperation=${isBatchOperation}, manualNotificationMode=${this.plugin.settings.manualNotificationMode}`);
      if (showNotices && !isBatchOperation) {
        const shouldShowNotice = this.plugin.settings.manualNotificationMode === "Always";
        verboseLog(this.plugin, `shouldShowNotice (no rename)=${shouldShowNotice}`);
        if (shouldShowNotice) {
          verboseLog(this.plugin, `Showing notice: Renamed to: ${currentName}`);
          new import_obsidian14.Notice(`Renamed to: ${currentName}`);
        }
      }
      return { success: false, reason: "no-rename-needed" };
    }
    let counter = 0;
    let fileExists = this.checkFileExistsCaseInsensitive(newPath);
    const tempPathConflict = false;
    verboseLog(this.plugin, `Conflict check for ${newPath}: fileExists=${fileExists}, tempPathConflict=${tempPathConflict} (tempNewPaths eliminated)`);
    if (fileExists || tempPathConflict) {
      verboseLog(this.plugin, `Found conflicts for ${newPath}, starting counter loop`);
      while (fileExists) {
        if (file.path === newPath) {
          verboseLog(this.plugin, `No rename needed for ${file.path} - already has correct name with counter`);
          return { success: false, reason: "no-rename-needed" };
        }
        counter += 1;
        newPath = `${parentPath}${newFileName} ${counter}.md`;
        fileExists = this.checkFileExistsCaseInsensitive(newPath);
      }
      verboseLog(this.plugin, `Found available filename with counter ${counter}: ${newPath}`);
    } else {
      verboseLog(this.plugin, `No conflicts found for ${newPath}, proceeding without counter`);
    }
    if (isSelfReferencing) {
      if (!isBatchOperation) {
        const now = Date.now();
        const lastNoticeTime = this.lastSelfRefNotice.get(file.path) || 0;
        if (now - lastNoticeTime >= 2e3) {
          verboseLog(this.plugin, `Showing notice: File not renamed due to self-referential link in first line: ${file.basename}`);
          new import_obsidian14.Notice(`Note not renamed due to self-referential link in first line: ${file.basename}`);
          this.lastSelfRefNotice.set(file.path, now);
        }
      }
      verboseLog(this.plugin, `Skipping self-referencing file: ${file.path}`);
      return { success: false, reason: "self-referential" };
    }
    if (noDelay) {
      cacheManager == null ? void 0 : cacheManager.reservePath(newPath);
    }
    try {
      if (isBatchOperation) {
        this.plugin.markBatchOperationStart(file.path);
      }
      this.plugin.markFlitModificationStart(file.path);
      const oldPath = file.path;
      const oldBasename = file.basename;
      if ((cacheManager == null ? void 0 : cacheManager.isFirstRename(oldPath)) || isManualCommand) {
        const newBasename = newPath.replace(/\.md$/, "").split("/").pop() || newFileName;
        console.log(`Renamed to: ${newBasename}
Original filename: ${oldBasename}`);
        if (!isManualCommand) {
          cacheManager.markFileRenamed(oldPath);
        }
      }
      await this.plugin.app.fileManager.renameFile(file, newPath);
      const processingTime = Date.now() - startTime;
      verboseLog(this.plugin, `Successfully renamed ${oldPath} to ${newPath} (${processingTime}ms)`);
      this.plugin.markFlitModificationEnd(newPath);
      if (isBatchOperation) {
        this.plugin.markBatchOperationEnd(newPath);
      }
      const lastContent = this.lastProcessedContent.get(oldPath);
      if (lastContent !== void 0) {
        this.lastProcessedContent.delete(oldPath);
        this.lastProcessedContent.set(newPath, lastContent);
      }
      cacheManager == null ? void 0 : cacheManager.notifyFileRenamed(oldPath, newPath);
      if (this.plugin.settings.enableAliases) {
        const renamedFile = this.plugin.app.vault.getAbstractFileByPath(newPath);
        if (renamedFile && renamedFile instanceof import_obsidian14.TFile) {
          await this.plugin.aliasManager.updateAliasIfNeeded(renamedFile, originalContentWithFrontmatter, newFileName);
        }
      }
      verboseLog(this.plugin, `Notification check: showNotices=${showNotices}, isBatchOperation=${isBatchOperation}, manualNotificationMode=${this.plugin.settings.manualNotificationMode}`);
      if (showNotices && !isBatchOperation) {
        const finalFileName = newPath.replace(/\.md$/, "").split("/").pop() || newFileName;
        const titleChanged = currentName !== finalFileName;
        verboseLog(this.plugin, `Notification details: currentName=${currentName}, finalFileName=${finalFileName}, titleChanged=${titleChanged}`);
        const shouldShowNotice = this.plugin.settings.manualNotificationMode === "Always" || this.plugin.settings.manualNotificationMode === "On title change" && titleChanged;
        verboseLog(this.plugin, `shouldShowNotice=${shouldShowNotice}`);
        if (shouldShowNotice) {
          verboseLog(this.plugin, `Showing notice: Updated title: ${currentName} \u2192 ${finalFileName}`);
          new import_obsidian14.Notice(`Renamed to: ${finalFileName}`);
        }
      }
      return { success: true };
    } catch (error) {
      console.error(`Failed to rename file ${file.path} to ${newPath}:`, error);
      return { success: false, reason: "error" };
    }
  }
  checkFileExistsCaseInsensitive(path) {
    const exactMatch = this.plugin.app.vault.getAbstractFileByPath(path);
    if (exactMatch !== null) {
      verboseLog(this.plugin, `Exact file conflict found: ${path} (existing file: ${exactMatch.path})`);
      return true;
    }
    const lowerPath = path.toLowerCase();
    const allFiles = this.plugin.app.vault.getAllLoadedFiles();
    for (const file of allFiles) {
      if (file.path.toLowerCase() === lowerPath) {
        verboseLog(this.plugin, `Case-insensitive file conflict found: ${path} (existing file: ${file.path})`);
        return true;
      }
    }
    return false;
  }
  // Getter for lastProcessedContent (for use in main.ts)
  getLastProcessedContent() {
    return this.lastProcessedContent;
  }
  // Setter for lastProcessedContent (for use in main.ts)
  setLastProcessedContent(path, content) {
    this.lastProcessedContent.set(path, content);
  }
  // Clear method for lastProcessedContent (for use in main.ts)
  clearLastProcessedContent() {
    this.lastProcessedContent.clear();
  }
};

// src/ui/context-menus.ts
var import_obsidian15 = require("obsidian");
init_utils();
init_modals();
var ContextMenuManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Creates or retrieves a context menu for the given mouse event.
   * Uses Tag Wrangler's menuForEvent pattern.
   */
  menuForEvent(evt) {
    let menu = evt.obsidian_contextmenu;
    if (!menu) {
      menu = evt.obsidian_contextmenu = new import_obsidian15.Menu();
      setTimeout(() => menu.showAtPosition({ x: evt.pageX, y: evt.pageY }), 0);
    }
    return menu;
  }
  /**
   * Determines whether to show disable menu option for a folder based on scope strategy.
   */
  shouldShowDisableMenuForFolder(folderPath) {
    const isInList = this.plugin.settings.excludedFolders.includes(folderPath);
    let result;
    if (this.plugin.settings.folderScopeStrategy === "Only exclude...") {
      result = !isInList;
    } else {
      result = isInList;
    }
    verboseLog(this.plugin, `shouldShowDisableMenuForFolder(${folderPath})`, {
      folderScopeStrategy: this.plugin.settings.folderScopeStrategy,
      isInList,
      result,
      willShow: result ? "DISABLE menu" : "ENABLE menu"
    });
    return result;
  }
  /**
   * Determines whether to show disable menu option for a tag based on scope strategy.
   */
  shouldShowDisableMenuForTag(tagName) {
    const tagToFind = tagName.startsWith("#") ? tagName : `#${tagName}`;
    const isInList = this.plugin.settings.excludedTags.includes(tagToFind);
    let result;
    if (this.plugin.settings.tagScopeStrategy === "Only exclude...") {
      result = !isInList;
    } else {
      result = isInList;
    }
    verboseLog(this.plugin, `shouldShowDisableMenuForTag(${tagName})`, {
      folderScopeStrategy: this.plugin.settings.folderScopeStrategy,
      tagToFind,
      isInList,
      result,
      willShow: result ? "DISABLE menu" : "ENABLE menu"
    });
    return result;
  }
  /**
   * Gets the appropriate menu text for folder operations based on scope strategy.
   */
  getFolderMenuText(folderPath) {
    if (this.plugin.settings.folderScopeStrategy === "Only exclude...") {
      return {
        disable: "Disable renaming in folder",
        enable: "Enable renaming in folder"
      };
    } else {
      return {
        disable: "Disable renaming in folder",
        enable: "Enable renaming in folder"
      };
    }
  }
  /**
   * Gets the appropriate menu text for tag operations based on scope strategy.
   */
  getTagMenuText(tagName) {
    if (this.plugin.settings.tagScopeStrategy === "Only exclude...") {
      return {
        disable: "Disable renaming for tag",
        enable: "Enable renaming for tag"
      };
    } else {
      return {
        disable: "Disable renaming for tag",
        enable: "Enable renaming for tag"
      };
    }
  }
  /**
   * Adds tag-related menu items to a context menu.
   */
  addTagMenuItems(menu, tagName) {
    const tagToFind = tagName.startsWith("#") ? tagName : `#${tagName}`;
    const shouldShowDisable = this.shouldShowDisableMenuForTag(tagName);
    const menuText = this.getTagMenuText(tagName);
    let visibleItemCount = 0;
    if (this.plugin.settings.commandVisibility.tagPutFirstLineInTitle) visibleItemCount++;
    if (shouldShowDisable && this.plugin.settings.commandVisibility.tagExclude) visibleItemCount++;
    if (!shouldShowDisable && this.plugin.settings.commandVisibility.tagStopExcluding) visibleItemCount++;
    if (visibleItemCount > 0) {
      menu.addSeparator();
    }
    if (this.plugin.settings.commandVisibility.tagPutFirstLineInTitle) {
      menu.addItem((item) => {
        item.setTitle("Put first line in title").setIcon("file-pen").onClick(() => {
          new ProcessTagModal(this.plugin.app, this.plugin, tagName).open();
        });
      });
    }
    if (shouldShowDisable && this.plugin.settings.commandVisibility.tagExclude) {
      menu.addItem((item) => {
        item.setTitle(menuText.disable).setIcon("square-x").onClick(async () => {
          await this.plugin.toggleTagExclusion(tagName);
        });
      });
    }
    if (!shouldShowDisable && this.plugin.settings.commandVisibility.tagStopExcluding) {
      menu.addItem((item) => {
        item.setTitle(menuText.enable).setIcon("square-check").onClick(async () => {
          await this.plugin.toggleTagExclusion(tagName);
        });
      });
    }
  }
  /**
   * Adds tag-related menu items directly to a DOM element.
   * Used for custom menu implementations.
   */
  addTagMenuItemsToDOM(menuEl, tagName) {
    const tagToFind = tagName.startsWith("#") ? tagName : `#${tagName}`;
    const shouldShowDisable = this.shouldShowDisableMenuForTag(tagName);
    const menuText = this.getTagMenuText(tagName);
    if (this.plugin.settings.commandVisibility.tagPutFirstLineInTitle) {
      const menuItem = menuEl.createEl("div", { cls: "menu-item" });
      const iconEl = menuItem.createEl("div", { cls: "menu-item-icon" });
      (0, import_obsidian15.setIcon)(iconEl, "file-pen");
      menuItem.createEl("div", { cls: "menu-item-title", text: "Put first line in title" });
      menuItem.addEventListener("click", () => {
        new ProcessTagModal(this.plugin.app, this.plugin, tagName).open();
        menuEl.remove();
      });
    }
    if (shouldShowDisable && this.plugin.settings.commandVisibility.tagExclude) {
      const menuItem = menuEl.createEl("div", { cls: "menu-item" });
      const iconEl = menuItem.createEl("div", { cls: "menu-item-icon" });
      (0, import_obsidian15.setIcon)(iconEl, "square-x");
      menuItem.createEl("div", { cls: "menu-item-title", text: menuText.disable });
      menuItem.addEventListener("click", async () => {
        await this.plugin.toggleTagExclusion(tagName);
        menuEl.remove();
      });
    }
    if (!shouldShowDisable && this.plugin.settings.commandVisibility.tagStopExcluding) {
      const menuItem = menuEl.createEl("div", { cls: "menu-item" });
      const iconEl = menuItem.createEl("div", { cls: "menu-item-icon" });
      (0, import_obsidian15.setIcon)(iconEl, "square-check");
      menuItem.createEl("div", { cls: "menu-item-title", text: menuText.enable });
      menuItem.addEventListener("click", async () => {
        await this.plugin.toggleTagExclusion(tagName);
        menuEl.remove();
      });
    }
  }
  /**
   * Adds menu items for bulk operations on multiple folders.
   */
  addMultiFolderMenuItems(menu, folders) {
    let totalFiles = 0;
    folders.forEach((folder) => {
      const files = this.plugin.getAllMarkdownFilesInFolder(folder);
      totalFiles += files.length;
    });
    if (totalFiles === 0) return;
    menu.addSeparator();
    if (this.plugin.settings.commandVisibility.folderPutFirstLineInTitle) {
      menu.addItem((item) => {
        item.setTitle(`Put first line in title (${folders.length} folders)`).setIcon("folder-pen").onClick(async () => {
          await this.plugin.processMultipleFolders(folders, "rename");
        });
      });
    }
    if (this.plugin.settings.commandVisibility.folderExclude) {
      menu.addItem((item) => {
        item.setTitle(`Disable renaming (${folders.length} folders)`).setIcon("square-x").onClick(async () => {
          await this.plugin.processMultipleFolders(folders, "disable");
        });
      });
    }
    if (this.plugin.settings.commandVisibility.folderStopExcluding) {
      menu.addItem((item) => {
        item.setTitle(`Enable renaming (${folders.length} folders)`).setIcon("square-check").onClick(async () => {
          await this.plugin.processMultipleFolders(folders, "enable");
        });
      });
    }
  }
};

// src/operations/folder-operations.ts
var import_obsidian16 = require("obsidian");
init_utils();
var FolderOperations = class {
  constructor(app, settings, renameEngine, saveSettings, debugLog, processMultipleFiles) {
    this.app = app;
    this.settings = settings;
    this.renameEngine = renameEngine;
    this.saveSettings = saveSettings;
    this.debugLog = debugLog;
    this.processMultipleFiles = processMultipleFiles;
  }
  async putFirstLineInTitleForFolder(folder) {
    const files = this.app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian16.TFile && file.extension === "md").filter((file) => {
      var _a;
      return file.path.startsWith(folder.path + "/") || ((_a = file.parent) == null ? void 0 : _a.path) === folder.path;
    });
    if (files.length === 0) {
      verboseLog(this, `Showing notice: No markdown files found in this folder.`);
      new import_obsidian16.Notice(`No notes found in: ${folder.name}`);
      return;
    }
    verboseLog(this, `Showing notice: Renaming ${files.length} files in "${folder.path}"...`);
    new import_obsidian16.Notice(`Renaming ${files.length} notes...`);
    let processedCount = 0;
    let errorCount = 0;
    const exclusionOverrides = { ignoreFolder: true, ignoreTag: true, ignoreProperty: true };
    for (const file of files) {
      try {
        await this.renameEngine.processFile(file, true, false, void 0, true, exclusionOverrides);
        processedCount++;
      } catch (error) {
        console.error(`Error processing file ${file.path}:`, error);
        errorCount++;
      }
    }
    if (errorCount > 0) {
      verboseLog(this, `Showing notice: Renamed ${processedCount}/${files.length} notes with ${errorCount} errors. Check console for details.`);
      new import_obsidian16.Notice(`Renamed ${processedCount}/${files.length} notes with ${errorCount} errors. Check console for details.`, 0);
    } else {
      verboseLog(this, `Showing notice: Successfully processed ${processedCount} files.`);
      new import_obsidian16.Notice(`Renamed ${processedCount}/${files.length} notes.`, 0);
    }
  }
  async toggleFolderExclusion(folderPath) {
    const isInList = this.settings.excludedFolders.includes(folderPath);
    const isInverted = this.settings.folderScopeStrategy === "Exclude all except...";
    if (isInList) {
      this.settings.excludedFolders = this.settings.excludedFolders.filter((path) => path !== folderPath);
      if (this.settings.excludedFolders.length === 0) {
        this.settings.excludedFolders.push("");
      }
      if (isInverted) {
        verboseLog(this, `Showing notice: Renaming disabled for folder: ${folderPath}`);
        new import_obsidian16.Notice(`Disabled renaming in: ${folderPath}`);
      } else {
        verboseLog(this, `Showing notice: Renaming enabled for folder: ${folderPath}`);
        new import_obsidian16.Notice(`Enabled renaming in: ${folderPath}`);
      }
    } else {
      if (this.settings.excludedFolders.length === 1 && this.settings.excludedFolders[0] === "") {
        this.settings.excludedFolders[0] = folderPath;
      } else {
        this.settings.excludedFolders.push(folderPath);
      }
      if (isInverted) {
        verboseLog(this, `Showing notice: Renaming enabled for folder: ${folderPath}`);
        new import_obsidian16.Notice(`Enabled renaming in: ${folderPath}`);
      } else {
        verboseLog(this, `Showing notice: Renaming disabled for folder: ${folderPath}`);
        new import_obsidian16.Notice(`Disabled renaming in: ${folderPath}`);
      }
    }
    this.debugLog("excludedFolders", this.settings.excludedFolders);
    await this.saveSettings();
    verboseLog(this, `Folder exclusion toggled for: ${folderPath}`, { isNowInList: !isInList });
  }
  getSelectedFolders() {
    const selectedFolders = [];
    const selectors = [
      ".nav-folder.is-selected",
      ".nav-folder.is-active",
      ".nav-folder-title.is-selected",
      ".nav-folder-title.is-active",
      ".tree-item.is-selected .nav-folder-title",
      ".tree-item.is-active .nav-folder-title"
    ];
    selectors.forEach((selector) => {
      const elements = document.querySelectorAll(selector);
      elements.forEach((element) => {
        let folderPath = element.getAttribute("data-path");
        if (!folderPath) {
          const parent = element.closest(".nav-folder, .tree-item");
          if (parent) {
            folderPath = parent.getAttribute("data-path");
          }
        }
        if (folderPath) {
          const folder = this.app.vault.getAbstractFileByPath(folderPath);
          if (folder instanceof import_obsidian16.TFolder && !selectedFolders.includes(folder)) {
            selectedFolders.push(folder);
          }
        }
      });
    });
    return selectedFolders;
  }
  getSelectedFiles() {
    const selectedFiles = [];
    const selectors = [
      ".nav-file.is-selected",
      ".nav-file.is-active",
      ".nav-file-title.is-selected",
      ".nav-file-title.is-active",
      ".tree-item.is-selected .nav-file-title",
      ".tree-item.is-active .nav-file-title"
    ];
    selectors.forEach((selector) => {
      const elements = document.querySelectorAll(selector);
      elements.forEach((element) => {
        let filePath = element.getAttribute("data-path");
        if (!filePath) {
          const parent = element.closest(".nav-file, .tree-item");
          if (parent) {
            filePath = parent.getAttribute("data-path");
          }
        }
        if (filePath) {
          const file = this.app.vault.getAbstractFileByPath(filePath);
          if (file instanceof import_obsidian16.TFile && file.extension === "md" && !selectedFiles.includes(file)) {
            selectedFiles.push(file);
          }
        }
      });
    });
    return selectedFiles;
  }
  getAllMarkdownFilesInFolder(folder) {
    const files = [];
    const processFolder = (currentFolder) => {
      currentFolder.children.forEach((child) => {
        if (child instanceof import_obsidian16.TFile && child.extension === "md") {
          files.push(child);
        } else if (child instanceof import_obsidian16.TFolder && this.settings.includeSubfolders) {
          processFolder(child);
        }
      });
    };
    processFolder(folder);
    return files;
  }
  async processMultipleFolders(folders, action) {
    if (folders.length === 0) return;
    let processed = 0;
    let skipped = 0;
    let errors = 0;
    const allFiles = [];
    folders.forEach((folder) => {
      const folderFiles = this.getAllMarkdownFilesInFolder(folder);
      allFiles.push(...folderFiles);
    });
    if (allFiles.length === 0) {
      verboseLog(this, `Showing notice: No markdown files found in selected folders.`);
      new import_obsidian16.Notice("No notes found in selected folders.");
      return;
    }
    if (action === "rename") {
      verboseLog(this, `Showing notice: Renaming ${allFiles.length} files from ${folders.length} folders...`);
      new import_obsidian16.Notice(`Renaming ${allFiles.length} notes...`);
      await this.processMultipleFiles(allFiles, "rename");
    } else {
      verboseLog(this, `Showing notice: Renaming ${folders.length} folders...`);
      new import_obsidian16.Notice(`Renaming ${folders.length} notes...`);
      for (const folder of folders) {
        try {
          const isCurrentlyExcluded = this.settings.excludedFolders.includes(folder.path);
          if (action === "disable" && !isCurrentlyExcluded) {
            await this.toggleFolderExclusion(folder.path);
            processed++;
          } else if (action === "enable" && isCurrentlyExcluded) {
            await this.toggleFolderExclusion(folder.path);
            processed++;
          } else {
            skipped++;
          }
        } catch (error) {
          console.error(`Error processing folder ${folder.path}:`, error);
          errors++;
        }
      }
      const actionText = action === "disable" ? "Disabled" : "Enabled";
      verboseLog(this, `Showing notice: ${actionText} renaming for ${processed} folders.`);
      new import_obsidian16.Notice(`${actionText} renaming in ${processed} folders.`);
    }
  }
};

// src/operations/tag-operations.ts
var import_obsidian17 = require("obsidian");
init_utils();
var TagOperations = class {
  constructor(app, settings, renameEngine, saveSettings, debugLog) {
    this.app = app;
    this.settings = settings;
    this.renameEngine = renameEngine;
    this.saveSettings = saveSettings;
    this.debugLog = debugLog;
  }
  async putFirstLineInTitleForTag(tagName, omitBodyTags = false, omitNestedTags = false) {
    var _a;
    const tagToFind = tagName.startsWith("#") ? tagName : `#${tagName}`;
    const files = this.app.vault.getMarkdownFiles();
    const matchingFiles = [];
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      let hasTag = false;
      let tagFoundInBody = false;
      if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.tags) {
        const frontmatterTags = Array.isArray(cache.frontmatter.tags) ? cache.frontmatter.tags : [cache.frontmatter.tags];
        hasTag = frontmatterTags.some((tag) => {
          if (omitNestedTags) {
            return tag === tagName || tag === tagToFind;
          } else {
            return tag === tagName || tag === tagToFind || tag.startsWith(tagName + "/") || tag.startsWith(tagToFind + "/");
          }
        });
      }
      if (!hasTag && (cache == null ? void 0 : cache.tags)) {
        cache.tags.forEach((tagCache) => {
          const cacheTag = tagCache.tag;
          let tagMatches = false;
          if (omitNestedTags) {
            tagMatches = cacheTag === tagToFind || cacheTag === `#${tagName}`;
          } else {
            tagMatches = cacheTag === tagToFind || cacheTag === `#${tagName}` || cacheTag.startsWith(tagToFind + "/") || cacheTag.startsWith(`#${tagName}/`);
          }
          if (tagMatches) {
            hasTag = true;
            if (tagCache.position.start.line > 0) {
              if (cache.frontmatterPosition) {
                if (tagCache.position.start.line > cache.frontmatterPosition.end.line) {
                  tagFoundInBody = true;
                }
              } else {
                tagFoundInBody = true;
              }
            }
          }
        });
      }
      if (hasTag && omitBodyTags && tagFoundInBody) {
        continue;
      }
      if (hasTag) {
        matchingFiles.push(file);
      }
    }
    if (matchingFiles.length === 0) {
      verboseLog(this, `Showing notice: No files found with tag ${tagToFind}.`);
      new import_obsidian17.Notice(`No notes found with #${tagToFind}.`);
      return;
    }
    verboseLog(this, `Showing notice: Renaming ${matchingFiles.length} files with tag ${tagToFind}...`);
    new import_obsidian17.Notice(`Renaming ${matchingFiles.length} notes...`);
    let processedCount = 0;
    let errorCount = 0;
    const exclusionOverrides = { ignoreFolder: true, ignoreTag: true, ignoreProperty: true };
    for (const file of matchingFiles) {
      try {
        await this.renameEngine.processFile(file, true, false, void 0, true, exclusionOverrides);
        processedCount++;
      } catch (error) {
        console.error(`Error processing file ${file.path}:`, error);
        errorCount++;
      }
    }
    if (errorCount > 0) {
      verboseLog(this, `Showing notice: Renamed ${processedCount}/${matchingFiles.length} notes with ${errorCount} errors. Check console for details.`);
      new import_obsidian17.Notice(`Renamed ${processedCount}/${matchingFiles.length} notes with ${errorCount} errors. Check console for details.`, 0);
    } else {
      verboseLog(this, `Showing notice: Successfully processed ${processedCount} files with tag ${tagToFind}.`);
      new import_obsidian17.Notice(`Renamed ${processedCount}/${matchingFiles.length} notes.`, 0);
    }
  }
  async toggleTagExclusion(tagName) {
    const tagToFind = tagName.startsWith("#") ? tagName : `#${tagName}`;
    const isInList = this.settings.excludedTags.includes(tagToFind);
    const isInverted = this.settings.tagScopeStrategy === "Exclude all except...";
    if (isInList) {
      this.settings.excludedTags = this.settings.excludedTags.filter((tag) => tag !== tagToFind);
      if (this.settings.excludedTags.length === 0) {
        this.settings.excludedTags.push("");
      }
      if (isInverted) {
        verboseLog(this, `Showing notice: Renaming disabled for ${tagToFind}`);
        new import_obsidian17.Notice(`Disabled renaming for ${tagToFind}.`);
      } else {
        verboseLog(this, `Showing notice: Renaming enabled for ${tagToFind}`);
        new import_obsidian17.Notice(`Enabled renaming for ${tagToFind}.`);
      }
    } else {
      if (this.settings.excludedTags.length === 1 && this.settings.excludedTags[0] === "") {
        this.settings.excludedTags[0] = tagToFind;
      } else {
        this.settings.excludedTags.push(tagToFind);
      }
      if (isInverted) {
        verboseLog(this, `Showing notice: Renaming enabled for ${tagToFind}`);
        new import_obsidian17.Notice(`Enabled renaming for ${tagToFind}.`);
      } else {
        verboseLog(this, `Showing notice: Renaming disabled for ${tagToFind}`);
        new import_obsidian17.Notice(`Disabled renaming for ${tagToFind}.`);
      }
    }
    this.debugLog("excludedTags", this.settings.excludedTags);
    await this.saveSettings();
    verboseLog(this, `Tag exclusion toggled for: ${tagToFind}`, { isNowInList: !isInList });
  }
};

// src/core/alias-manager.ts
var import_obsidian18 = require("obsidian");
init_utils();
var AliasManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.aliasUpdateInProgress = /* @__PURE__ */ new Set();
  }
  get app() {
    return this.plugin.app;
  }
  get settings() {
    return this.plugin.settings;
  }
  isAliasUpdateInProgress(filePath) {
    return this.aliasUpdateInProgress.has(filePath);
  }
  getAliasPropertyKeys() {
    const aliasPropertyKey = this.settings.aliasPropertyKey || "aliases";
    return aliasPropertyKey.split(",").map((key) => key.trim()).filter((key) => key.length > 0);
  }
  async updateAliasIfNeeded(file, providedContent, targetFileName) {
    this.plugin.trackUsage();
    try {
      const currentFile = this.app.vault.getAbstractFileByPath(file.path);
      if (!currentFile || !(currentFile instanceof import_obsidian18.TFile)) {
        verboseLog(this.plugin, `Skipping alias update - file no longer exists: ${file.path}`);
        return;
      }
      file = currentFile;
      const fileKey = file.path;
      if (this.aliasUpdateInProgress.has(fileKey)) {
        verboseLog(this.plugin, `Skipping alias update for ${file.path} - update already in progress`);
        return;
      }
      if (await hasDisablePropertyInFile(file, this.app, this.settings.disableRenamingKey, this.settings.disableRenamingValue)) {
        verboseLog(this.plugin, `Skipping alias update - file has disable property: ${file.path}`);
        return;
      }
      if (!shouldProcessFile(file, this.settings, this.app)) {
        return;
      }
      let content;
      if (providedContent !== void 0) {
        content = providedContent;
        verboseLog(this.plugin, `Using provided content for alias update in ${file.path} (${content.length} chars)`);
      } else if (this.settings.fileReadMethod === "File") {
        content = await this.app.vault.read(file);
      } else {
        content = await this.app.vault.cachedRead(file);
      }
      if (!content || content.trim() === "") {
        return;
      }
      const contentWithoutFrontmatter = this.plugin.renameEngine.stripFrontmatterFromContent(content, file);
      const lines = contentWithoutFrontmatter.split("\n");
      const firstLine = lines.length > 0 ? lines[0] : "";
      if (!firstLine || firstLine.trim() === "") {
        if (this.settings.enableAliases) {
          await this.removePluginAliasesFromFile(file);
        }
        return;
      }
      if (!this.settings.enableAliases) {
        return;
      }
      const metadata = this.app.metadataCache.getFileCache(file);
      const frontmatter = metadata == null ? void 0 : metadata.frontmatter;
      const processedFirstLine = extractTitle(firstLine, this.settings);
      const fileNameToCompare = targetFileName !== void 0 ? targetFileName.trim() : file.basename.trim();
      const processedLineMatchesFilename = processedFirstLine.trim() === fileNameToCompare;
      const shouldHaveAlias = !this.settings.addAliasOnlyIfFirstLineDiffers || !processedLineMatchesFilename;
      if (!shouldHaveAlias) {
        await this.removePluginAliasesFromFile(file);
        return;
      }
      const aliasPropertyKeys = this.getAliasPropertyKeys();
      const zwspMarker = "\u200B";
      const expectedAlias = this.settings.stripMarkupInAlias ? extractTitle(firstLine, this.settings) : firstLine;
      const expectedAliasWithMarker = expectedAlias + zwspMarker;
      let allPropertiesHaveCorrectAlias = true;
      for (const aliasPropertyKey of aliasPropertyKeys) {
        let existingAliases = [];
        if (frontmatter && frontmatter[aliasPropertyKey]) {
          if (Array.isArray(frontmatter[aliasPropertyKey])) {
            existingAliases = frontmatter[aliasPropertyKey];
          } else {
            existingAliases = [frontmatter[aliasPropertyKey]];
          }
        }
        const hasCorrectAlias = existingAliases.some(
          (alias) => alias === expectedAliasWithMarker || alias === expectedAlias
        );
        if (!hasCorrectAlias) {
          allPropertiesHaveCorrectAlias = false;
          break;
        }
      }
      if (allPropertiesHaveCorrectAlias) {
        verboseLog(this.plugin, `File ${file.path} already has correct alias in all properties`);
        return;
      }
      this.aliasUpdateInProgress.add(fileKey);
      try {
        verboseLog(this.plugin, `Adding alias to ${file.path} - no correct alias found`);
        await this.addAliasToFile(file, firstLine, fileNameToCompare, content);
      } finally {
        this.aliasUpdateInProgress.delete(fileKey);
      }
    } catch (error) {
      console.error("Error updating alias:", error);
      this.aliasUpdateInProgress.delete(file.path);
    }
  }
  async addAliasToFile(file, originalFirstLine, newFileName, content) {
    try {
      const currentFile = this.app.vault.getAbstractFileByPath(file.path);
      if (!currentFile || !(currentFile instanceof import_obsidian18.TFile)) {
        verboseLog(this.plugin, `Skipping alias addition - file no longer exists: ${file.path}`);
        return;
      }
      file = currentFile;
      const firstLine = originalFirstLine;
      let aliasProcessedLine = firstLine;
      if (this.settings.enableCustomReplacements && this.settings.applyCustomRulesInAlias) {
        for (const replacement of this.settings.customReplacements) {
          if (replacement.searchText === "" || !replacement.enabled) continue;
          let tempLine = aliasProcessedLine;
          if (replacement.onlyWholeLine) {
            if (aliasProcessedLine.trim() === replacement.searchText.trim()) {
              tempLine = replacement.replaceText;
            }
          } else if (replacement.onlyAtStart) {
            if (tempLine.startsWith(replacement.searchText)) {
              tempLine = replacement.replaceText + tempLine.slice(replacement.searchText.length);
            }
          } else {
            tempLine = tempLine.replaceAll(replacement.searchText, replacement.replaceText);
          }
          aliasProcessedLine = tempLine;
        }
      }
      const originalCharReplacementSetting = this.settings.enableForbiddenCharReplacements;
      const originalStripMarkupSetting = this.settings.enableStripMarkup;
      this.settings.enableForbiddenCharReplacements = false;
      if (!this.settings.stripMarkupInAlias) {
        this.settings.enableStripMarkup = false;
      }
      let aliasToAdd = extractTitle(aliasProcessedLine, this.settings);
      this.settings.enableForbiddenCharReplacements = originalCharReplacementSetting;
      this.settings.enableStripMarkup = originalStripMarkupSetting;
      const targetFileNameWithoutExt = newFileName.trim();
      const aliasMatchesFilename = aliasToAdd.trim() === targetFileNameWithoutExt;
      const shouldAddAlias = !this.settings.addAliasOnlyIfFirstLineDiffers || !aliasMatchesFilename;
      if (!shouldAddAlias) {
        verboseLog(this.plugin, `Removing plugin aliases and skipping add - alias matches filename: \`${aliasToAdd}\` = \`${targetFileNameWithoutExt}\``);
        await this.removePluginAliasesFromFile(file);
        return;
      }
      if (this.settings.truncateAlias) {
        if (aliasToAdd.length > this.settings.charCount - 1) {
          aliasToAdd = aliasToAdd.slice(0, this.settings.charCount - 1).trimEnd() + "\u2026";
        }
      }
      if (!aliasToAdd || aliasToAdd.trim() === "") {
        verboseLog(this.plugin, `Removing plugin alias - no non-empty content found`);
        await this.removePluginAliasesFromFile(file);
        return;
      }
      const untitledPattern = /^Untitled(\s+[1-9]\d*)?$/;
      if (untitledPattern.test(aliasToAdd.trim())) {
        const originalFirstLineTrimmed = firstLine.trim();
        if (!untitledPattern.test(originalFirstLineTrimmed)) {
          verboseLog(this.plugin, `Removing plugin alias - extracted title is "${aliasToAdd}" but first line is not literally Untitled`);
          await this.removePluginAliasesFromFile(file);
          return;
        }
      }
      const markedAlias = "\u200B" + aliasToAdd + "\u200B";
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian18.MarkdownView);
      if (activeView && activeView.file === file) {
        await activeView.save();
      }
      const lines = content.split("\n");
      const hasFrontmatter = lines.length > 0 && lines[0].trim() === "---";
      if (!hasFrontmatter) {
        const currentFileForFrontmatter = this.app.vault.getAbstractFileByPath(file.path);
        if (!currentFileForFrontmatter || !(currentFileForFrontmatter instanceof import_obsidian18.TFile)) {
          verboseLog(this.plugin, `Skipping frontmatter creation - file no longer exists: ${file.path}`);
          return;
        }
        const aliasPropertyKeys2 = this.getAliasPropertyKeys();
        this.plugin.markFlitModificationStart(currentFileForFrontmatter.path);
        await this.app.fileManager.processFrontMatter(currentFileForFrontmatter, (frontmatter) => {
          for (const aliasPropertyKey of aliasPropertyKeys2) {
            if (aliasPropertyKey === "aliases") {
              frontmatter[aliasPropertyKey] = [markedAlias];
            } else {
              frontmatter[aliasPropertyKey] = markedAlias;
            }
          }
        });
        this.plugin.markFlitModificationEnd(currentFileForFrontmatter.path);
        this.plugin.pendingMetadataUpdates.add(currentFileForFrontmatter.path);
        verboseLog(this.plugin, `Created frontmatter and added alias \`${aliasToAdd}\` to ${currentFileForFrontmatter.path}`);
        return;
      }
      const currentFileForUpdate = this.app.vault.getAbstractFileByPath(file.path);
      if (!currentFileForUpdate || !(currentFileForUpdate instanceof import_obsidian18.TFile)) {
        verboseLog(this.plugin, `Skipping frontmatter update - file no longer exists: ${file.path}`);
        return;
      }
      const aliasPropertyKeys = this.getAliasPropertyKeys();
      this.plugin.markFlitModificationStart(currentFileForUpdate.path);
      await this.app.fileManager.processFrontMatter(currentFileForUpdate, (frontmatter) => {
        for (const aliasPropertyKey of aliasPropertyKeys) {
          if (aliasPropertyKey === "aliases") {
            let existingAliases = [];
            if (frontmatter[aliasPropertyKey]) {
              if (Array.isArray(frontmatter[aliasPropertyKey])) {
                existingAliases = [...frontmatter[aliasPropertyKey]];
              } else {
                existingAliases = [frontmatter[aliasPropertyKey]];
              }
            }
            existingAliases = existingAliases.filter(
              (alias) => !(typeof alias === "string" && alias.startsWith("\u200B") && alias.endsWith("\u200B")) && alias !== ""
            );
            if (!existingAliases.includes(aliasToAdd)) {
              existingAliases.push(markedAlias);
              frontmatter[aliasPropertyKey] = existingAliases;
            } else {
              if (existingAliases.length === 0) {
                if (this.settings.keepEmptyAliasProperty) {
                  frontmatter[aliasPropertyKey] = null;
                } else {
                  delete frontmatter[aliasPropertyKey];
                }
              } else {
                frontmatter[aliasPropertyKey] = existingAliases;
              }
            }
          } else {
            const propertyExists = frontmatter.hasOwnProperty(aliasPropertyKey);
            if (!propertyExists || frontmatter[aliasPropertyKey] === null || frontmatter[aliasPropertyKey] === void 0 || frontmatter[aliasPropertyKey] === "") {
              frontmatter[aliasPropertyKey] = markedAlias;
            } else {
              let existingValues = [];
              if (Array.isArray(frontmatter[aliasPropertyKey])) {
                existingValues = [...frontmatter[aliasPropertyKey]];
              } else {
                existingValues = [frontmatter[aliasPropertyKey]];
              }
              const userValues = existingValues.filter(
                (value) => !(typeof value === "string" && value.startsWith("\u200B") && value.endsWith("\u200B")) && value !== ""
              );
              if (!userValues.includes(aliasToAdd)) {
                if (userValues.length === 0) {
                  frontmatter[aliasPropertyKey] = markedAlias;
                } else {
                  userValues.push(markedAlias);
                  frontmatter[aliasPropertyKey] = userValues;
                }
              } else {
                if (userValues.length === 0) {
                  if (this.settings.keepEmptyAliasProperty) {
                    frontmatter[aliasPropertyKey] = null;
                  } else {
                    delete frontmatter[aliasPropertyKey];
                  }
                } else if (userValues.length === 1) {
                  frontmatter[aliasPropertyKey] = userValues[0];
                } else {
                  frontmatter[aliasPropertyKey] = userValues;
                }
              }
            }
          }
        }
      });
      this.plugin.markFlitModificationEnd(currentFileForUpdate.path);
      this.plugin.pendingMetadataUpdates.add(currentFileForUpdate.path);
      verboseLog(this.plugin, `Updated alias \`${aliasToAdd}\` in ${currentFileForUpdate.path}`);
    } catch (error) {
      if (error.code === "ENOENT") {
        verboseLog(this.plugin, `Skipping alias addition - file was renamed during operation: ${file.path}`);
      } else {
        console.error(`Failed to add alias to file ${file.path}:`, error);
      }
    }
  }
  async removePluginAliasesFromFile(file, forceCompleteRemoval = false) {
    try {
      const currentFile = this.app.vault.getAbstractFileByPath(file.path);
      if (!currentFile || !(currentFile instanceof import_obsidian18.TFile)) {
        verboseLog(this.plugin, `Skipping alias removal - file no longer exists: ${file.path}`);
        return;
      }
      file = currentFile;
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian18.MarkdownView);
      if (activeView && activeView.file === file) {
        await activeView.save();
      }
      const currentFileForRemoval = this.app.vault.getAbstractFileByPath(file.path);
      if (!currentFileForRemoval || !(currentFileForRemoval instanceof import_obsidian18.TFile)) {
        verboseLog(this.plugin, `Skipping alias removal - file no longer exists: ${file.path}`);
        return;
      }
      this.plugin.markFlitModificationStart(currentFileForRemoval.path);
      await this.app.fileManager.processFrontMatter(currentFileForRemoval, (frontmatter) => {
        const aliasPropertyKeys = this.getAliasPropertyKeys();
        for (const aliasPropertyKey of aliasPropertyKeys) {
          if (frontmatter[aliasPropertyKey]) {
            let existingValues = [];
            if (Array.isArray(frontmatter[aliasPropertyKey])) {
              existingValues = [...frontmatter[aliasPropertyKey]];
            } else {
              existingValues = [frontmatter[aliasPropertyKey]];
            }
            const filteredValues = existingValues.filter(
              (value) => !(typeof value === "string" && value.startsWith("\u200B") && value.endsWith("\u200B")) && value !== ""
            );
            if (filteredValues.length === 0) {
              if (forceCompleteRemoval || !this.settings.keepEmptyAliasProperty) {
                delete frontmatter[aliasPropertyKey];
              } else {
                frontmatter[aliasPropertyKey] = null;
              }
            } else if (filteredValues.length === 1 && aliasPropertyKey !== "aliases") {
              frontmatter[aliasPropertyKey] = filteredValues[0];
            } else {
              frontmatter[aliasPropertyKey] = filteredValues;
            }
          }
        }
      });
      this.plugin.markFlitModificationEnd(currentFileForRemoval.path);
      this.plugin.pendingMetadataUpdates.add(currentFileForRemoval.path);
      verboseLog(this.plugin, `Removed plugin aliases from ${currentFileForRemoval.path}`);
    } catch (error) {
      if (error.code === "ENOENT") {
        verboseLog(this.plugin, `Skipping alias removal - file was renamed during operation: ${file.path}`);
      } else {
        console.error(`Failed to remove plugin aliases from ${file.path}:`, error);
      }
    }
  }
  async removeAliasFromFile(file, aliasToRemove) {
    try {
      const trimmedAlias = aliasToRemove.trim();
      if (!trimmedAlias) {
        return;
      }
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian18.MarkdownView);
      if (activeView && activeView.file === file) {
        await activeView.save();
      }
      this.plugin.markFlitModificationStart(file.path);
      await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
        const aliasPropertyKeys = this.getAliasPropertyKeys();
        for (const aliasPropertyKey of aliasPropertyKeys) {
          if (frontmatter[aliasPropertyKey]) {
            let existingAliases = [];
            if (Array.isArray(frontmatter[aliasPropertyKey])) {
              existingAliases = [...frontmatter[aliasPropertyKey]];
            } else {
              existingAliases = [frontmatter[aliasPropertyKey]];
            }
            const filteredAliases = existingAliases.filter((alias) => alias !== trimmedAlias && alias !== "");
            if (filteredAliases.length === 0) {
              if (this.settings.keepEmptyAliasProperty) {
                frontmatter[aliasPropertyKey] = null;
              } else {
                delete frontmatter[aliasPropertyKey];
              }
            } else {
              frontmatter[aliasPropertyKey] = filteredAliases;
            }
          }
        }
      });
      this.plugin.markFlitModificationEnd(file.path);
      verboseLog(this.plugin, `Removed alias "${trimmedAlias}" from ${file.path}`);
    } catch (error) {
      console.error(`Failed to remove alias from ${file.path}:`, error);
    }
  }
};

// src/operations/file-operations.ts
var import_obsidian19 = require("obsidian");
init_utils();
init_constants();
var FileOperations = class {
  constructor(plugin) {
    this.plugin = plugin;
    // Track files waiting for YAML with their resolve callbacks and timeout timers
    this.yamlWaiters = /* @__PURE__ */ new Map();
  }
  get app() {
    return this.plugin.app;
  }
  get settings() {
    return this.plugin.settings;
  }
  /**
   * Cleans up stale entries from caches (deprecated - now handled by cache manager)
   */
  cleanupStaleCache() {
    verboseLog(this.plugin, "Cache cleanup delegated to CacheManager");
  }
  /**
   * Inserts the filename as the first line of a newly created file
   * @param initialContent - Optional initial content captured at file creation time
   * @param templateContent - Optional template content captured after template wait (skips internal wait)
   * @returns true if title was inserted, false if skipped
   */
  async insertTitleOnCreation(file, initialContent, templateContent) {
    var _a, _b, _c;
    try {
      const untitledPattern = /^Untitled(\s[1-9]\d*)?$/;
      if (untitledPattern.test(file.basename)) {
        verboseLog(this.plugin, `Skipping title insertion for untitled file: ${file.path}`);
        return false;
      }
      let cleanTitle = file.basename;
      const replacementCharToKey = {
        "\u2215": "slash",
        "\u0589": "colon",
        "\u2217": "asterisk",
        "\uFE56": "question",
        "\u2039": "lessThan",
        "\u203A": "greaterThan",
        "\uFF02": "quote",
        "\u2758": "pipe",
        "\uFF03": "hash",
        "\uFF3B": "leftBracket",
        "\uFF3D": "rightBracket",
        "\u02C6": "caret",
        "\u29F5": "backslash",
        "\u2024": "dot"
      };
      const punctuation = `,.?;:!"'""''\xBB\xAB\xA1\xBF\u203D`;
      for (const [replacementChar, originalChar] of Object.entries(TITLE_CHAR_REVERSAL_MAP)) {
        if (!cleanTitle.includes(replacementChar)) continue;
        const settingKey = replacementCharToKey[replacementChar];
        if (!settingKey) continue;
        const replacementEnabled = this.settings.charReplacementEnabled[settingKey];
        const trimLeft = this.settings.charReplacementTrimLeft[settingKey];
        const trimRight = this.settings.charReplacementTrimRight[settingKey];
        if (!replacementEnabled) {
          cleanTitle = cleanTitle.replaceAll(replacementChar, originalChar);
          continue;
        }
        let result = "";
        let remaining = cleanTitle;
        while (remaining.includes(replacementChar)) {
          const index = remaining.indexOf(replacementChar);
          result += remaining.substring(0, index);
          let replacement = originalChar;
          if (trimLeft) {
            replacement = " " + replacement;
          }
          if (trimRight) {
            const charToRight = remaining.length > index + 1 ? remaining[index + 1] : "";
            if (!punctuation.includes(charToRight)) {
              replacement = replacement + " ";
            }
          }
          result += replacement;
          remaining = remaining.substring(index + 1);
        }
        result += remaining;
        cleanTitle = result;
      }
      if (this.settings.addHeadingToTitle) {
        cleanTitle = "# " + cleanTitle;
      }
      verboseLog(this.plugin, `Inserting title "${cleanTitle}" in new file: ${file.path}`);
      let currentContent;
      if (templateContent !== void 0) {
        currentContent = templateContent;
        verboseLog(this.plugin, `[TITLE-INSERT] Using provided template content. Length: ${currentContent.length} chars`);
      } else if (this.settings.waitForTemplate) {
        verboseLog(this.plugin, `[TITLE-INSERT] Template wait enabled, checking delays`);
        const templateWaitTime = this.settings.fileReadMethod === "Cache" || this.settings.fileReadMethod === "File" ? 2500 : 600;
        const remainingWait = templateWaitTime - this.settings.newNoteDelay;
        verboseLog(this.plugin, `[TITLE-INSERT] Template wait calculation: templateWaitTime=${templateWaitTime}ms, newNoteDelay=${this.settings.newNoteDelay}ms, remainingWait=${remainingWait}ms`);
        if (remainingWait > 0) {
          if (this.settings.fileReadMethod === "Cache" || this.settings.fileReadMethod === "File") {
            verboseLog(this.plugin, `[TITLE-INSERT] Waiting full ${remainingWait}ms for template (${this.settings.fileReadMethod} read method, total: ${templateWaitTime}ms)`);
            await new Promise((resolve) => setTimeout(resolve, remainingWait));
          } else {
            verboseLog(this.plugin, `[TITLE-INSERT] Starting YAML wait for ${remainingWait}ms (Editor mode)`);
            await this.waitForYamlOrTimeout(file, remainingWait);
            verboseLog(this.plugin, `[TITLE-INSERT] YAML wait completed`);
          }
        } else {
          verboseLog(this.plugin, `Skipping template wait - newNoteDelay (${this.settings.newNoteDelay}ms) already >= ${templateWaitTime}ms`);
        }
        verboseLog(this.plugin, `[TITLE-INSERT] Re-reading content after template wait`);
        const leaves2 = this.app.workspace.getLeavesOfType("markdown");
        let foundEditor = false;
        for (const leaf of leaves2) {
          const view = leaf.view;
          if (view && ((_a = view.file) == null ? void 0 : _a.path) === file.path && view.editor) {
            currentContent = view.editor.getValue();
            verboseLog(this.plugin, `[TITLE-INSERT] Read fresh content from editor after template wait. Length: ${currentContent.length} chars`);
            foundEditor = true;
            break;
          }
        }
        if (!foundEditor) {
          currentContent = await this.app.vault.read(file);
          verboseLog(this.plugin, `[TITLE-INSERT] Read fresh content from vault after template wait. Length: ${currentContent.length} chars`);
        }
      } else if (initialContent !== void 0) {
        currentContent = initialContent;
        verboseLog(this.plugin, `[TITLE-INSERT] No template wait, using initial content. Length: ${currentContent.length} chars`);
      } else {
        verboseLog(this.plugin, `[TITLE-INSERT] No template wait, reading immediately from editor`);
        const leaves2 = this.app.workspace.getLeavesOfType("markdown");
        let foundEditor = false;
        for (const leaf of leaves2) {
          const view = leaf.view;
          if (view && ((_b = view.file) == null ? void 0 : _b.path) === file.path && view.editor) {
            currentContent = view.editor.getValue();
            verboseLog(this.plugin, `[TITLE-INSERT] Read content immediately from editor. Length: ${currentContent.length} chars`);
            foundEditor = true;
            break;
          }
        }
        if (!foundEditor) {
          try {
            currentContent = await this.app.vault.read(file);
            verboseLog(this.plugin, `[TITLE-INSERT] Read content immediately from vault. Length: ${currentContent.length} chars`);
          } catch (error) {
            console.error(`Failed to read file ${file.path} for title insertion:`, error);
            return false;
          }
        }
      }
      const lines = currentContent.split("\n");
      let yamlEndLine = -1;
      if (lines[0] === "---") {
        for (let i = 1; i < lines.length; i++) {
          if (lines[i] === "---") {
            yamlEndLine = i;
            break;
          }
        }
      }
      const contentAfterYaml = yamlEndLine !== -1 ? lines.slice(yamlEndLine + 1).join("\n").trim() : currentContent.trim();
      if (contentAfterYaml !== "") {
        verboseLog(this.plugin, `File has content (excluding YAML), skipping title insertion for ${file.path}`);
        return false;
      }
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      let insertedViaEditor = false;
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view && ((_c = view.file) == null ? void 0 : _c.path) === file.path && view.editor) {
          if (yamlEndLine !== -1) {
            const insertLine = yamlEndLine + 1;
            view.editor.replaceRange(cleanTitle + "\n", { line: insertLine, ch: 0 });
            verboseLog(this.plugin, `[TITLE-INSERT] Inserted title after frontmatter at line ${insertLine} via editor`);
          } else {
            view.editor.replaceRange(cleanTitle + "\n", { line: 0, ch: 0 });
            verboseLog(this.plugin, `[TITLE-INSERT] Inserted title at beginning via editor`);
          }
          insertedViaEditor = true;
          break;
        }
      }
      if (!insertedViaEditor) {
        if (yamlEndLine !== -1) {
          const lines2 = currentContent.split("\n");
          const insertLine = yamlEndLine + 1;
          lines2.splice(insertLine, 0, cleanTitle);
          const newContent = lines2.join("\n");
          verboseLog(this.plugin, `[TITLE-INSERT] Inserting title after frontmatter at line ${insertLine} via vault`);
          await this.app.vault.modify(file, newContent);
        } else {
          verboseLog(this.plugin, `[TITLE-INSERT] Inserting title at beginning via vault`);
          await this.app.vault.modify(file, cleanTitle + "\n");
        }
      }
      verboseLog(this.plugin, `Successfully inserted title in ${file.path}`);
      return true;
    } catch (error) {
      console.error(`Error inserting title on creation for ${file.path}:`, error);
      return false;
    }
  }
  /**
   * Wait for YAML to appear or timeout
   * Public method for use by workspace-integration
   */
  async waitForYamlOrTimeout(file, timeoutMs) {
    return new Promise((resolve) => {
      const startTime = Date.now();
      const timeoutTimer = setTimeout(() => {
        const waiter = this.yamlWaiters.get(file.path);
        if (waiter) {
          this.yamlWaiters.delete(file.path);
          verboseLog(this.plugin, `Template wait timeout (${timeoutMs}ms) reached for ${file.path}`);
          resolve();
        }
      }, timeoutMs);
      this.yamlWaiters.set(file.path, { resolve, startTime, timeoutTimer });
    });
  }
  /**
   * Check if file has YAML and resolve waiting promise if found
   * Called from editor-change event
   */
  checkYamlAndResolve(file, content) {
    const waiter = this.yamlWaiters.get(file.path);
    if (!waiter) return;
    if (content.startsWith("---")) {
      const lines = content.split("\n");
      for (let i = 1; i < lines.length; i++) {
        if (lines[i] === "---") {
          const elapsed = Date.now() - waiter.startTime;
          verboseLog(this.plugin, `YAML detected after ${elapsed}ms for ${file.path}`);
          clearTimeout(waiter.timeoutTimer);
          this.yamlWaiters.delete(file.path);
          waiter.resolve();
          return;
        }
      }
    }
  }
  /**
   * Handles cursor positioning after title insertion
   * @param file - The file to position cursor in
   * @param usePlaceCursorAtLineEndSetting - Whether to respect placeCursorAtLineEnd setting (true when title insertion is OFF)
   */
  async handleCursorPositioning(file, usePlaceCursorAtLineEndSetting = true) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    try {
      verboseLog(this.plugin, `handleCursorPositioning called for ${file.path}, usePlaceCursorAtLineEndSetting: ${usePlaceCursorAtLineEndSetting}`);
      let targetView = null;
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view && ((_a = view.file) == null ? void 0 : _a.path) === file.path) {
          targetView = view;
          break;
        }
      }
      verboseLog(this.plugin, `Target view found: ${!!targetView}, file matches: ${((_b = targetView == null ? void 0 : targetView.file) == null ? void 0 : _b.path) === file.path}`);
      if (targetView && ((_c = targetView.file) == null ? void 0 : _c.path) === file.path) {
        await targetView.leaf.setViewState({
          type: "markdown",
          state: {
            mode: "source",
            source: false
          }
        });
        await ((_d = targetView.editor) == null ? void 0 : _d.focus());
        let titleLineNumber = 0;
        let titleLineLength = 0;
        const content = ((_e = targetView.editor) == null ? void 0 : _e.getValue()) || "";
        const lines = content.split("\n");
        let yamlEndLine = -1;
        if (lines[0] === "---") {
          for (let i = 1; i < lines.length; i++) {
            if (lines[i] === "---") {
              yamlEndLine = i;
              break;
            }
          }
        }
        if (yamlEndLine !== -1) {
          titleLineNumber = yamlEndLine + 1;
          verboseLog(this.plugin, `Found frontmatter ending at line ${yamlEndLine}, title on line ${titleLineNumber}`);
        } else {
          titleLineNumber = 0;
          verboseLog(this.plugin, `No frontmatter found, title on line ${titleLineNumber}`);
        }
        titleLineLength = ((_g = (_f = targetView.editor) == null ? void 0 : _f.getLine(titleLineNumber)) == null ? void 0 : _g.length) || 0;
        const shouldPlaceAtEnd = usePlaceCursorAtLineEndSetting && this.settings.moveCursorToFirstLine && this.settings.placeCursorAtLineEnd;
        if (shouldPlaceAtEnd) {
          (_h = targetView.editor) == null ? void 0 : _h.setCursor({ line: titleLineNumber, ch: titleLineLength });
          verboseLog(this.plugin, `Moved cursor to end of title line ${titleLineNumber} (${titleLineLength} chars) via handleCursorPositioning for ${file.path}`);
        } else {
          (_i = targetView.editor) == null ? void 0 : _i.setCursor({ line: titleLineNumber, ch: 0 });
          verboseLog(this.plugin, `Moved cursor to start of title line ${titleLineNumber} via handleCursorPositioning for ${file.path}`);
        }
      } else {
        verboseLog(this.plugin, `Skipping cursor positioning - no matching active view for ${file.path}`);
      }
    } catch (error) {
      console.error(`Error positioning cursor for ${file.path}:`, error);
    }
  }
  /**
   * Checks if a file is currently open in an editor
   */
  isFileOpenInEditor(file) {
    let isOpen = false;
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a;
      if (leaf.view instanceof import_obsidian19.MarkdownView && ((_a = leaf.view.file) == null ? void 0 : _a.path) === file.path) {
        isOpen = true;
      }
    });
    return isOpen;
  }
  /**
   * Check if file is excluded from processing (folder/tag/property exclusions + disable property)
   * Uses real-time content checking for tags if content provided
   */
  async isFileExcludedForCursorPositioning(file, content) {
    if (!shouldProcessFile(file, this.settings, this.app, content)) {
      return true;
    }
    if (content) {
      const hasDisableProperty = this.checkDisablePropertyInContent(content);
      if (hasDisableProperty) {
        return true;
      }
    } else {
      if (await hasDisablePropertyInFile(file, this.app, this.settings.disableRenamingKey, this.settings.disableRenamingValue)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Check for disable property and excluded properties by parsing YAML directly from content
   */
  checkDisablePropertyInContent(content) {
    const lines = content.split("\n");
    if (lines[0] !== "---") return false;
    let yamlEndLine = -1;
    for (let i = 1; i < lines.length; i++) {
      if (lines[i] === "---") {
        yamlEndLine = i;
        break;
      }
    }
    if (yamlEndLine === -1) return false;
    const yamlLines = lines.slice(1, yamlEndLine);
    const disableKey = this.settings.disableRenamingKey;
    const disableValue = this.settings.disableRenamingValue.toLowerCase();
    const nonEmptyExcludedProps = this.settings.excludedProperties.filter(
      (prop) => prop.key.trim() !== ""
    );
    let currentKey = "";
    let inArray = false;
    for (const line of yamlLines) {
      const trimmed = line.trim();
      if (trimmed === "" || trimmed.startsWith("#")) continue;
      if (trimmed.startsWith("- ")) {
        if (inArray && currentKey) {
          let arrayValue = trimmed.substring(2).trim();
          if (arrayValue.startsWith('"') && arrayValue.endsWith('"') || arrayValue.startsWith("'") && arrayValue.endsWith("'")) {
            arrayValue = arrayValue.substring(1, arrayValue.length - 1);
          }
          const normalizedArrayValue = arrayValue.startsWith("#") ? arrayValue.substring(1) : arrayValue;
          if (currentKey === disableKey && arrayValue.toLowerCase() === disableValue) {
            verboseLog(this.plugin, `Found disable property in array: ${currentKey}: [${arrayValue}]`);
            return true;
          }
          for (const excludedProp of nonEmptyExcludedProps) {
            const propKey = excludedProp.key.trim();
            const propValue = excludedProp.value.trim();
            if (currentKey === propKey) {
              if (propKey === "tags") {
                const normalizedPropValue = propValue.startsWith("#") ? propValue.substring(1) : propValue;
                if (propValue === "" || normalizedArrayValue === normalizedPropValue) {
                  verboseLog(this.plugin, `Found excluded tag in array: ${propKey}: [${arrayValue}]`);
                  return true;
                }
              } else {
                if (propValue === "" || arrayValue === propValue) {
                  verboseLog(this.plugin, `Found excluded property in array: ${propKey}: [${arrayValue}]`);
                  return true;
                }
              }
            }
          }
        }
        continue;
      }
      if (trimmed.includes(":")) {
        const colonIndex = trimmed.indexOf(":");
        const key = trimmed.substring(0, colonIndex).trim();
        const value = trimmed.substring(colonIndex + 1).trim();
        currentKey = key;
        if (value === "" || value === "[") {
          inArray = true;
          continue;
        } else {
          inArray = false;
        }
        if (key === disableKey && value.toLowerCase() === disableValue) {
          verboseLog(this.plugin, `Found disable property: ${key}: ${value}`);
          return true;
        }
        for (const excludedProp of nonEmptyExcludedProps) {
          const propKey = excludedProp.key.trim();
          const propValue = excludedProp.value.trim();
          if (key === propKey) {
            if (propValue === "" || value === propValue) {
              verboseLog(this.plugin, `Found excluded property: ${propKey}: ${value}`);
              return true;
            }
          }
        }
      }
    }
    return false;
  }
};

// src/ui/property-visibility.ts
var PropertyVisibility = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  get settings() {
    return this.plugin.settings;
  }
  /**
   * Parse comma-separated property keys from settings
   * @returns Array of property keys, defaults to ['aliases'] if empty
   */
  getAliasPropertyKeys() {
    const aliasPropertyKey = this.settings.aliasPropertyKey || "aliases";
    return aliasPropertyKey.split(",").map((key) => key.trim()).filter((key) => key.length > 0);
  }
  /**
   * Sets up property hiding for specified property keys using DOM observation
   */
  setupPropertyHiding(propertyKeys) {
    this.cleanupPropertyObserver();
    this.propertyObserver = new MutationObserver((mutations) => {
      mutations.forEach(() => {
        propertyKeys.forEach((propertyKey) => {
          this.hideProperties(propertyKey);
        });
      });
    });
    this.propertyObserver.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ["data-property-key"]
    });
    propertyKeys.forEach((propertyKey) => {
      this.hideProperties(propertyKey);
    });
  }
  /**
   * Hides properties based on current settings and context
   */
  hideProperties(propertyKey) {
    const properties = document.querySelectorAll(`[data-property-key="${propertyKey}"]`);
    properties.forEach((property) => {
      var _a;
      const isInSourceView = property.closest(".cm-editor") && !property.closest(".metadata-container");
      if (isInSourceView) {
        return;
      }
      const isInSidebar = property.closest(".workspace-leaf-content") && !property.closest('.workspace-leaf-content[data-type="markdown"]') && !property.closest(".markdown-source-view") && !property.closest(".markdown-preview-view");
      let shouldHide = false;
      if (this.settings.hideAliasProperty === "always") {
        if (isInSidebar && !this.settings.hideAliasInSidebar) {
          shouldHide = false;
        } else {
          shouldHide = true;
        }
      } else if (this.settings.hideAliasProperty === "when_empty") {
        const valueContainer = property.querySelector(".metadata-property-value");
        const isEmpty = !valueContainer || ((_a = valueContainer.textContent) == null ? void 0 : _a.trim()) === "" || valueContainer.children.length === 0;
        if (isEmpty) {
          if (isInSidebar && !this.settings.hideAliasInSidebar) {
            shouldHide = false;
          } else {
            shouldHide = true;
          }
        } else {
          shouldHide = false;
        }
      }
      const metadataContainer = property.closest(".metadata-container");
      const metadataProperties = property.closest(".metadata-properties");
      if (shouldHide) {
        if (metadataProperties) {
          const allProperties = metadataProperties.querySelectorAll(".metadata-property[data-property-key]");
          if (allProperties.length === 1 && allProperties[0] === property) {
            if (isInSidebar) {
              metadataProperties.addClass("flit-container-hidden");
              metadataProperties.removeClass("flit-container-visible");
            } else {
              if (metadataContainer) {
                metadataContainer.addClass("flit-container-hidden");
                metadataContainer.removeClass("flit-container-visible");
              } else {
                metadataProperties.addClass("flit-container-hidden");
                metadataProperties.removeClass("flit-container-visible");
              }
            }
          } else {
            property.addClass("flit-property-hidden");
            property.removeClass("flit-property-visible");
            metadataProperties.removeClass("flit-container-hidden");
            metadataProperties.addClass("flit-container-visible");
            if (metadataContainer) {
              metadataContainer.removeClass("flit-container-hidden");
              metadataContainer.addClass("flit-container-visible");
            }
          }
        } else {
          property.addClass("flit-property-hidden");
          property.removeClass("flit-property-visible");
        }
      } else {
        property.removeClass("flit-property-hidden");
        property.addClass("flit-property-visible");
        if (metadataProperties) {
          metadataProperties.removeClass("flit-container-hidden");
          metadataProperties.addClass("flit-container-visible");
        }
        if (metadataContainer) {
          metadataContainer.removeClass("flit-container-hidden");
          metadataContainer.addClass("flit-container-visible");
        }
      }
    });
  }
  /**
   * Cleans up the property observer and restores any hidden elements
   */
  cleanupPropertyObserver() {
    if (this.propertyObserver) {
      this.propertyObserver.disconnect();
      this.propertyObserver = void 0;
    }
    const hiddenProperties = document.querySelectorAll(".flit-property-hidden");
    hiddenProperties.forEach((property) => {
      property.removeClass("flit-property-hidden");
      property.addClass("flit-property-visible");
    });
    const hiddenContainers = document.querySelectorAll(".flit-container-hidden");
    hiddenContainers.forEach((container) => {
      container.removeClass("flit-container-hidden");
      container.addClass("flit-container-visible");
    });
  }
  /**
   * Updates property visibility based on current settings
   */
  updatePropertyVisibility() {
    var _a;
    (_a = document.head.querySelector("#flit-hide-property-style")) == null ? void 0 : _a.remove();
    this.cleanupPropertyObserver();
    if (this.settings.hideAliasProperty === "never") {
      return;
    }
    const propertyKeys = this.getAliasPropertyKeys();
    if (this.settings.hideAliasProperty === "always" || this.settings.hideAliasProperty === "when_empty") {
      this.setupPropertyHiding(propertyKeys);
    }
  }
  /**
   * Cleans up all property visibility related observers and styles
   */
  cleanup() {
    this.cleanupPropertyObserver();
  }
};

// node_modules/monkey-around/dist/index.mjs
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const inherited = obj[method], hadOwn = obj.hasOwnProperty(method), original = hadOwn ? inherited : function() {
    return Object.getPrototypeOf(obj)[method].apply(this, arguments);
  };
  let current = createWrapper(original);
  if (inherited)
    Object.setPrototypeOf(current, inherited);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, inherited || Function);
  }
}

// src/core/cache-manager.ts
var DEFAULT_CACHE_CONFIG = {
  maxContentEntries: 1e3,
  maxOperationEntries: 500,
  maintenanceIntervalMs: 3e5,
  // 5 minutes - safety net for edge case cleanup
  staleThresholdMs: 10 * 60 * 1e3
};
var LRUCache = class {
  constructor(maxSize) {
    this.maxSize = maxSize;
    this.cache = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }
  get(key) {
    const value = this.cache.get(key);
    if (value !== void 0) {
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }
  has(key) {
    return this.cache.has(key);
  }
  delete(key) {
    return this.cache.delete(key);
  }
  clear() {
    this.cache.clear();
  }
  size() {
    return this.cache.size;
  }
  keys() {
    return this.cache.keys();
  }
};
var FileExistenceCache = class {
  constructor(plugin) {
    this.pathCache = /* @__PURE__ */ new Set();
    this.lastUpdate = 0;
    this.cacheTTL = 5e3;
    this.plugin = plugin;
  }
  exists(path) {
    const now = Date.now();
    if (now - this.lastUpdate > this.cacheTTL) {
      this.rebuildCache();
      this.lastUpdate = now;
    }
    return this.pathCache.has(path.toLowerCase()) || this.plugin.app.vault.getAbstractFileByPath(path) !== null;
  }
  rebuildCache() {
    this.pathCache.clear();
    const files = this.plugin.app.vault.getAllLoadedFiles();
    for (const file of files) {
      this.pathCache.add(file.path.toLowerCase());
    }
  }
  addPath(path) {
    this.pathCache.add(path.toLowerCase());
  }
  removePath(path) {
    this.pathCache.delete(path.toLowerCase());
  }
  clear() {
    this.pathCache.clear();
    this.lastUpdate = 0;
  }
};
var CacheManager = class {
  constructor(plugin, config = DEFAULT_CACHE_CONFIG) {
    // Maintenance
    this.maintenanceTimer = null;
    this.isDisposed = false;
    this.config = config;
    this.contentCache = new LRUCache(config.maxContentEntries);
    this.tempPaths = /* @__PURE__ */ new Set();
    this.fileExistence = new FileExistenceCache(plugin);
    this.operationTracker = /* @__PURE__ */ new Map();
    this.aliasTimers = /* @__PURE__ */ new Map();
    this.aliasInProgress = /* @__PURE__ */ new Set();
    this.firstRenames = /* @__PURE__ */ new Set();
    if (config.maintenanceIntervalMs > 0) {
      this.startMaintenance();
    }
  }
  // ==================== CONTENT CACHE ====================
  /**
   * Get cached content for a file - O(1) operation
   */
  getContent(filePath) {
    return this.contentCache.get(filePath);
  }
  /**
   * Store content in cache - O(1) operation with LRU eviction
   */
  setContent(filePath, content) {
    this.contentCache.set(filePath, content);
  }
  /**
   * Check if content has changed - O(1) operation
   */
  hasContentChanged(filePath, currentContent) {
    const cachedContent = this.contentCache.get(filePath);
    return cachedContent !== currentContent;
  }
  // ==================== TEMP PATHS (CONFLICT PREVENTION) ====================
  /**
   * Reserve a path to prevent conflicts - O(1) operation (vs O(n) with array)
   */
  reservePath(path) {
    this.tempPaths.add(path.toLowerCase());
  }
  /**
   * Release a reserved path - O(1) operation
   */
  releasePath(path) {
    this.tempPaths.delete(path.toLowerCase());
  }
  /**
   * Release multiple paths at once (for batch operations)
   */
  releasePathsBatch(paths) {
    for (const path of paths) {
      this.tempPaths.delete(path.toLowerCase());
    }
  }
  /**
   * Clear all reserved paths (for immediate cleanup after batch operations)
   */
  clearReservedPaths() {
    this.tempPaths.clear();
  }
  /**
   * Check if path is reserved - O(1) operation (vs O(n) with array.some())
   */
  isPathReserved(path) {
    return this.tempPaths.has(path.toLowerCase());
  }
  /**
   * Check for path conflicts - O(1) operation combining existence + reservation
   */
  hasPathConflict(path) {
    return this.fileExistence.exists(path) || this.isPathReserved(path);
  }
  // ==================== FILE EXISTENCE CACHE ====================
  /**
   * Check if file exists - O(1) with TTL cache
   */
  fileExists(path) {
    return this.fileExistence.exists(path);
  }
  /**
   * Notify cache of new file creation
   */
  notifyFileCreated(path) {
    this.fileExistence.addPath(path);
  }
  /**
   * Notify cache of file deletion
   */
  notifyFileDeleted(path) {
    this.fileExistence.removePath(path);
    this.contentCache.delete(path);
    this.releasePath(path);
    this.operationTracker.delete(path);
    this.firstRenames.delete(path);
  }
  /**
   * Update cache when file is renamed
   */
  notifyFileRenamed(oldPath, newPath) {
    const content = this.contentCache.get(oldPath);
    if (content !== void 0) {
      this.contentCache.delete(oldPath);
      this.contentCache.set(newPath, content);
    }
    this.fileExistence.removePath(oldPath);
    this.fileExistence.addPath(newPath);
    const operation = this.operationTracker.get(oldPath);
    if (operation) {
      this.operationTracker.delete(oldPath);
      this.operationTracker.set(newPath, operation);
    }
    if (this.firstRenames.has(oldPath)) {
      this.firstRenames.delete(oldPath);
      this.firstRenames.add(newPath);
    }
    this.releasePath(oldPath);
    this.reservePath(newPath);
  }
  // ==================== OPERATION TRACKING ====================
  /**
   * Track operation for rate limiting and conflict prevention
   */
  trackOperation(filePath, content) {
    const existing = this.operationTracker.get(filePath);
    if (existing) {
      existing.count++;
      existing.lastContent = content;
      existing.lastUpdate = Date.now();
    } else {
      this.operationTracker.set(filePath, {
        count: 1,
        lastContent: content,
        lastUpdate: Date.now()
      });
    }
  }
  /**
   * Get operation data for a file
   */
  getOperationData(filePath) {
    return this.operationTracker.get(filePath);
  }
  // ==================== ALIAS MANAGEMENT ====================
  /**
   * Set alias update timer
   */
  setAliasTimer(filePath, timer) {
    const existing = this.aliasTimers.get(filePath);
    if (existing) {
      clearTimeout(existing);
    }
    this.aliasTimers.set(filePath, timer);
  }
  /**
   * Clear alias timer
   */
  clearAliasTimer(filePath) {
    const timer = this.aliasTimers.get(filePath);
    if (timer) {
      clearTimeout(timer);
      this.aliasTimers.delete(filePath);
    }
  }
  /**
   * Mark alias operation as in progress
   */
  markAliasInProgress(filePath) {
    this.aliasInProgress.add(filePath);
  }
  /**
   * Mark alias operation as completed
   */
  markAliasCompleted(filePath) {
    this.aliasInProgress.delete(filePath);
    this.clearAliasTimer(filePath);
  }
  /**
   * Check if alias operation is in progress
   */
  isAliasInProgress(filePath) {
    return this.aliasInProgress.has(filePath);
  }
  /**
   * Clear all alias timers (used during plugin unload)
   */
  clearAllAliasTimers() {
    for (const timer of this.aliasTimers.values()) {
      clearTimeout(timer);
    }
    this.aliasTimers.clear();
    this.aliasInProgress.clear();
  }
  // ==================== FIRST RENAME TRACKING ====================
  /**
   * Check if this is the first rename for a file
   */
  isFirstRename(filePath) {
    return !this.firstRenames.has(filePath);
  }
  /**
   * Mark file as having been renamed
   */
  markFileRenamed(filePath) {
    this.firstRenames.add(filePath);
  }
  /**
   * Clear first rename tracking for a file
   */
  clearFirstRenameTracking(filePath) {
    this.firstRenames.delete(filePath);
  }
  // ==================== MAINTENANCE & CLEANUP ====================
  /**
   * Start automatic maintenance cycle (only if configured)
   * Note: Most cleanup is now done immediately after operations complete
   */
  startMaintenance() {
    if (this.maintenanceTimer) return;
    this.maintenanceTimer = setInterval(() => {
      if (!this.isDisposed) {
        this.performMaintenance();
      }
    }, this.config.maintenanceIntervalMs);
  }
  /**
   * Perform maintenance - clean up stale entries (legacy fallback only)
   * Most cleanup is now done immediately after operations complete
   */
  performMaintenance() {
    const now = Date.now();
    const cutoff = now - this.config.staleThresholdMs;
    for (const [path, data] of this.operationTracker.entries()) {
      if (data.lastUpdate < cutoff) {
        this.operationTracker.delete(path);
      }
    }
    const validPaths = /* @__PURE__ */ new Set();
    for (const path of this.tempPaths) {
      if (this.fileExistence.exists(path)) {
        validPaths.add(path);
      }
    }
    this.tempPaths = validPaths;
    for (const path of this.aliasInProgress) {
      if (!this.fileExistence.exists(path)) {
        this.aliasInProgress.delete(path);
        this.clearAliasTimer(path);
      }
    }
  }
  /**
   * Get cache statistics for monitoring
   */
  getStats() {
    return {
      contentCacheSize: this.contentCache.size(),
      tempPathsCount: this.tempPaths.size,
      operationsTracked: this.operationTracker.size,
      aliasTimersActive: this.aliasTimers.size,
      aliasInProgressCount: this.aliasInProgress.size
    };
  }
  /**
   * Force immediate cleanup
   */
  forceCleanup() {
    this.performMaintenance();
  }
  /**
   * Dispose of cache manager and clean up all resources
   */
  dispose() {
    this.isDisposed = true;
    if (this.maintenanceTimer) {
      clearInterval(this.maintenanceTimer);
      this.maintenanceTimer = null;
    }
    for (const timer of this.aliasTimers.values()) {
      clearTimeout(timer);
    }
    this.contentCache.clear();
    this.tempPaths.clear();
    this.fileExistence.clear();
    this.operationTracker.clear();
    this.aliasTimers.clear();
    this.aliasInProgress.clear();
    this.firstRenames.clear();
  }
};

// src/core/editor-lifecycle.ts
var import_obsidian20 = require("obsidian");
init_utils();
var EditorLifecycleManager = class {
  constructor(plugin) {
    // Track files currently open in editors (with last-seen timestamp)
    this.openEditorFiles = /* @__PURE__ */ new Map();
    // Interval-based checking system
    this.pendingChecks = /* @__PURE__ */ new Map();
    this.checkTimer = null;
    // Track active editors for tab close detection
    this.activeEditorFiles = /* @__PURE__ */ new Map();
    // Throttle timer system for checkInterval > 0
    this.throttleTimers = /* @__PURE__ */ new Map();
    // Track files in creation delay period with their timer references
    this.creationDelayTimers = /* @__PURE__ */ new Map();
    // Track files that were just processed on tab close to prevent duplicate processing
    this.recentlyProcessedCloses = /* @__PURE__ */ new Set();
    this.plugin = plugin;
  }
  get app() {
    return this.plugin.app;
  }
  get settings() {
    return this.plugin.settings;
  }
  get isFullyLoaded() {
    return this.plugin.isFullyLoaded;
  }
  get renameEngine() {
    return this.plugin.renameEngine;
  }
  /**
   * Set creation delay timer for a file
   */
  setCreationDelayTimer(filePath, timer) {
    this.creationDelayTimers.set(filePath, timer);
    verboseLog(this.plugin, `Set creation delay timer for: ${filePath}`);
  }
  /**
   * Clear creation delay timer for a file
   */
  clearCreationDelayTimer(filePath) {
    const timer = this.creationDelayTimers.get(filePath);
    if (timer) {
      clearTimeout(timer);
      this.creationDelayTimers.delete(filePath);
      verboseLog(this.plugin, `Cleared creation delay timer for: ${filePath}`);
    }
  }
  /**
   * Check if a file is in creation delay period
   */
  isFileInCreationDelay(filePath) {
    return this.creationDelayTimers.has(filePath);
  }
  /**
   * Initialize the checking system based on settings
   */
  initializeCheckingSystem() {
    this.clearCheckingSystems();
    this.trackActiveEditors();
    if (this.settings.checkInterval === 0) {
      this.setupEventBasedChecking();
    } else {
      this.setupThrottleBasedChecking();
    }
  }
  /**
   * Setup event-based checking (immediate processing)
   */
  setupEventBasedChecking() {
    verboseLog(this.plugin, "Setting up event-based checking (immediate)");
  }
  /**
   * Setup throttle-based checking (process N ms after editor change)
   */
  setupThrottleBasedChecking() {
    verboseLog(this.plugin, `Setting up throttle-based checking (${this.settings.checkInterval}ms delay)`);
  }
  /**
   * Register workspace events to track open editors
   */
  trackActiveEditors() {
    this.plugin.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.updateActiveEditorTracking();
      })
    );
    this.plugin.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.updateActiveEditorTracking();
      })
    );
    this.updateActiveEditorTracking();
  }
  /**
   * Update tracking of active editors
   */
  async updateActiveEditorTracking() {
    var _a;
    const markdownViews = this.app.workspace.getLeavesOfType("markdown");
    const newActiveFiles = /* @__PURE__ */ new Map();
    const activeLeafIds = /* @__PURE__ */ new Set();
    for (const leaf of markdownViews) {
      const view = leaf.view;
      if (view && view.file && view.editor) {
        try {
          const leafId = leaf.id;
          activeLeafIds.add(leafId);
          const firstLine = this.extractFirstLineFromEditor(view.editor, view.file);
          const existing = this.activeEditorFiles.get(view.file.path);
          newActiveFiles.set(view.file.path, {
            file: view.file,
            editor: view.editor,
            lastFirstLine: (existing == null ? void 0 : existing.lastFirstLine) || firstLine,
            leafId
          });
        } catch (error) {
          console.error(`Error tracking editor for ${view.file.path}:`, error);
        }
      }
    }
    if (this.isFullyLoaded && this.settings.renameNotes === "automatically") {
      for (const [filePath, oldData] of this.activeEditorFiles) {
        if (!newActiveFiles.has(filePath)) {
          let stillOpen = false;
          for (const newData of newActiveFiles.values()) {
            if (newData.file === oldData.file) {
              stillOpen = true;
              verboseLog(this.plugin, `File ${filePath} was renamed, not closed - skipping tab close processing`);
              break;
            }
          }
          if (stillOpen) {
            continue;
          }
          if (activeLeafIds.has(oldData.leafId)) {
            verboseLog(this.plugin, `File ${filePath} switched in same tab (leaf ${oldData.leafId} still active) - skipping tab close processing`);
            continue;
          }
          if (this.recentlyProcessedCloses.has(filePath)) {
            verboseLog(this.plugin, `File ${filePath} already processed on tab close - skipping duplicate`);
            continue;
          }
          verboseLog(this.plugin, `Tab closed for: ${filePath}`);
          (_a = this.plugin.cacheManager) == null ? void 0 : _a.clearFirstRenameTracking(filePath);
          this.recentlyProcessedCloses.add(filePath);
          setTimeout(() => {
            this.recentlyProcessedCloses.delete(filePath);
          }, 100);
          const hasThrottleTimer = this.throttleTimers.has(filePath);
          if (hasThrottleTimer) {
            verboseLog(this.plugin, `Tab close overriding throttle timer for: ${filePath}`);
            this.clearThrottleTimer(filePath);
            verboseLog(this.plugin, `Processing immediately due to pending throttle: ${filePath}`);
            try {
              await this.renameEngine.processFile(oldData.file, true);
            } catch (error) {
              console.error(`Error processing closed file ${filePath}:`, error);
            }
          } else {
            verboseLog(this.plugin, `Tab closed with no pending throttle: ${filePath} - no action needed`);
          }
        }
      }
    }
    this.activeEditorFiles = newActiveFiles;
    verboseLog(this.plugin, `Tracking ${this.activeEditorFiles.size} active editor files for tab close detection`);
  }
  /**
   * Handle editor change with throttle for checkInterval > 0
   * Only starts timer if first line actually changed from last known state
   */
  handleEditorChangeWithThrottle(editor, file) {
    const filePath = file.path;
    if (this.isFileInCreationDelay(filePath)) {
      verboseLog(this.plugin, `File in creation delay, skipping throttle: ${filePath}`);
      return;
    }
    const currentFirstLine = this.extractFirstLineFromEditor(editor, file);
    let tracked = this.activeEditorFiles.get(filePath);
    if (!tracked) {
      tracked = {
        file,
        editor,
        lastFirstLine: currentFirstLine,
        leafId: ""
        // Will be set properly by updateActiveEditorTracking
      };
      this.activeEditorFiles.set(filePath, tracked);
      verboseLog(this.plugin, `Initialized tracking on first editor change for ${filePath}: "${currentFirstLine}"`);
    }
    const lastFirstLine = tracked.lastFirstLine;
    if (lastFirstLine !== void 0 && lastFirstLine === currentFirstLine) {
      verboseLog(this.plugin, `First line unchanged for ${filePath}, skipping throttle`);
      return;
    }
    if (tracked) {
      tracked.lastFirstLine = currentFirstLine;
    }
    if (this.throttleTimers.has(filePath)) {
      verboseLog(this.plugin, `Throttle timer already running for: ${filePath}, not starting new one`);
      return;
    }
    verboseLog(this.plugin, `Starting throttle timer (${this.settings.checkInterval}ms) for: ${filePath}`);
    const timer = setTimeout(async () => {
      verboseLog(this.plugin, `Throttle timer expired, processing: ${filePath}`);
      this.throttleTimers.delete(filePath);
      try {
        await this.renameEngine.processEditorChangeOptimal(editor, file);
      } catch (error) {
        console.error(`Error processing throttled change for ${filePath}:`, error);
      }
    }, this.settings.checkInterval);
    this.throttleTimers.set(filePath, timer);
  }
  /**
   * Clear throttle timer for a specific file
   */
  clearThrottleTimer(filePath) {
    const timer = this.throttleTimers.get(filePath);
    if (timer) {
      clearTimeout(timer);
      this.throttleTimers.delete(filePath);
      verboseLog(this.plugin, `Cleared throttle timer for: ${filePath}`);
    }
  }
  /**
   * Update lastFirstLine for a file after processing
   * Called after rename completes to sync tracking state
   */
  updateLastFirstLine(filePath, firstLine) {
    const tracked = this.activeEditorFiles.get(filePath);
    if (tracked) {
      tracked.lastFirstLine = firstLine;
      verboseLog(this.plugin, `Updated lastFirstLine for ${filePath}: "${firstLine}"`);
    }
  }
  /**
   * Clear all checking systems and state
   */
  clearCheckingSystems() {
    if (this.checkTimer) {
      clearTimeout(this.checkTimer);
      this.checkTimer = null;
    }
    for (const timer of this.throttleTimers.values()) {
      clearTimeout(timer);
    }
    this.throttleTimers.clear();
    for (const timer of this.creationDelayTimers.values()) {
      clearTimeout(timer);
    }
    this.creationDelayTimers.clear();
    this.activeEditorFiles.clear();
    this.pendingChecks.clear();
  }
  /**
   * Extract first line from editor content
   */
  extractFirstLineFromEditor(editor, file) {
    try {
      const content = editor.getValue();
      const lines = content.split("\n");
      const metadata = this.app.metadataCache.getFileCache(file);
      let firstLineIndex = 0;
      if (metadata == null ? void 0 : metadata.frontmatterPosition) {
        firstLineIndex = metadata.frontmatterPosition.end.line + 1;
      }
      for (let i = firstLineIndex; i < lines.length; i++) {
        const line = lines[i];
        if (line.trim() !== "") {
          return line;
        }
      }
      return "";
    } catch (error) {
      console.error(`Error extracting first line from ${file.path}:`, error);
      return "";
    }
  }
  /**
   * Extract first line from file content string
   */
  extractFirstLineFromContent(content, file) {
    try {
      const lines = content.split("\n");
      const metadata = this.app.metadataCache.getFileCache(file);
      let firstLineIndex = 0;
      if (metadata == null ? void 0 : metadata.frontmatterPosition) {
        firstLineIndex = metadata.frontmatterPosition.end.line + 1;
      }
      for (let i = firstLineIndex; i < lines.length; i++) {
        const line = lines[i];
        if (line.trim() !== "") {
          return line;
        }
      }
      return "";
    } catch (error) {
      console.error(`Error extracting first line from content for ${file.path}:`, error);
      return "";
    }
  }
  /**
   * Check if a file is currently open in an editor
   */
  isFileOpenInEditor(file) {
    let isOpen = false;
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a;
      if (leaf.view instanceof import_obsidian20.MarkdownView && ((_a = leaf.view.file) == null ? void 0 : _a.path) === file.path) {
        isOpen = true;
        return false;
      }
    });
    return isOpen;
  }
  /**
   * Process pending editor changes (kept for backward compatibility)
   */
  processPendingEditorChanges() {
    verboseLog(this.plugin, `processPendingEditorChanges called - no action needed with immediate processing`);
  }
  /**
   * Get open editor files map (for external access)
   */
  getOpenEditorFiles() {
    return this.openEditorFiles;
  }
  /**
   * Get active editor files map (for external access)
   */
  getActiveEditorFiles() {
    return this.activeEditorFiles;
  }
};

// src/core/workspace-integration.ts
var import_obsidian21 = require("obsidian");
init_utils();
var WorkspaceIntegration = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  get app() {
    return this.plugin.app;
  }
  get settings() {
    return this.plugin.settings;
  }
  get isFullyLoaded() {
    return this.plugin.isFullyLoaded;
  }
  get renameEngine() {
    return this.plugin.renameEngine;
  }
  /**
   * Setup custom icons in command palette
   */
  setupCommandPaletteIcons() {
    const commandIcons = /* @__PURE__ */ new Map([
      ["Put first line in title", "file-pen"],
      ["Put first line in title (unless excluded)", "file-pen"],
      ["Put first line in title in all notes", "files"],
      ["Disable renaming for note", "square-x"],
      ["Enable renaming for note", "square-check"]
    ]);
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node instanceof HTMLElement) {
            const suggestionItems = node.querySelectorAll('.suggestion-item, [class*="suggestion"]');
            suggestionItems.forEach((item) => {
              var _a;
              if (item instanceof HTMLElement) {
                const titleElement = item.querySelector('.suggestion-title, [class*="title"]');
                if (titleElement) {
                  const commandName = (_a = titleElement.textContent) == null ? void 0 : _a.trim();
                  if (commandName && commandIcons.has(commandName)) {
                    if (!item.querySelector(".flit-command-icon")) {
                      const iconName = commandIcons.get(commandName);
                      const iconElement = document.createElement("div");
                      iconElement.classList.add("flit-command-icon");
                      (0, import_obsidian21.setIcon)(iconElement, iconName);
                      item.insertBefore(iconElement, item.firstChild);
                    }
                  }
                }
              }
            });
          }
        });
      });
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    this.commandPaletteObserver = observer;
  }
  /**
   * Register ribbon icons according to settings
   */
  registerRibbonIcons() {
    const ribbonActions = [
      {
        condition: this.settings.ribbonVisibility.renameCurrentFile,
        icon: "file-pen",
        title: "Put first line in title",
        callback: () => this.plugin.commandRegistrar.executeRenameCurrentFile()
      },
      {
        condition: this.settings.ribbonVisibility.renameAllNotes,
        icon: "files",
        title: "Put first line in title in all notes",
        callback: () => {
          const { RenameAllFilesModal: RenameAllFilesModal3 } = (init_modals(), __toCommonJS(modals_exports));
          new RenameAllFilesModal3(this.app, this.plugin).open();
        }
      },
      {
        condition: this.settings.ribbonVisibility.toggleAutomaticRenaming,
        icon: "file-cog",
        title: "Toggle automatic renaming",
        callback: () => this.plugin.commandRegistrar.executeToggleAutomaticRenaming()
      }
    ];
    ribbonActions.forEach((action) => {
      if (action.condition) {
        this.plugin.addRibbonIcon(action.icon, action.title, action.callback);
      }
    });
  }
  /**
   * Setup save event hook for rename on save
   */
  setupSaveEventHook() {
    var _a, _b;
    const saveCommand = (_b = (_a = this.app.commands) == null ? void 0 : _a.commands) == null ? void 0 : _b["editor:save-file"];
    if (saveCommand) {
      this.originalSaveCallback = saveCommand.checkCallback;
      saveCommand.checkCallback = (checking) => {
        const result = this.originalSaveCallback ? this.originalSaveCallback(checking) : true;
        if (!checking && this.settings.renameOnSave) {
          const activeFile = this.app.workspace.getActiveFile();
          if (activeFile && activeFile.extension === "md") {
            setTimeout(() => {
              this.plugin.commandRegistrar.executeRenameUnlessExcluded();
            }, 100);
          }
        }
        return result;
      };
      verboseLog(this.plugin, "Save event hook installed for rename on save");
    }
  }
  /**
   * Setup processing for new files - sequential execution after single delay
   */
  setupCursorPositioning() {
    this.plugin.registerEvent(
      this.app.vault.on("create", async (file) => {
        if (!(file instanceof import_obsidian21.TFile) || file.extension !== "md") return;
        if (file.stat.ctime < this.plugin.pluginLoadTime - 1e3) {
          return;
        }
        const plugin = this.plugin;
        const app = this.app;
        const settings = this.settings;
        if (!(plugin == null ? void 0 : plugin.fileOperations)) {
          verboseLog(plugin, `CREATE: Plugin not fully initialized, skipping ${file.name}`);
          return;
        }
        const processFileCreation = async () => {
          var _a, _b;
          let initialContent = "";
          try {
            const leaves = app.workspace.getLeavesOfType("markdown");
            for (const leaf of leaves) {
              const view = leaf.view;
              if (view && ((_a = view.file) == null ? void 0 : _a.path) === file.path && view.editor) {
                initialContent = view.editor.getValue();
                verboseLog(plugin, `CREATE: Captured initial editor content for ${file.path}: ${initialContent.length} chars`);
                break;
              }
            }
          } catch (error) {
            verboseLog(plugin, `CREATE: Could not read initial editor content`);
          }
          verboseLog(plugin, `CREATE: New file created, processing in ${settings.newNoteDelay}ms: ${file.name}`);
          const untitledPattern = /^Untitled(\s[1-9]\d*)?$/;
          const isUntitled = untitledPattern.test(file.basename);
          if (settings.renameNotes === "automatically" && settings.moveCursorToFirstLine) {
            if (!settings.waitForCursorTemplate) {
              const isExcluded = await plugin.fileOperations.isFileExcludedForCursorPositioning(file, initialContent);
              if (!isExcluded) {
                const activeView = app.workspace.getActiveViewOfType(import_obsidian21.MarkdownView);
                const inCanvas = !activeView;
                if (!inCanvas) {
                  requestAnimationFrame(() => {
                    setTimeout(() => {
                      const hasContent = initialContent.trim() !== "";
                      const willSkipTitleInsertion = !settings.insertTitleOnCreation || isUntitled || hasContent;
                      plugin.fileOperations.handleCursorPositioning(file, willSkipTitleInsertion);
                    }, 200);
                  });
                }
              } else {
                verboseLog(plugin, `Skipping cursor positioning - file is excluded: ${file.path}`);
              }
            } else {
              verboseLog(plugin, `Waiting for template before cursor positioning: ${file.path}`);
              const templateWaitTime = 600;
              await plugin.fileOperations.waitForYamlOrTimeout(file, templateWaitTime);
              const leaves = app.workspace.getLeavesOfType("markdown");
              let currentContent;
              for (const leaf of leaves) {
                const view = leaf.view;
                if (view && ((_b = view.file) == null ? void 0 : _b.path) === file.path && view.editor) {
                  currentContent = view.editor.getValue();
                  break;
                }
              }
              file._flitTemplateContent = currentContent;
              const isExcluded = await plugin.fileOperations.isFileExcludedForCursorPositioning(file, currentContent);
              if (!isExcluded) {
                const activeView = app.workspace.getActiveViewOfType(import_obsidian21.MarkdownView);
                const inCanvas = !activeView;
                if (!inCanvas) {
                  requestAnimationFrame(() => {
                    setTimeout(() => {
                      const hasContent = currentContent && currentContent.trim() !== "";
                      const willSkipTitleInsertion = !settings.insertTitleOnCreation || isUntitled || hasContent;
                      plugin.fileOperations.handleCursorPositioning(file, willSkipTitleInsertion);
                    }, 200);
                  });
                }
              } else {
                verboseLog(plugin, `Skipping cursor positioning after template - file is excluded: ${file.path}`);
              }
            }
          }
          const timer = setTimeout(async () => {
            var _a2;
            verboseLog(plugin, `CREATE: Processing new file after delay: ${file.name}`);
            let titleWasInserted = false;
            try {
              if (settings.insertTitleOnCreation) {
                const templateContent = file._flitTemplateContent;
                let skipTitleDueToExclusion = false;
                if (settings.waitForTemplate && templateContent) {
                  const isExcluded = await plugin.fileOperations.isFileExcludedForCursorPositioning(file, templateContent);
                  if (isExcluded) {
                    verboseLog(plugin, `Skipping title insertion - file is excluded: ${file.path}`);
                    skipTitleDueToExclusion = true;
                  }
                }
                if (!skipTitleDueToExclusion) {
                  titleWasInserted = await plugin.fileOperations.insertTitleOnCreation(file, initialContent, templateContent);
                  verboseLog(plugin, `CREATE: insertTitleOnCreation returned ${titleWasInserted}`);
                }
              }
              if (settings.renameNotes === "automatically" && settings.moveCursorToFirstLine) {
                if (titleWasInserted && settings.placeCursorAtLineEnd) {
                  const leaves = app.workspace.getLeavesOfType("markdown");
                  let currentContent;
                  for (const leaf of leaves) {
                    const view = leaf.view;
                    if (view && ((_a2 = view.file) == null ? void 0 : _a2.path) === file.path && view.editor) {
                      currentContent = view.editor.getValue();
                      break;
                    }
                  }
                  const isExcluded = await plugin.fileOperations.isFileExcludedForCursorPositioning(file, currentContent);
                  if (!isExcluded) {
                    const activeView = app.workspace.getActiveViewOfType(import_obsidian21.MarkdownView);
                    const inCanvas = !activeView;
                    if (!inCanvas) {
                      requestAnimationFrame(() => {
                        setTimeout(() => {
                          plugin.fileOperations.handleCursorPositioning(file);
                        }, 200);
                      });
                    }
                  } else {
                    verboseLog(plugin, `Skipping post-title cursor repositioning - file is excluded: ${file.path}`);
                  }
                }
              }
              if (settings.renameNotes === "automatically" && plugin.isFullyLoaded) {
                let editorContent;
                const leaves = app.workspace.getLeavesOfType("markdown");
                for (const leaf of leaves) {
                  const view = leaf.view;
                  if (view && view.file && view.file.path === file.path && view.editor) {
                    const value = view.editor.getValue();
                    if (typeof value === "string") {
                      editorContent = value;
                    }
                    break;
                  }
                }
                await plugin.renameEngine.processFile(file, true, false, editorContent);
              }
              verboseLog(plugin, `CREATE: Completed processing new file: ${file.name}`);
            } catch (error) {
              console.error(`CREATE: Failed to process new file ${file.path}:`, error);
            } finally {
              delete file._flitTemplateContent;
              plugin.editorLifecycle.clearCreationDelayTimer(file.path);
            }
          }, settings.newNoteDelay);
          plugin.editorLifecycle.setCreationDelayTimer(file.path, timer);
        };
        const checkViewReady = async () => {
          var _a;
          const leaves = app.workspace.getLeavesOfType("markdown");
          for (const leaf of leaves) {
            const view = leaf.view;
            if (view && ((_a = view.file) == null ? void 0 : _a.path) === file.path) {
              verboseLog(plugin, `CREATE: Markdown view ready for ${file.name}`);
              return true;
            }
          }
          return false;
        };
        const immediateCheck = await checkViewReady();
        if (immediateCheck) {
          verboseLog(plugin, `CREATE: File created ${file.name}, markdown view ready`);
          await processFileCreation();
        } else {
          setTimeout(async () => {
            const delayedCheck = await checkViewReady();
            if (delayedCheck) {
              await processFileCreation();
            } else {
              verboseLog(plugin, `CREATE: No markdown view found for ${file.name} after delay, skipping`);
            }
          }, 100);
        }
      })
    );
  }
  /**
   * Cleanup all workspace integrations
   */
  cleanup() {
    var _a, _b;
    if (this.originalSaveCallback) {
      const saveCommand = (_b = (_a = this.app.commands) == null ? void 0 : _a.commands) == null ? void 0 : _b["editor:save-file"];
      if (saveCommand) {
        saveCommand.checkCallback = this.originalSaveCallback;
      }
    }
    if (this.commandPaletteObserver) {
      this.commandPaletteObserver.disconnect();
      this.commandPaletteObserver = void 0;
    }
  }
  /**
   * Get command palette observer (for external access)
   */
  getCommandPaletteObserver() {
    return this.commandPaletteObserver;
  }
};

// src/core/property-manager.ts
var import_obsidian22 = require("obsidian");
init_utils();
var PropertyManager = class {
  constructor(plugin) {
    this.propertyTypeCache = /* @__PURE__ */ new Map();
    this.plugin = plugin;
  }
  get app() {
    return this.plugin.app;
  }
  get settings() {
    return this.plugin.settings;
  }
  /**
   * Setup notification suppression for external modification notices
   */
  setupNotificationSuppression() {
    this.notificationObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node instanceof HTMLElement) {
            const notices = node.classList.contains("notice") ? [node] : node.querySelectorAll(".notice");
            notices.forEach((notice) => {
              if (notice instanceof HTMLElement) {
                const noticeText = notice.textContent || "";
                const conditions = {
                  hasExternal: noticeText.includes("has been modified externally, merging changes automatically"),
                  hasMd: noticeText.includes(".md"),
                  noUpdated: !noticeText.includes("Updated"),
                  startsQuote: noticeText.trim().charCodeAt(0) === 8220,
                  // Left double quotation mark
                  shortEnough: noticeText.length < 200
                };
                if (this.settings.suppressMergeNotifications && conditions.hasExternal && conditions.hasMd && conditions.noUpdated && conditions.startsQuote && conditions.shortEnough) {
                  notice.style.display = "none";
                  verboseLog(this.plugin, `Suppressed external modification notice: ${noticeText.substring(0, 50)}...`);
                }
              }
            });
          }
        });
      });
    });
    this.notificationObserver.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  /**
   * Cleanup notification suppression observer
   */
  cleanupNotificationSuppression() {
    if (this.notificationObserver) {
      this.notificationObserver.disconnect();
      this.notificationObserver = void 0;
    }
  }
  /**
   * Get notification observer (for external access if needed)
   */
  getNotificationObserver() {
    return this.notificationObserver;
  }
  /**
   * Get path to types.json in vault's .obsidian folder
   */
  getTypesJsonPath() {
    return (0, import_obsidian22.normalizePath)(`${this.app.vault.configDir}/types.json`);
  }
  /**
   * Read types.json file
   */
  async readTypesJson() {
    const path = this.getTypesJsonPath();
    try {
      const content = await this.app.vault.adapter.read(path);
      return JSON.parse(content);
    } catch (error) {
      verboseLog(this.plugin, `types.json not found or invalid, creating new structure`);
      return { types: {} };
    }
  }
  /**
   * Write types.json file
   */
  async writeTypesJson(data) {
    const path = this.getTypesJsonPath();
    try {
      const content = JSON.stringify(data, null, 2);
      await this.app.vault.adapter.write(path, content);
      verboseLog(this.plugin, `Updated types.json`);
    } catch (error) {
      console.error("Failed to write types.json:", error);
    }
  }
  /**
   * Check if value is boolean (true or false)
   */
  isBooleanValue(value) {
    return value === true || value === false || value === "true" || value === "false";
  }
  /**
   * Normalize boolean values to actual boolean type
   */
  normalizeBooleanValue(value) {
    if (value === "true") return true;
    if (value === "false") return false;
    return value;
  }
  /**
   * Ensure property type is set to checkbox in types.json
   * Call this when "Disable renaming" commands are executed
   *
   * This ensures the property type is always checkbox when the property value is boolean,
   * regardless of what type it was before or if it existed at all.
   */
  async ensurePropertyTypeIsCheckbox() {
    const propertyKey = this.settings.disableRenamingKey;
    const propertyValue = this.settings.disableRenamingValue;
    if (!propertyKey) return;
    const normalizedValue = this.normalizeBooleanValue(propertyValue);
    const isBoolean = this.isBooleanValue(normalizedValue);
    if (!isBoolean) {
      verboseLog(this.plugin, `Property "${propertyKey}" value is not boolean (${propertyValue}), skipping type update`);
      return;
    }
    const typesData = await this.readTypesJson();
    const currentType = typesData.types[propertyKey];
    if (currentType !== "checkbox") {
      typesData.types[propertyKey] = "checkbox";
      await this.writeTypesJson(typesData);
      verboseLog(this.plugin, `Property "${propertyKey}" set to checkbox for disable renaming command`);
    }
    this.propertyTypeCache.set(propertyKey, "checkbox");
  }
};

// src/core/plugin-initializer.ts
init_utils();
var PluginInitializer = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  get settings() {
    return this.plugin.settings;
  }
  /**
   * Initialize first-enable logic for sections
   * Ensures that when features are enabled for the first time, their items are enabled
   */
  async initializeFirstEnableLogic() {
    let settingsChanged = false;
    if (this.settings.enableCustomReplacements && !this.settings.hasEnabledCustomReplacements) {
      this.settings.customReplacements.forEach((replacement) => {
        replacement.enabled = true;
      });
      this.settings.hasEnabledCustomReplacements = true;
      settingsChanged = true;
      verboseLog(this.plugin, "Initialized custom replacements on first enable");
    }
    if (this.settings.enableSafewords && !this.settings.hasEnabledSafewords) {
      this.settings.safewords.forEach((safeword) => {
        safeword.enabled = true;
      });
      this.settings.hasEnabledSafewords = true;
      settingsChanged = true;
      verboseLog(this.plugin, "Initialized safewords on first enable");
    }
    if (this.settings.enableForbiddenCharReplacements && !this.settings.hasEnabledForbiddenChars) {
      const allOSesKeys = ["leftBracket", "rightBracket", "hash", "caret", "pipe", "backslash", "slash", "colon", "dot"];
      allOSesKeys.forEach((key) => {
        this.settings.charReplacementEnabled[key] = true;
      });
      this.settings.hasEnabledForbiddenChars = true;
      settingsChanged = true;
      verboseLog(this.plugin, "Initialized forbidden char replacements on first enable");
    }
    if (settingsChanged) {
      await this.plugin.saveSettings();
    }
  }
  /**
   * Load external CSS styles
   */
  async loadStyles() {
    try {
      const css = await this.plugin.app.vault.adapter.read(`${this.plugin.manifest.dir}/styles.css`);
      const styleEl = document.createElement("style");
      styleEl.textContent = css;
      document.head.appendChild(styleEl);
    } catch (error) {
    }
  }
};

// src/core/command-registrar.ts
var import_obsidian23 = require("obsidian");
init_utils();
init_modals();
var CommandRegistrar = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  get app() {
    return this.plugin.app;
  }
  get settings() {
    return this.plugin.settings;
  }
  /**
   * Register all command palette commands based on settings
   */
  registerCommands() {
    if (!this.settings.enableCommandPalette) {
      return;
    }
    this.registerRenameCurrentFileCommand();
    this.registerRenameCurrentFileUnlessExcludedCommand();
    this.registerRenameAllFilesCommand();
    this.registerSafeInternalLinkCommand();
    this.registerSafeInternalLinkWithCaptionCommand();
    this.registerToggleAutomaticRenamingCommand();
    this.registerDisableRenamingCommand();
    this.registerEnableRenamingCommand();
  }
  /**
   * Execute rename current file (shared logic for command, ribbon, context menu)
   * Note: This command ignores folder/tag/property exclusions but ALWAYS respects disable property
   */
  async executeRenameCurrentFile() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "md") {
      verboseLog(this.plugin, `Showing notice: Error: no active note.`);
      new import_obsidian23.Notice("Error: no active note.");
      return;
    }
    verboseLog(this.plugin, `Manual rename command triggered for ${activeFile.path} (ignoring folder/tag/property exclusions, respecting disable property)`);
    const exclusionOverrides = { ignoreFolder: true, ignoreTag: true, ignoreProperty: true };
    await this.plugin.renameEngine.processFile(activeFile, true, true, void 0, false, exclusionOverrides, true);
  }
  /**
   * Register command: Put first line in title
   * Note: This command ignores folder/tag/property exclusions but ALWAYS respects disable property
   */
  registerRenameCurrentFileCommand() {
    if (!this.settings.commandPaletteVisibility.renameCurrentFile) {
      return;
    }
    this.plugin.addCommand({
      id: "rename-current-file",
      name: "Put first line in title",
      icon: "file-pen",
      callback: () => this.executeRenameCurrentFile()
    });
  }
  /**
   * Execute rename unless excluded (shared logic for command and save hook)
   */
  async executeRenameUnlessExcluded() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "md") {
      verboseLog(this.plugin, `Showing notice: Error: no active note.`);
      new import_obsidian23.Notice("Error: no active note.");
      return;
    }
    verboseLog(this.plugin, `Manual rename command triggered for ${activeFile.path} (unless excluded)`);
    await this.plugin.renameEngine.processFile(activeFile, true, true, void 0, false, void 0, true);
  }
  /**
   * Register command: Put first line in title (unless excluded)
   */
  registerRenameCurrentFileUnlessExcludedCommand() {
    if (!this.settings.commandPaletteVisibility.renameCurrentFileUnlessExcluded) {
      return;
    }
    this.plugin.addCommand({
      id: "rename-current-file-unless-excluded",
      name: "Put first line in title (unless excluded)",
      icon: "file-pen",
      callback: () => this.executeRenameUnlessExcluded()
    });
  }
  /**
   * Register command: Put first line in title in all notes
   */
  registerRenameAllFilesCommand() {
    if (!this.settings.commandPaletteVisibility.renameAllFiles) {
      return;
    }
    this.plugin.addCommand({
      id: "rename-all-files",
      name: "Put first line in title in all notes",
      icon: "file-pen",
      callback: () => {
        verboseLog(this.plugin, "Bulk rename command triggered");
        new RenameAllFilesModal(this.app, this.plugin).open();
      }
    });
  }
  /**
   * Register command: Add safe internal link
   */
  registerSafeInternalLinkCommand() {
    if (!this.settings.commandVisibility.addSafeInternalLink) {
      return;
    }
    this.plugin.addCommand({
      id: "add-safe-internal-link",
      name: "Add safe internal link",
      icon: "link",
      callback: async () => {
        await this.plugin.addSafeInternalLink();
      }
    });
  }
  /**
   * Register command: Add safe internal link with selection as caption
   */
  registerSafeInternalLinkWithCaptionCommand() {
    if (!this.settings.commandVisibility.addSafeInternalLinkWithCaption) {
      return;
    }
    this.plugin.addCommand({
      id: "add-safe-internal-link-with-caption",
      name: "Add safe internal link with selection as caption",
      icon: "link",
      callback: async () => {
        await this.plugin.addSafeInternalLinkWithCaption();
      }
    });
  }
  /**
   * Register command: Disable renaming for note
   * Uses checkCallback to only show when file doesn't have disable property
   */
  registerDisableRenamingCommand() {
    if (!this.settings.commandPaletteVisibility.disableRenaming) {
      return;
    }
    this.plugin.addCommand({
      id: "disable-renaming-for-note",
      name: "Disable renaming for note",
      icon: "square-x",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile || activeFile.extension !== "md") {
          return false;
        }
        const fileCache = this.app.metadataCache.getFileCache(activeFile);
        let hasProperty = false;
        if (fileCache && fileCache.frontmatter) {
          const value = fileCache.frontmatter[this.settings.disableRenamingKey];
          if (value !== void 0 && value !== null) {
            const { normalizePropertyValue: normalizePropertyValue2 } = (init_utils(), __toCommonJS(utils_exports));
            const normalizedValue = normalizePropertyValue2(value);
            const normalizedExpected = normalizePropertyValue2(this.settings.disableRenamingValue);
            if (typeof normalizedValue === "string" && typeof normalizedExpected === "string") {
              hasProperty = normalizedValue.toLowerCase() === normalizedExpected.toLowerCase();
            } else {
              hasProperty = normalizedValue === normalizedExpected;
            }
          }
        }
        if (hasProperty) {
          return false;
        }
        if (!checking) {
          this.executeDisableRenaming();
        }
        return true;
      }
    });
  }
  /**
   * Register command: Enable renaming for note
   * Uses checkCallback to only show when file has disable property
   */
  registerEnableRenamingCommand() {
    if (!this.settings.commandPaletteVisibility.enableRenaming) {
      return;
    }
    this.plugin.addCommand({
      id: "enable-renaming-for-note",
      name: "Enable renaming for note",
      icon: "square-check",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile || activeFile.extension !== "md") {
          return false;
        }
        verboseLog(this.plugin, `Enable renaming checkCallback called for: ${activeFile.basename}, checking=${checking}`);
        const fileCache = this.app.metadataCache.getFileCache(activeFile);
        let hasProperty = false;
        verboseLog(this.plugin, `Enable renaming: fileCache exists=${!!fileCache}, frontmatter exists=${!!(fileCache && fileCache.frontmatter)}`);
        if (fileCache && fileCache.frontmatter) {
          const value = fileCache.frontmatter[this.settings.disableRenamingKey];
          verboseLog(this.plugin, `Enable renaming: raw property value="${value}" (type: ${typeof value}), key="${this.settings.disableRenamingKey}"`);
          if (value !== void 0 && value !== null) {
            const { normalizePropertyValue: normalizePropertyValue2 } = (init_utils(), __toCommonJS(utils_exports));
            const normalizedValue = normalizePropertyValue2(value);
            const normalizedExpected = normalizePropertyValue2(this.settings.disableRenamingValue);
            verboseLog(this.plugin, `Enable renaming normalized: value="${normalizedValue}" (type: ${typeof normalizedValue}), expected="${normalizedExpected}" (type: ${typeof normalizedExpected})`);
            if (typeof normalizedValue === "string" && typeof normalizedExpected === "string") {
              hasProperty = normalizedValue.toLowerCase() === normalizedExpected.toLowerCase();
            } else {
              hasProperty = normalizedValue === normalizedExpected;
            }
            verboseLog(this.plugin, `Enable renaming comparison result: hasProperty=${hasProperty}`);
          } else {
            verboseLog(this.plugin, `Enable renaming: property value is undefined or null`);
          }
        } else {
          verboseLog(this.plugin, `Enable renaming: no frontmatter found`);
        }
        if (!hasProperty) {
          verboseLog(this.plugin, `Enable renaming command hidden: hasProperty=${hasProperty}`);
          return false;
        }
        verboseLog(this.plugin, `Enable renaming command shown: hasProperty=${hasProperty}`);
        if (!checking) {
          verboseLog(this.plugin, `Executing enable renaming for: ${activeFile.basename}`);
          this.executeEnableRenaming();
        }
        return true;
      }
    });
  }
  /**
   * Execute disable renaming (shared logic for command and context menu)
   */
  async executeDisableRenaming() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "md") {
      new import_obsidian23.Notice("Error: no active note.");
      return;
    }
    await this.plugin.propertyManager.ensurePropertyTypeIsCheckbox();
    const hasProperty = await hasDisablePropertyInFile(activeFile, this.app, this.settings.disableRenamingKey, this.settings.disableRenamingValue);
    try {
      if (!hasProperty) {
        await this.app.fileManager.processFrontMatter(activeFile, (frontmatter) => {
          const value = this.settings.disableRenamingValue;
          if (value === "true") {
            frontmatter[this.settings.disableRenamingKey] = true;
          } else if (value === "false") {
            frontmatter[this.settings.disableRenamingKey] = false;
          } else {
            frontmatter[this.settings.disableRenamingKey] = value;
          }
        });
      }
      new import_obsidian23.Notice(`Disabled renaming for: ${activeFile.basename}`);
    } catch (error) {
      console.error("Failed to disable renaming:", error);
      new import_obsidian23.Notice(`Failed to disable renaming. Check console for details.`);
    }
  }
  /**
   * Execute enable renaming (shared logic for command and context menu)
   */
  async executeEnableRenaming() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "md") {
      new import_obsidian23.Notice("Error: no active note.");
      return;
    }
    const hasProperty = await hasDisablePropertyInFile(activeFile, this.app, this.settings.disableRenamingKey, this.settings.disableRenamingValue);
    try {
      if (hasProperty) {
        await this.app.fileManager.processFrontMatter(activeFile, (frontmatter) => {
          delete frontmatter[this.settings.disableRenamingKey];
        });
      }
      new import_obsidian23.Notice(`Enabled renaming for: ${activeFile.basename}`);
    } catch (error) {
      console.error("Failed to enable renaming:", error);
      new import_obsidian23.Notice(`Failed to enable renaming. Check console for details.`);
    }
  }
  /**
   * Execute toggle automatic renaming (shared logic for command and ribbon)
   */
  async executeToggleAutomaticRenaming() {
    const newValue = this.settings.renameNotes === "automatically" ? "manually" : "automatically";
    this.settings.renameNotes = newValue;
    this.plugin.debugLog("renameNotes", newValue);
    await this.plugin.saveSettings();
    verboseLog(this.plugin, `Showing notice: Automatic renaming ${newValue === "automatically" ? "enabled" : "disabled"}.`);
    new import_obsidian23.Notice(`Automatic renaming ${newValue === "automatically" ? "enabled" : "disabled"}.`);
  }
  /**
   * Register command: Toggle automatic renaming
   */
  registerToggleAutomaticRenamingCommand() {
    if (!this.settings.commandPaletteVisibility.toggleAutomaticRenaming) {
      return;
    }
    this.plugin.addCommand({
      id: "toggle-automatic-renaming",
      name: "Toggle automatic renaming",
      icon: "file-cog",
      callback: () => this.executeToggleAutomaticRenaming()
    });
  }
};

// src/core/title-insertion.ts
var import_obsidian24 = require("obsidian");
init_utils();
init_constants();
var TitleInsertion = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async insertTitleOnCreation(file) {
    try {
      const untitledPattern = /^Untitled(\s\d+)?$/;
      if (untitledPattern.test(file.basename)) {
        verboseLog(this.plugin, `Skipping title insertion for untitled file: ${file.path}`);
        return;
      }
      let content;
      try {
        content = await this.plugin.app.vault.read(file);
      } catch (error) {
        console.error(`Failed to read file ${file.path} for title insertion:`, error);
        return;
      }
      verboseLog(this.plugin, `Title insertion delay complete. File content length: ${content.length} chars, trimmed: "${content.trim()}"`);
      if (content.trim() !== "") {
        verboseLog(this.plugin, `Skipping title insertion - file already has content: ${file.path}`);
        return;
      }
      let cleanTitle = file.basename;
      for (const [forbiddenChar, normalChar] of Object.entries(TITLE_CHAR_REVERSAL_MAP)) {
        cleanTitle = cleanTitle.replaceAll(forbiddenChar, normalChar);
      }
      verboseLog(this.plugin, `Inserting title "${cleanTitle}" in new file: ${file.path}`);
      const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian24.MarkdownView);
      const inCanvas = !activeView;
      let newContent = cleanTitle;
      if (!inCanvas && this.plugin.settings.moveCursorToFirstLine) {
        if (this.plugin.settings.placeCursorAtLineEnd) {
          newContent += "\n";
        } else {
          newContent += "\n";
        }
      } else {
        newContent += "\n";
      }
      let currentContent;
      let retryCount = 0;
      const maxRetries = 3;
      const retryDelay = 500;
      do {
        try {
          currentContent = await this.plugin.app.vault.read(file);
          verboseLog(this.plugin, `Re-read file content (attempt ${retryCount + 1}). Length: ${currentContent.length} chars`);
          if (currentContent.trim() !== "") {
            verboseLog(this.plugin, `Template content found after ${retryCount + 1} attempts`);
            break;
          }
          if (retryCount < maxRetries - 1) {
            verboseLog(this.plugin, `File still empty, retrying in ${retryDelay}ms...`);
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
          }
        } catch (error) {
          console.error(`Failed to re-read file ${file.path} for title insertion:`, error);
          return;
        }
        retryCount++;
      } while (retryCount < maxRetries && currentContent.trim() === "");
      if (currentContent.trim() !== "") {
        verboseLog(this.plugin, `File now has template content, inserting title into existing content`);
        const metadata = this.plugin.app.metadataCache.getFileCache(file);
        const lines = currentContent.split("\n");
        if (metadata == null ? void 0 : metadata.frontmatterPosition) {
          const insertLine = metadata.frontmatterPosition.end.line + 1;
          lines.splice(insertLine, 0, cleanTitle);
          verboseLog(this.plugin, `Inserted title after frontmatter at line ${insertLine}`);
        } else {
          lines.unshift(cleanTitle);
          verboseLog(this.plugin, `Inserted title at beginning of file`);
        }
        const finalContent = lines.join("\n");
        await this.plugin.app.vault.modify(file, finalContent);
      } else {
        verboseLog(this.plugin, `File still empty, inserting title as new content`);
        await this.plugin.app.vault.modify(file, newContent);
      }
      if (!inCanvas && this.plugin.settings.moveCursorToFirstLine) {
        setTimeout(() => {
          this.handleCursorPositioning(file);
        }, 50);
      }
      verboseLog(this.plugin, `Successfully inserted title in ${file.path}`);
    } catch (error) {
      console.error(`Error inserting title on creation for ${file.path}:`, error);
    }
  }
  async handleCursorPositioning(file) {
    var _a, _b, _c, _d, _e, _f, _g;
    try {
      verboseLog(this.plugin, `handleCursorPositioning called for ${file.path}`);
      const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian24.MarkdownView);
      verboseLog(this.plugin, `Active view found: ${!!activeView}, file matches: ${((_a = activeView == null ? void 0 : activeView.file) == null ? void 0 : _a.path) === file.path}`);
      if (activeView && ((_b = activeView.file) == null ? void 0 : _b.path) === file.path) {
        await activeView.leaf.setViewState({
          type: "markdown",
          state: {
            mode: "source",
            source: false
          }
        });
        await ((_c = activeView.editor) == null ? void 0 : _c.focus());
        let titleLineNumber = 0;
        let titleLineLength = 0;
        const metadata = this.plugin.app.metadataCache.getFileCache(file);
        if (metadata == null ? void 0 : metadata.frontmatterPosition) {
          titleLineNumber = metadata.frontmatterPosition.end.line + 1;
          verboseLog(this.plugin, `Found frontmatter ending at line ${metadata.frontmatterPosition.end.line}, title on line ${titleLineNumber}`);
        } else {
          titleLineNumber = 0;
          verboseLog(this.plugin, `No frontmatter found, title on line ${titleLineNumber}`);
        }
        titleLineLength = ((_e = (_d = activeView.editor) == null ? void 0 : _d.getLine(titleLineNumber)) == null ? void 0 : _e.length) || 0;
        if (this.plugin.settings.placeCursorAtLineEnd) {
          (_f = activeView.editor) == null ? void 0 : _f.setCursor({ line: titleLineNumber, ch: titleLineLength });
          verboseLog(this.plugin, `Moved cursor to end of title line ${titleLineNumber} (${titleLineLength} chars) via handleCursorPositioning for ${file.path}`);
        } else {
          (_g = activeView.editor) == null ? void 0 : _g.setCursor({ line: titleLineNumber + 1, ch: 0 });
          verboseLog(this.plugin, `Moved cursor to line after title (line ${titleLineNumber + 1}) via handleCursorPositioning for ${file.path}`);
        }
      } else {
        verboseLog(this.plugin, `Skipping cursor positioning - no matching active view for ${file.path}`);
      }
    } catch (error) {
      console.error(`Error positioning cursor for ${file.path}:`, error);
    }
  }
};

// src/core/link-manager.ts
var import_obsidian25 = require("obsidian");
init_utils();
init_modals();
var LinkManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async addSafeInternalLink() {
    var _a;
    const activeEditor = (_a = this.plugin.app.workspace.activeEditor) == null ? void 0 : _a.editor;
    if (!activeEditor) {
      new import_obsidian25.Notice("Error: no active note.");
      return;
    }
    const selection = activeEditor.getSelection();
    if (selection.trim()) {
      const safeLinkTarget = generateSafeLinkTarget(selection, this.plugin.settings);
      const wikiLink = `[[${safeLinkTarget}]]`;
      activeEditor.replaceSelection(wikiLink);
    } else {
      const modal = new InternalLinkModal(this.plugin.app, this.plugin, (linkTarget) => {
        const safeLinkTarget = generateSafeLinkTarget(linkTarget, this.plugin.settings);
        const wikiLink = `[[${safeLinkTarget}]]`;
        activeEditor.replaceSelection(wikiLink);
      });
      modal.open();
    }
  }
  async addSafeInternalLinkWithCaption() {
    var _a;
    const activeEditor = (_a = this.plugin.app.workspace.activeEditor) == null ? void 0 : _a.editor;
    if (!activeEditor) {
      new import_obsidian25.Notice("Error: no active note.");
      return;
    }
    const selection = activeEditor.getSelection();
    if (selection.trim()) {
      const safeLinkTarget = generateSafeLinkTarget(selection, this.plugin.settings);
      const wikiLink = `[[${safeLinkTarget}|${selection}]]`;
      activeEditor.replaceSelection(wikiLink);
    } else {
      const modal = new InternalLinkModal(this.plugin.app, this.plugin, (linkTarget, linkCaption) => {
        const safeLinkTarget = generateSafeLinkTarget(linkTarget, this.plugin.settings);
        let wikiLink;
        if (linkCaption && linkCaption.trim()) {
          wikiLink = `[[${safeLinkTarget}|${linkCaption}]]`;
        } else {
          wikiLink = `[[${safeLinkTarget}|${linkTarget}]]`;
        }
        activeEditor.replaceSelection(wikiLink);
      }, true);
      modal.open();
    }
  }
};

// main.ts
var FirstLineIsTitle = class extends import_obsidian26.Plugin {
  constructor() {
    super(...arguments);
    this.isFullyLoaded = false;
    this.pluginLoadTime = 0;
    // Track files with pending metadata cache updates (for alias manager sync)
    this.pendingMetadataUpdates = /* @__PURE__ */ new Set();
    // Track FLIT modifications to suppress debug output
    this.flitModifications = /* @__PURE__ */ new Set();
    // Track batch operations to suppress debug output
    this.batchOperations = /* @__PURE__ */ new Set();
  }
  isTagWranglerEnabled() {
    return this.app.plugins.enabledPlugins.has("tag-wrangler");
  }
  cleanupStaleCache() {
    if (this.cacheManager) {
      this.cacheManager.forceCleanup();
      verboseLog(this, "Cache cleanup completed");
    }
  }
  async putFirstLineInTitleForFolder(folder) {
    return this.folderOperations.putFirstLineInTitleForFolder(folder);
  }
  async toggleFolderExclusion(folderPath) {
    return this.folderOperations.toggleFolderExclusion(folderPath);
  }
  async putFirstLineInTitleForTag(tagName, omitBodyTags = false, omitNestedTags = false) {
    return this.tagOperations.putFirstLineInTitleForTag(tagName, omitBodyTags, omitNestedTags);
  }
  async toggleTagExclusion(tagName) {
    return this.tagOperations.toggleTagExclusion(tagName);
  }
  // Debug logging helper for setting changes
  debugLog(settingName, value) {
    if (this.settings.verboseLogging) {
      console.debug(`Setting changed: ${settingName} = ${JSON.stringify(value)}`);
    }
  }
  // Debug file content output
  outputDebugFileContent(file, action, editorContent) {
    if (!this.settings.verboseLogging || !this.settings.debugOutputFullContent) {
      return;
    }
    try {
      const content = editorContent != null ? editorContent : "N/A (no editor content available)";
      console.debug(`CONTENT [${action}] ${file.path}:`);
      console.debug("--- FILE CONTENT START ---");
      console.debug(content);
      console.debug("--- FILE CONTENT END ---");
    } catch (error) {
      console.debug(`CONTENT [${action}] ${file.path}: Failed to read file:`, error);
    }
  }
  // Output all current settings when debug mode is enabled
  outputAllSettings() {
    if (!this.settings.verboseLogging) {
      return;
    }
    console.debug("SETTINGS: Complete configuration dump:");
    console.debug("--- SETTINGS START ---");
    console.debug(JSON.stringify(this.settings, null, 2));
    console.debug("--- SETTINGS END ---");
  }
  async insertTitleOnCreation(file) {
    return this.titleInsertion.insertTitleOnCreation(file);
  }
  getSelectedFolders() {
    return this.folderOperations.getSelectedFolders();
  }
  getAllMarkdownFilesInFolder(folder) {
    return this.folderOperations.getAllMarkdownFilesInFolder(folder);
  }
  async processMultipleFolders(folders, action) {
    return this.folderOperations.processMultipleFolders(folders, action);
  }
  async processMultipleFiles(files, action) {
    if (files.length === 0) return;
    let processed = 0;
    let skipped = 0;
    let errors = 0;
    new import_obsidian26.Notice(`Renaming ${files.length} notes...`);
    const exclusionOverrides = { ignoreFolder: true, ignoreTag: true, ignoreProperty: true };
    for (const file of files) {
      try {
        if (action === "rename") {
          const result = await this.renameEngine.processFile(file, true, true, void 0, false, exclusionOverrides);
          if (result.success) {
            processed++;
          } else {
            skipped++;
          }
        }
      } catch (error) {
        console.error(`Error processing file ${file.path}:`, error);
        errors++;
      }
    }
    if (errors > 0) {
      new import_obsidian26.Notice(`Renamed ${processed}/${files.length} notes with ${errors} errors. Check console for details.`, 0);
    } else {
      new import_obsidian26.Notice(`Renamed ${processed}/${files.length} notes.`, 0);
    }
  }
  // registerDynamicCommands removed - dynamic command visibility handled via checkCallback in CommandRegistrar
  async disableRenamingForNote() {
    return this.commandRegistrar.executeDisableRenaming();
  }
  async enableRenamingForNote() {
    return this.commandRegistrar.executeEnableRenaming();
  }
  async addSafeInternalLink() {
    return this.linkManager.addSafeInternalLink();
  }
  async addSafeInternalLinkWithCaption() {
    return this.linkManager.addSafeInternalLinkWithCaption();
  }
  updatePropertyVisibility() {
    this.propertyVisibility.updatePropertyVisibility();
  }
  checkAndShowNotices() {
    const today = this.getTodayDateString();
    if (!this.settings.hasShownFirstTimeNotice) {
      this.showFirstTimeNotice();
      this.updateLastUsageDate(today);
      return;
    }
    if (this.settings.lastUsageDate && this.isInactive(this.settings.lastUsageDate, today) && this.settings.renameNotes === "automatically") {
      this.showInactivityNotice();
    }
    this.updateLastUsageDate(today);
  }
  getTodayDateString() {
    const today = /* @__PURE__ */ new Date();
    return today.getFullYear() + "-" + String(today.getMonth() + 1).padStart(2, "0") + "-" + String(today.getDate()).padStart(2, "0");
  }
  getCurrentTimestamp() {
    const now = /* @__PURE__ */ new Date();
    return now.getFullYear() + "-" + String(now.getMonth() + 1).padStart(2, "0") + "-" + String(now.getDate()).padStart(2, "0") + " " + String(now.getHours()).padStart(2, "0") + ":" + String(now.getMinutes()).padStart(2, "0");
  }
  isInactive(lastUsageDate, todayDate) {
    const lastDate = new Date(lastUsageDate);
    const today = new Date(todayDate);
    const daysDiff = Math.floor((today.getTime() - lastDate.getTime()) / (1e3 * 60 * 60 * 24));
    return daysDiff > 30;
  }
  showFirstTimeNotice() {
    new import_obsidian26.Notice("Please open First Line is Title settings to set your preferences. Ensure your files are backed up.");
    this.settings.hasShownFirstTimeNotice = true;
    this.saveSettings();
  }
  showInactivityNotice() {
    new import_obsidian26.Notice("Please open First Line is Title settings to set your preferences. Ensure your files are backed up.");
  }
  updateLastUsageDate(today) {
    if (this.settings.lastUsageDate !== today) {
      this.settings.lastUsageDate = today;
      this.saveSettings();
    }
  }
  // Call this method at the start of any significant plugin operation
  trackUsage() {
    const today = this.getTodayDateString();
    this.updateLastUsageDate(today);
  }
  switchFileReadMode(mode) {
    this.settings.fileReadMethod = mode;
    this.editorLifecycle.clearCheckingSystems();
    this.editorLifecycle.initializeCheckingSystem();
  }
  markFlitModificationStart(path) {
    this.flitModifications.add(path);
  }
  markFlitModificationEnd(path) {
    setTimeout(() => {
      this.flitModifications.delete(path);
    }, 100);
  }
  markBatchOperationStart(path) {
    this.batchOperations.add(path);
  }
  markBatchOperationEnd(path) {
    setTimeout(() => {
      this.batchOperations.delete(path);
    }, 100);
  }
  async onload() {
    this.pluginLoadTime = Date.now();
    await this.loadSettings();
    if (this.settings.verboseLogging && this.settings.debugEnabledTimestamp) {
      const enabledTime = new Date(this.settings.debugEnabledTimestamp).getTime();
      const currentTime = (/* @__PURE__ */ new Date()).getTime();
      const hoursPassed = (currentTime - enabledTime) / (1e3 * 60 * 60);
      if (hoursPassed >= 24) {
        this.settings.verboseLogging = false;
        await this.saveSettings();
      }
    }
    this.cacheManager = new CacheManager(this);
    this.checkAndShowNotices();
    this.renameEngine = new RenameEngine(this);
    this.aliasManager = new AliasManager(this);
    this.contextMenuManager = new ContextMenuManager(this);
    this.folderOperations = new FolderOperations(
      this.app,
      this.settings,
      this.renameEngine,
      this.saveSettings.bind(this),
      this.debugLog.bind(this),
      this.processMultipleFiles.bind(this)
    );
    this.tagOperations = new TagOperations(
      this.app,
      this.settings,
      this.renameEngine,
      this.saveSettings.bind(this),
      this.debugLog.bind(this)
    );
    this.fileOperations = new FileOperations(this);
    this.editorLifecycle = new EditorLifecycleManager(this);
    this.workspaceIntegration = new WorkspaceIntegration(this);
    this.propertyManager = new PropertyManager(this);
    this.titleInsertion = new TitleInsertion(this);
    this.linkManager = new LinkManager(this);
    this.propertyVisibility = new PropertyVisibility(this);
    this.settings.osPreset = detectOS();
    await this.saveSettings();
    verboseLog(this, "Plugin loaded", this.settings);
    verboseLog(this, `Detected OS: \`${this.settings.osPreset}\``);
    const pluginInitializer = new PluginInitializer(this);
    await pluginInitializer.initializeFirstEnableLogic();
    await pluginInitializer.loadStyles();
    this.addSettingTab(new FirstLineIsTitleSettings(this.app, this));
    this.commandRegistrar = new CommandRegistrar(this);
    this.commandRegistrar.registerCommands();
    if (this.settings.enableRibbon) {
      this.app.workspace.onLayoutReady(() => {
        setTimeout(() => {
          this.workspaceIntegration.registerRibbonIcons();
        }, 0);
      });
    }
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (!this.settings.enableContextMenus) return;
        let hasVisibleItems = false;
        if (file instanceof import_obsidian26.TFile && file.extension === "md") {
          if (this.settings.commandVisibility.filePutFirstLineInTitle) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle("Put first line in title").setIcon("file-pen").onClick(() => this.commandRegistrar.executeRenameCurrentFile());
            });
          }
          const fileCache = this.app.metadataCache.getFileCache(file);
          let hasDisableProperty = false;
          if (fileCache && fileCache.frontmatter) {
            const frontmatter = fileCache.frontmatter;
            const value = frontmatter[this.settings.disableRenamingKey];
            if (value !== void 0 && value !== null) {
              const { normalizePropertyValue: normalizePropertyValue2 } = (init_utils(), __toCommonJS(utils_exports));
              const normalizedValue = normalizePropertyValue2(value);
              const normalizedExpected = normalizePropertyValue2(this.settings.disableRenamingValue);
              if (typeof normalizedValue === "string" && typeof normalizedExpected === "string") {
                hasDisableProperty = normalizedValue.toLowerCase() === normalizedExpected.toLowerCase();
              } else {
                hasDisableProperty = normalizedValue === normalizedExpected;
              }
            }
          }
          if (!hasDisableProperty && this.settings.commandVisibility.fileExclude) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle("Disable renaming for note").setIcon("square-x").onClick(() => this.commandRegistrar.executeDisableRenaming());
            });
          } else if (hasDisableProperty && this.settings.commandVisibility.fileStopExcluding) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle("Enable renaming for note").setIcon("square-check").onClick(() => this.commandRegistrar.executeEnableRenaming());
            });
          }
        } else if (file instanceof import_obsidian26.TFolder) {
          if (this.settings.commandVisibility.folderPutFirstLineInTitle) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle("Put first line in title").setIcon("folder-pen").onClick(() => {
                new RenameFolderModal(this.app, this, file).open();
              });
            });
          }
          const shouldShowDisable = this.contextMenuManager.shouldShowDisableMenuForFolder(file.path);
          const menuText = this.contextMenuManager.getFolderMenuText(file.path);
          if (shouldShowDisable && this.settings.commandVisibility.folderExclude) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle(menuText.disable).setIcon("square-x").onClick(async () => {
                await this.toggleFolderExclusion(file.path);
              });
            });
          }
          if (!shouldShowDisable && this.settings.commandVisibility.folderStopExcluding) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle(menuText.enable).setIcon("square-check").onClick(async () => {
                await this.toggleFolderExclusion(file.path);
              });
            });
          }
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("files-menu", (menu, files) => {
        if (!this.settings.enableContextMenus) return;
        const markdownFiles = files.filter((file) => file instanceof import_obsidian26.TFile && file.extension === "md");
        const folders = files.filter((file) => file instanceof import_obsidian26.TFolder);
        if (markdownFiles.length > 0 && folders.length > 0) return;
        if (markdownFiles.length === 0 && folders.length === 0) return;
        let hasVisibleItems = false;
        if (markdownFiles.length > 0) {
          if (this.settings.commandVisibility.filePutFirstLineInTitle) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle(`Put first line in title (${markdownFiles.length} notes)`).setIcon("file-pen").onClick(async () => {
                new RenameModal(this.app, this, markdownFiles).open();
              });
            });
          }
          if (this.settings.commandVisibility.fileExclude) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle(`Disable renaming (${markdownFiles.length} notes)`).setIcon("square-x").onClick(async () => {
                new DisableEnableModal(this.app, this, markdownFiles, "disable").open();
              });
            });
          }
          if (this.settings.commandVisibility.fileStopExcluding) {
            if (!hasVisibleItems) {
              menu.addSeparator();
              hasVisibleItems = true;
            }
            menu.addItem((item) => {
              item.setTitle(`Enable renaming (${markdownFiles.length} notes)`).setIcon("square-check").onClick(async () => {
                new DisableEnableModal(this.app, this, markdownFiles, "enable").open();
              });
            });
          }
        }
        if (folders.length > 1) {
          this.contextMenuManager.addMultiFolderMenuItems(menu, folders);
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        if (!this.settings.enableContextMenus) return;
        const token = editor.getClickableTokenAt(editor.getCursor());
        if ((token == null ? void 0 : token.type) === "tag") {
          const tagName = token.text.startsWith("#") ? token.text.slice(1) : token.text;
          this.contextMenuManager.addTagMenuItems(menu, tagName);
        }
      })
    );
    this.registerDomEvent(document, "contextmenu", (evt) => {
      var _a;
      if (!this.settings.enableContextMenus) return;
      const target = evt.target;
      const tagElement = target.closest(".tag-pane-tag");
      if (tagElement) {
        const tagNameEl = tagElement.querySelector(".tag-pane-tag-text, .tag-pane-tag .tree-item-inner-text");
        const tagText = (_a = tagNameEl == null ? void 0 : tagNameEl.textContent) == null ? void 0 : _a.trim();
        if (tagText) {
          const tagName = tagText.startsWith("#") ? tagText.slice(1) : tagText;
          const menu = this.contextMenuManager.menuForEvent(evt);
          this.contextMenuManager.addTagMenuItems(menu, tagName);
        }
        return;
      }
      const yamlTagElement = target.closest('.metadata-property[data-property-key="tags"] .multi-select-pill');
      if (yamlTagElement) {
        return;
      }
      const readingModeTag = target.closest('a.tag[href^="#"]');
      if (readingModeTag) {
        const href = readingModeTag.getAttribute("href");
        if (href) {
          const tagName = href.slice(1);
          const menu = this.contextMenuManager.menuForEvent(evt);
          this.contextMenuManager.addTagMenuItems(menu, tagName);
        }
        return;
      }
    }, true);
    this.registerDomEvent(document, "contextmenu", (evt) => {
      var _a;
      if (!this.settings.enableContextMenus) return;
      const target = evt.target;
      const yamlTagElement = target.closest('.metadata-property[data-property-key="tags"] .multi-select-pill');
      if (yamlTagElement) {
        const tagText = (_a = yamlTagElement.textContent) == null ? void 0 : _a.trim();
        if (tagText) {
          const tagName = tagText.startsWith("#") ? tagText.slice(1) : tagText;
          const plugin = this;
          const remove = around(import_obsidian26.Menu.prototype, {
            showAtPosition(old) {
              return function(...args) {
                remove();
                plugin.contextMenuManager.addTagMenuItems(this, tagName);
                return old.apply(this, args);
              };
            }
          });
          if (import_obsidian26.Menu.forEvent) {
            const remove2 = around(import_obsidian26.Menu, { forEvent(old) {
              return function(ev) {
                const m = old.call(this, evt);
                if (ev === evt) {
                  plugin.contextMenuManager.addTagMenuItems(m, tagName);
                  remove();
                }
                remove2();
                return m;
              };
            } });
            setTimeout(remove2, 0);
          }
          setTimeout(remove, 0);
        }
      }
    }, true);
    this.registerEvent(
      this.app.workspace.on("search:results-menu", (menu, leaf) => {
        var _a, _b;
        if (!this.settings.enableVaultSearchContextMenu) return;
        let files = [];
        if ((_b = (_a = leaf.dom) == null ? void 0 : _a.vChildren) == null ? void 0 : _b.children) {
          leaf.dom.vChildren.children.forEach((e) => {
            if (e.file && e.file instanceof import_obsidian26.TFile && e.file.extension === "md") {
              files.push(e.file);
            }
          });
        }
        if (files.length < 1) return;
        let hasVisibleItems = false;
        if (this.settings.vaultSearchContextMenuVisibility.putFirstLineInTitle) {
          if (!hasVisibleItems) {
            menu.addSeparator();
            hasVisibleItems = true;
          }
          menu.addItem((item) => {
            item.setTitle(`Put first line in title (${files.length} notes)`).setIcon("file-pen").onClick(async () => {
              new RenameModal(this.app, this, files).open();
            });
          });
        }
        if (this.settings.vaultSearchContextMenuVisibility.disable) {
          if (!hasVisibleItems) {
            menu.addSeparator();
            hasVisibleItems = true;
          }
          menu.addItem((item) => {
            item.setTitle(`Disable renaming (${files.length} notes)`).setIcon("square-x").onClick(async () => {
              new DisableEnableModal(this.app, this, files, "disable").open();
            });
          });
        }
        if (this.settings.vaultSearchContextMenuVisibility.enable) {
          if (!hasVisibleItems) {
            menu.addSeparator();
            hasVisibleItems = true;
          }
          menu.addItem((item) => {
            item.setTitle(`Enable renaming (${files.length} notes)`).setIcon("square-check").onClick(async () => {
              new DisableEnableModal(this.app, this, files, "enable").open();
            });
          });
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if (this.settings.renameNotes === "automatically" && this.settings.renameOnFocus && leaf && leaf.view && leaf.view.file && leaf.view.file instanceof import_obsidian26.TFile && leaf.view.file.extension === "md") {
          verboseLog(this, `File focused: ${leaf.view.file.path}`);
          this.renameEngine.processFile(leaf.view.file, true);
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-change", async (editor, info) => {
        var _a, _b;
        verboseLog(this, `Editor change detected for file: ${((_a = info.file) == null ? void 0 : _a.path) || "unknown"}`);
        if (info.file && editor) {
          const content = editor.getValue();
          this.fileOperations.checkYamlAndResolve(info.file, content);
          this.outputDebugFileContent(info.file, "MODIFIED", content);
        }
        if (this.settings.renameNotes !== "automatically") {
          verboseLog(this, `Skipping: automatic renaming disabled (${this.settings.renameNotes})`);
          return;
        }
        if (!info.file || info.file.extension !== "md") {
          verboseLog(this, `Skipping: not markdown file (${((_b = info.file) == null ? void 0 : _b.extension) || "no file"})`);
          return;
        }
        if (!this.isFullyLoaded) {
          verboseLog(this, `Skipping: plugin not fully loaded`);
          return;
        }
        if (this.settings.fileReadMethod === "Editor") {
          if (this.settings.checkInterval === 0) {
            verboseLog(this, `Processing immediate change for: ${info.file.path}`);
            await this.renameEngine.processEditorChangeOptimal(editor, info.file);
          } else {
            verboseLog(this, `Editor changed, starting/checking throttle timer for: ${info.file.path}`);
            this.editorLifecycle.handleEditorChangeWithThrottle(editor, info.file);
          }
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (abstractFile) => {
        if (!(abstractFile instanceof import_obsidian26.TFile) || abstractFile.extension !== "md") {
          return;
        }
        if (this.settings.fileReadMethod !== "Cache" && this.settings.fileReadMethod !== "File") {
          return;
        }
        if (this.settings.renameNotes !== "automatically") {
          verboseLog(this, `Skipping: automatic renaming disabled (${this.settings.renameNotes})`);
          return;
        }
        if (!this.isFullyLoaded) {
          verboseLog(this, `Skipping: plugin not fully loaded`);
          return;
        }
        const noDelay = this.settings.checkInterval === 0;
        verboseLog(this, `File modified: ${abstractFile.path}`);
        this.renameEngine.processFile(abstractFile, noDelay);
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (abstractFile) => {
        if (abstractFile instanceof import_obsidian26.TFile) {
          if (this.cacheManager) {
            this.cacheManager.notifyFileDeleted(abstractFile.path);
          }
          verboseLog(this, `File deleted, cleaned up cache: ${abstractFile.path}`);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (abstractFile, oldPath) => {
        if (abstractFile instanceof import_obsidian26.TFile) {
          if (this.cacheManager) {
            this.cacheManager.notifyFileRenamed(oldPath, abstractFile.path);
          }
          verboseLog(this, `File renamed, updated cache: ${oldPath} -> ${abstractFile.path}`);
        }
      })
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        if (this.pendingMetadataUpdates.has(file.path)) {
          this.pendingMetadataUpdates.delete(file.path);
          verboseLog(this, `Metadata cache updated, cleared pending flag: ${file.path}`);
        }
      })
    );
    this.propertyManager.setupNotificationSuppression();
    this.workspaceIntegration.setupCursorPositioning();
    this.workspaceIntegration.setupSaveEventHook();
    this.updatePropertyVisibility();
    this.app.workspace.onLayoutReady(() => {
      setTimeout(() => {
        this.isFullyLoaded = true;
        this.editorLifecycle.initializeCheckingSystem();
        verboseLog(this, "Checking system initialized based on checkInterval setting");
      }, 1e3);
    });
  }
  onunload() {
    if (this.cacheManager) {
      this.cacheManager.dispose();
    }
    if (this.editorLifecycle) {
      this.editorLifecycle.clearCheckingSystems();
    }
    if (this.workspaceIntegration) {
      this.workspaceIntegration.cleanup();
    }
    if (this.propertyManager) {
      this.propertyManager.cleanupNotificationSuppression();
    }
    if (this.propertyVisibility) {
      this.propertyVisibility.cleanup();
    }
    if (this.cacheManager) {
      this.cacheManager.clearAllAliasTimers();
    }
    verboseLog(this, "Plugin unloaded");
  }
  async loadSettings() {
    const loadedData = await this.loadData() || {};
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      loadedData
    );
    if (!this.settings.scopeStrategy) {
      this.settings.scopeStrategy = "Enable in all notes except below";
    }
    if (this.settings.excludedFolders.length === 0) {
      this.settings.excludedFolders.push("");
    }
    if (this.settings.excludedTags.length === 0) {
      this.settings.excludedTags.push("");
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
